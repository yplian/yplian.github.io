<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宁静致远</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luckyp.top/"/>
  <updated>2025-06-02T03:59:50.000Z</updated>
  <id>https://luckyp.top/</id>
  
  <author>
    <name>luckyp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大模型微调数据集</title>
    <link href="https://luckyp.top/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://luckyp.top/大模型微调数据集/</id>
    <published>2025-06-02T03:59:50.000Z</published>
    <updated>2025-06-02T03:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>大模型微调数据集<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 DeepSeek-R1 等推理模型的爆火，越来越多的开发者开始尝试将大模型微调到特定领域。然而，在实际操作中，80%以上的微调问题都源于数据集的准备不当。本文将为您详细解析如何为不同的微调任务准备高质量的数据集。</p><h2 id="一、为什么数据集如此重要？"><a href="#一、为什么数据集如此重要？" class="headerlink" title="一、为什么数据集如此重要？"></a>一、为什么数据集如此重要？</h2><p>在大模型微调中，数据集的质量直接决定了最终效果。就像学生参加补习班一样：</p><ul><li><strong>优质教材</strong>：数据集格式规范、内容准确</li><li><strong>充足练习</strong>：数据集数量足够、覆盖全面</li><li><strong>针对性强</strong>：数据集与目标任务高度匹配</li></ul><p>如果教材本身就有错误，再优秀的老师和教学方法也无法帮助学生取得好成绩。</p><h2 id="二、微调任务类型与数据集需求"><a href="#二、微调任务类型与数据集需求" class="headerlink" title="二、微调任务类型与数据集需求"></a>二、微调任务类型与数据集需求</h2><h3 id="2-1-指令微调（Instruction-Tuning）"><a href="#2-1-指令微调（Instruction-Tuning）" class="headerlink" title="2.1 指令微调（Instruction Tuning）"></a>2.1 指令微调（Instruction Tuning）</h3><p><strong>适用场景：</strong> 智能翻译、文档处理、教育辅导</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"将这句英文翻译成中文"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"Hello, how are you?"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"你好，你好吗？"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键特点：</strong> 任务明确，有标准答案，相对容易准备</p><p><strong>典型应用场景：</strong></p><ul><li>智能翻译：多语言文本翻译，支持专业术语翻译</li><li>文档处理：自动摘要生成、格式转换、信息提取</li><li>教育辅导：作业批改、学习路径规划、知识点解答</li><li>内容生成：根据关键词生成文章、产品描述、营销文案</li></ul><p>eg:</p><ul><li><a href="https://huggingface.co/datasets/shibing624/alpaca-zh" target="_blank" rel="noopener">https://huggingface.co/datasets/shibing624/alpaca-zh</a></li><li><a href="https://huggingface.co/datasets/fka/awesome-chatgpt-prompts" target="_blank" rel="noopener">https://huggingface.co/datasets/fka/awesome-chatgpt-prompts</a></li></ul><h3 id="2-2-对话微调（Dialogue-Tuning）"><a href="#2-2-对话微调（Dialogue-Tuning）" class="headerlink" title="2.2 对话微调（Dialogue Tuning）"></a>2.2 对话微调（Dialogue Tuning）</h3><p><strong>适用场景：</strong> 智能客服、聊天机器人、语音助手</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dialogue"</span>: [</span><br><span class="line">    &#123; <span class="attr">"role"</span>: <span class="string">"user"</span>, <span class="attr">"content"</span>: <span class="string">"今天天气怎么样？"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"role"</span>: <span class="string">"assistant"</span>, <span class="attr">"content"</span>: <span class="string">"北京今日多云转晴，气温22℃"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"role"</span>: <span class="string">"user"</span>, <span class="attr">"content"</span>: <span class="string">"适合去长城吗？"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"role"</span>: <span class="string">"assistant"</span>, <span class="attr">"content"</span>: <span class="string">"天气不错，建议携带外套防晒"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键特点：</strong> 注重上下文连贯性和多轮对话理解</p><p><strong>典型应用场景：</strong></p><ul><li>智能客服：处理用户咨询、投诉处理、问题解答</li><li>聊天机器人：日常闲聊、情感陪伴、娱乐互动</li><li>语音助手：语音交互、任务执行、设备控制</li><li>在线教育：一对一辅导、答疑解惑、学习陪伴</li></ul><p>eg: <a href="https://huggingface.co/datasets/philschmid/guanaco-sharegpt-style" target="_blank" rel="noopener">https://huggingface.co/datasets/philschmid/guanaco-sharegpt-style</a></p><h3 id="2-3-领域适配（Domain-Adaptation）"><a href="#2-3-领域适配（Domain-Adaptation）" class="headerlink" title="2.3 领域适配（Domain Adaptation）"></a>2.3 领域适配（Domain Adaptation）</h3><p><strong>适用场景：</strong> 医疗诊断、法律咨询、金融分析</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"分析患者症状"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"55岁男性，胸骨后疼痛3小时，服用硝酸甘油无效"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"建议诊断：急性心肌梗死，需立即心电图检查"</span>,</span><br><span class="line">  <span class="attr">"domain"</span>: <span class="string">"医疗"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键特点：</strong> 需要专业领域知识，数据准备难度较高</p><p><strong>典型应用场景：</strong></p><ul><li>医疗诊断：病历分析、症状诊断、用药建议</li><li>法律咨询：合同审查、法条解释、案例分析</li><li>金融分析：风险评估、投资建议、市场预测</li><li>科研辅助：文献综述、实验设计、数据解读</li></ul><p>eg: <a href="https://huggingface.co/datasets/qiaojin/PubMedQA" target="_blank" rel="noopener">https://huggingface.co/datasets/qiaojin/PubMedQA</a></p><h3 id="2-4-文本分类（Text-Classification）"><a href="#2-4-文本分类（Text-Classification）" class="headerlink" title="2.4 文本分类（Text Classification）"></a>2.4 文本分类（Text Classification）</h3><p><strong>适用场景：</strong> 情感分析、内容审核、新闻分类、意图识别</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"这款手机拍照效果惊艳，续航表现优秀，系统流畅"</span>,</span><br><span class="line">  <span class="attr">"label"</span>: <span class="string">"positive"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者带指令的分类格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"对以下商品评论进行情感分析"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"系统频繁卡顿，客服响应速度慢，不推荐购买"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"negative"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键特点：</strong> 需要明确的分类标签体系，标注一致性要求高</p><p><strong>典型应用场景：</strong></p><ul><li>情感分析：商品评论情感极性识别（正面/负面/中性）</li><li>内容审核：检测违规内容（涉政/暴力/广告/正常）</li><li>新闻分类：自动归类至财经/科技/体育等栏目</li><li>意图识别：用户query分类（咨询/投诉/比价/退换货）</li></ul><p>eg: <a href="https://huggingface.co/datasets/stanfordnlp/imdb" target="_blank" rel="noopener">https://huggingface.co/datasets/stanfordnlp/imdb</a></p><h3 id="2-5-推理微调（Reasoning-Tuning）"><a href="#2-5-推理微调（Reasoning-Tuning）" class="headerlink" title="2.5 推理微调（Reasoning Tuning）"></a>2.5 推理微调（Reasoning Tuning）</h3><p><strong>适用场景：</strong> DeepSeek-R1 等推理模型的微调</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"解决数学应用题"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"小明买3支铅笔每支2元，5本笔记本每本比铅笔贵4元，总花费？"</span>,</span><br><span class="line">  <span class="attr">"chain_of_thought"</span>: [</span><br><span class="line">    <span class="string">"铅笔总价：3×2=6元"</span>,</span><br><span class="line">    <span class="string">"笔记本单价：2+4=6元，总价：5×6=30元"</span>,</span><br><span class="line">    <span class="string">"合计：6+30=36元"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"总花费36元"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键特点：</strong> 包含思维链，适合需要推理过程的复杂任务</p><p><strong>推理模型适用场景：</strong></p><ul><li>代码生成与调试：理解复杂编程问题，生成高效代码解决方案</li><li>数学问题求解：提供详细解题步骤和准确答案</li><li>复杂数据分析：多步骤推理和策略规划</li><li>法律与金融分析：处理复杂文档，理解模糊信息</li></ul><p>eg: <a href="https://huggingface.co/datasets/AI-MO/NuminaMath-CoT" target="_blank" rel="noopener">https://huggingface.co/datasets/AI-MO/NuminaMath-CoT</a></p><h3 id="2-6-知识蒸馏（Knowledge-Distillation）"><a href="#2-6-知识蒸馏（Knowledge-Distillation）" class="headerlink" title="2.6 知识蒸馏（Knowledge Distillation）"></a>2.6 知识蒸馏（Knowledge Distillation）</h3><p><strong>适用场景：</strong> 模型压缩、成本优化、性能提升</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"解释什么是机器学习"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"请用简单的话解释机器学习的基本概念"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"机器学习是让计算机通过分析大量数据来自动学习规律，从而对新数据做出预测或决策的技术。就像人类通过经验学习一样，机器通过数据中的模式来提高自己的表现。"</span>,</span><br><span class="line">  <span class="attr">"teacher_model"</span>: <span class="string">"DeepSeek-V3"</span>,</span><br><span class="line">  <span class="attr">"student_model"</span>: <span class="string">"DeepSeek-7B"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键特点：</strong> 将大模型的知识迁移到小模型，保持性能的同时降低部署成本</p><p><strong>典型应用场景：</strong></p><ul><li>模型压缩：将大型模型的能力迁移到轻量级模型</li><li>成本优化：用小模型替代大模型，降低推理成本</li><li>边缘部署：适配资源受限的移动设备和边缘计算</li><li>特定任务优化：针对具体业务场景优化模型性能</li></ul><p><strong>蒸馏数据构造方法：</strong></p><ul><li>直接蒸馏：用大模型的输出作为小模型的训练目标</li><li>思维链蒸馏：保留大模型的推理过程，训练小模型的逻辑思维</li><li>多样本蒸馏：生成多个回答候选，提高数据多样性</li><li>质量筛选：人工或自动评估蒸馏数据的质量</li></ul><p>eg: <a href="https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k" target="_blank" rel="noopener">https://huggingface.co/datasets/Congliu/Chinese-DeepSeek-R1-Distill-data-110k</a></p><h3 id="2-7-其他微调技术（了解）"><a href="#2-7-其他微调技术（了解）" class="headerlink" title="2.7 其他微调技术（了解）"></a>2.7 其他微调技术（了解）</h3><p>以上几种监督微调的方式是大家最经常用到的场景，但为了更好地理解微调技术，我们也需要了解一些其他的微调手段。</p><h4 id="2-7-1-强化学习微调（RLHF）"><a href="#2-7-1-强化学习微调（RLHF）" class="headerlink" title="2.7.1 强化学习微调（RLHF）"></a>2.7.1 强化学习微调（RLHF）</h4><p>强化学习微调（Reinforcement Learning from Human Feedback，RLHF）是在监督微调的基础上，通过人类反馈优化模型生成质量的方法。</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"请推荐一部科幻电影"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"《星际穿越》是一部经典科幻片，探讨了时间与亲情。"</span>,</span><br><span class="line">  <span class="attr">"reward_score"</span>: <span class="number">4.5</span>  // 人类标注的质量评分（<span class="number">0</span><span class="number">-5</span>分）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>典型应用场景：</strong></p><ul><li>对话系统优化：提升回复的相关性，对齐人类价值观（安全、无害、有用性）</li><li>内容生成：控制输出风格（如幽默、正式）或避免敏感信息</li><li>代码生成：优化代码的可读性和正确性</li></ul><p>eg: <a href="https://huggingface.co/datasets/Dahoas/rm-static" target="_blank" rel="noopener">https://huggingface.co/datasets/Dahoas/rm-static</a></p><h4 id="2-7-2-多模态微调"><a href="#2-7-2-多模态微调" class="headerlink" title="2.7.2 多模态微调"></a>2.7.2 多模态微调</h4><p>多模态微调（Multimodal Fine-Tuning）指通过文本、图像、语音等多模态数据训练模型，使其具备跨模态理解与生成能力。</p><p><strong>数据格式示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"一只猫在追蝴蝶"</span>,</span><br><span class="line">  <span class="attr">"image_url"</span>: <span class="string">"https://example.com/cat.jpg"</span>,</span><br><span class="line">  <span class="attr">"caption"</span>: <span class="string">"一只橘色的猫正在追逐花园里的白色蝴蝶"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>需要选择具备多模态能力的预训练模型</li><li>图片、视频、音频等可以是CDN地址、base64编码，或HuggingFace相对路径</li><li>如果预训练模型本身不具备多模态能力，微调难度极大</li></ul><p><strong>典型应用场景：</strong></p><ul><li>图文问答：输入图片和问题，生成答案</li><li>视频内容理解：分析视频帧和字幕，生成摘要</li><li>跨模态检索：根据文本描述搜索相关图像/视频</li></ul><p>eg: <a href="https://huggingface.co/datasets/HuggingFaceM4/the_cauldron" target="_blank" rel="noopener">https://huggingface.co/datasets/HuggingFaceM4/the_cauldron</a></p><h4 id="2-7-3-无监督-自监督微调"><a href="#2-7-3-无监督-自监督微调" class="headerlink" title="2.7.3 无监督/自监督微调"></a>2.7.3 无监督/自监督微调</h4><p>这类微调技术不需要人工标注的标签，通过数据本身的结构和规律进行学习。</p><p><strong>典型方法：</strong></p><ul><li>掩码语言模型：随机遮挡部分词汇，让模型预测</li><li>对比学习：学习相似样本的表示应该接近，不相似的应该远离</li><li>自回归预训练：继续用”预测下一个词”的方式在特定领域数据上训练</li></ul><p><strong>适用场景：</strong> 当标注成本过高，或者只想让模型更好地理解某个领域的文本时使用</p><h2 id="三、数据集格式标准"><a href="#三、数据集格式标准" class="headerlink" title="三、数据集格式标准"></a>三、数据集格式标准</h2><h3 id="重要说明：格式并非强制标准"><a href="#重要说明：格式并非强制标准" class="headerlink" title="重要说明：格式并非强制标准"></a>重要说明：格式并非强制标准</h3><p>在深入介绍具体格式之前，需要明确一个重要观点：<strong>数据集格式并不是强制性的技术标准，而是社区约定俗成的最佳实践</strong>。</p><h4 id="为什么格式不是强制的？"><a href="#为什么格式不是强制的？" class="headerlink" title="为什么格式不是强制的？"></a>为什么格式不是强制的？</h4><ol><li><strong>最终都是文本</strong>：无论什么格式，最终都会被转换为模型可以理解的文本序列</li><li><strong>框架自动转换</strong>：主流微调框架（如LLaMA-Factory、DeepSpeed）都内置了格式转换功能</li><li><strong>自定义处理</strong>：开发者完全可以编写自己的数据处理逻辑</li></ol><h4 id="实际处理示例"><a href="#实际处理示例" class="headerlink" title="实际处理示例"></a>实际处理示例</h4><p>以我们之前教程中的代码为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义数据格式化模板</span></span><br><span class="line">template = <span class="string">"""Question: &#123;question&#125;</span></span><br><span class="line"><span class="string">Thinking: &#123;thinking&#125;  </span></span><br><span class="line"><span class="string">Answer: &#123;answer&#125;"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环处理原始数据</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dataset:</span><br><span class="line">    formatted_text = template.format(</span><br><span class="line">        question=item[<span class="string">'Question'</span>],</span><br><span class="line">        thinking=item[<span class="string">'Complex_COT'</span>], </span><br><span class="line">        answer=item[<span class="string">'Response'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 最终都转换为文本字符串</span></span><br></pre></td></tr></table></figure><p>可以看到，不管原始数据是什么格式，最终都通过模板转换为了统一的文本格式。</p><h4 id="那为什么还要遵循格式标准？"><a href="#那为什么还要遵循格式标准？" class="headerlink" title="那为什么还要遵循格式标准？"></a>那为什么还要遵循格式标准？</h4><p>虽然格式不是强制的，但遵循标准格式有很多好处：</p><h5 id="1-生态兼容性"><a href="#1-生态兼容性" class="headerlink" title="1. 生态兼容性"></a>1. 生态兼容性</h5><ul><li>大部分开源数据集都采用标准格式</li><li>微调框架可以直接加载，无需额外处理</li><li>便于数据集的分享和复用</li></ul><h5 id="2-处理效率"><a href="#2-处理效率" class="headerlink" title="2. 处理效率"></a>2. 处理效率</h5><ul><li>减少重复的数据处理工作</li><li>避免格式转换的bug</li><li>团队协作更高效</li></ul><h5 id="3-社区支持"><a href="#3-社区支持" class="headerlink" title="3. 社区支持"></a>3. 社区支持</h5><ul><li>丰富的工具和教程资源</li><li>问题解决方案容易找到</li><li>便于学习和参考</li></ul><h5 id="4-可维护性"><a href="#4-可维护性" class="headerlink" title="4. 可维护性"></a>4. 可维护性</h5><ul><li>代码结构清晰，易于维护</li><li>便于后期数据集的扩展和优化</li></ul><h4 id="自定义格式的适用场景"><a href="#自定义格式的适用场景" class="headerlink" title="自定义格式的适用场景"></a>自定义格式的适用场景</h4><p>在以下情况下，可以考虑使用自定义格式：</p><ul><li>有特殊的数据结构需求</li><li>现有格式无法满足复杂的任务要求  </li><li>团队内部有统一的数据处理流程</li><li>需要与现有系统保持兼容</li></ul><p><strong>总结：格式标准是建议而非强制，选择时应该平衡兼容性、效率和实际需求。</strong></p><h3 id="3-1-Alpaca-格式"><a href="#3-1-Alpaca-格式" class="headerlink" title="3.1 Alpaca 格式"></a>3.1 Alpaca 格式</h3><p>Alpaca 最初是斯坦福大学于 2023 年发布的 52k 条指令微调数据集，由 OpenAI 的 text-davinci-003 模型生成，旨在通过指令跟随（Instruction Following）任务优化大语言模型的性能。随着社区的发展，Alpaca 的 JSON 结构逐渐被抽象为一种通用数据格式。</p><h4 id="核心字段说明"><a href="#核心字段说明" class="headerlink" title="核心字段说明"></a>核心字段说明</h4><p><strong>基础三元组：</strong></p><ul><li><code>instruction</code>：任务指令，明确告诉模型要做什么</li><li><code>input</code>：具体的输入内容（可选，可为空）</li><li><code>output</code>：期望的输出结果</li></ul><p><strong>扩展字段：</strong></p><ul><li><code>system</code>：系统提示，定义模型的角色和行为准则</li><li><code>history</code>：历史对话记录，格式为 <code>[[&quot;问题1&quot;, &quot;回答1&quot;], [&quot;问题2&quot;, &quot;回答2&quot;]]</code></li></ul><h4 id="不同场景下的-Alpaca-格式示例"><a href="#不同场景下的-Alpaca-格式示例" class="headerlink" title="不同场景下的 Alpaca 格式示例"></a>不同场景下的 Alpaca 格式示例</h4><p><strong>指令微调数据集：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"将以下英文翻译成中文"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"The weather is beautiful today."</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"今天天气很好。"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>领域适配数据集：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"根据症状进行医学诊断"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"患者：男性，35岁，持续咳嗽2周，伴有轻微发热"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"建议进行胸部X光检查，可能是支气管炎或早期肺炎，建议及时就医"</span>,</span><br><span class="line">  <span class="attr">"system"</span>: <span class="string">"你是一名专业的医学助手"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带历史对话的数据集：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"instruction"</span>: <span class="string">"继续之前的对话"</span>,</span><br><span class="line">  <span class="attr">"input"</span>: <span class="string">"那推荐什么治疗方法？"</span>,</span><br><span class="line">  <span class="attr">"output"</span>: <span class="string">"建议多休息，多喝水，如症状加重请及时就医"</span>,</span><br><span class="line">  <span class="attr">"history"</span>: [</span><br><span class="line">    [<span class="string">"我感冒了怎么办？"</span>, <span class="string">"轻微感冒建议多休息，保持充足睡眠"</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优势与局限"><a href="#优势与局限" class="headerlink" title="优势与局限"></a>优势与局限</h4><p><strong>优势：</strong></p><ul><li>结构简洁明了，易于理解和处理</li><li>适合单轮指令任务，目标明确</li><li>社区支持广泛，兼容性好</li><li>便于批量处理和自动化生成</li></ul><p><strong>局限：</strong></p><ul><li>多轮对话需要额外的 history 字段处理</li><li>不原生支持工具调用和复杂交互</li><li>对话历史的表示方式相对简单</li></ul><h3 id="3-2-ShareGPT-格式"><a href="#3-2-ShareGPT-格式" class="headerlink" title="3.2 ShareGPT 格式"></a>3.2 ShareGPT 格式</h3><p>ShareGPT 最早是一种数据格式标准，由社区设计用于规范多轮对话和工具调用场景的模型训练数据存储方式。其核心目标是通过结构化字段支持复杂交互，如用户提问 → 工具调用 → 结果整合的完整流程。</p><h4 id="核心字段结构"><a href="#核心字段结构" class="headerlink" title="核心字段结构"></a>核心字段结构</h4><p><strong>基础结构：</strong></p><ul><li><code>conversations</code>：对话列表，包含完整的多轮交互</li><li><code>tools</code>：工具定义列表（可选）</li></ul><p><strong>角色标签规范：</strong></p><ul><li><code>human</code> / <code>user</code>：用户输入</li><li><code>gpt</code> / <code>assistant</code>：模型回复</li><li><code>function_call</code>：工具调用指令</li><li><code>observation</code>：工具返回结果</li><li><code>system</code>：系统提示</li></ul><h4 id="角色位置规则"><a href="#角色位置规则" class="headerlink" title="角色位置规则"></a>角色位置规则</h4><p>ShareGPT 格式有严格的角色位置规则：</p><ul><li><code>human</code> 或 <code>observation</code> 必须出现在奇数位置（1, 3, 5…）</li><li><code>gpt</code> 或 <code>function_call</code> 必须出现在偶数位置（2, 4, 6…）</li><li>这样确保了对话的逻辑连贯性</li></ul><h4 id="不同场景下的-ShareGPT-格式示例"><a href="#不同场景下的-ShareGPT-格式示例" class="headerlink" title="不同场景下的 ShareGPT 格式示例"></a>不同场景下的 ShareGPT 格式示例</h4><p><strong>基础多轮对话：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"conversations"</span>: [</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"human"</span>, <span class="attr">"value"</span>: <span class="string">"你好，今天天气怎么样？"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"gpt"</span>, <span class="attr">"value"</span>: <span class="string">"您好！我无法直接获取实时天气信息，建议您查看天气预报应用。"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"human"</span>, <span class="attr">"value"</span>: <span class="string">"那你能告诉我北京的特色美食吗？"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"gpt"</span>, <span class="attr">"value"</span>: <span class="string">"北京有很多特色美食，比如北京烤鸭、炸酱面、豆汁儿等。"</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工具调用场景：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"conversations"</span>: [</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"human"</span>, <span class="attr">"value"</span>: <span class="string">"帮我查一下明天北京的天气"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"function_call"</span>, <span class="attr">"value"</span>: <span class="string">"&#123;\"name\": \"get_weather\", \"arguments\": &#123;\"city\": \"北京\", \"date\": \"明天\"&#125;&#125;"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"observation"</span>, <span class="attr">"value"</span>: <span class="string">"明天北京天气：晴，最高温度25°C，最低温度15°C"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"from"</span>: <span class="string">"gpt"</span>, <span class="attr">"value"</span>: <span class="string">"根据查询结果，明天北京天气晴朗，最高温度25°C，最低温度15°C，适合出行。"</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"tools"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"get_weather"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"获取指定城市的天气信息"</span>,</span><br><span class="line">      <span class="attr">"parameters"</span>: &#123;</span><br><span class="line">        <span class="attr">"city"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"description"</span>: <span class="string">"城市名称"</span>&#125;,</span><br><span class="line">        <span class="attr">"date"</span>: &#123;<span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"description"</span>: <span class="string">"日期"</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OpenAI 格式（ShareGPT 的特殊形式）：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"messages"</span>: [</span><br><span class="line">    &#123;<span class="attr">"role"</span>: <span class="string">"system"</span>, <span class="attr">"content"</span>: <span class="string">"你是一个有用的AI助手"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"role"</span>: <span class="string">"user"</span>, <span class="attr">"content"</span>: <span class="string">"解释什么是机器学习"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"role"</span>: <span class="string">"assistant"</span>, <span class="attr">"content"</span>: <span class="string">"机器学习是人工智能的一个分支..."</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优势与局限性"><a href="#优势与局限性" class="headerlink" title="优势与局限性"></a>优势与局限性</h4><p><strong>优势：</strong></p><ul><li>原生支持多轮对话和上下文理解</li><li>完整支持工具调用功能</li><li>角色标签清晰，便于复杂交互建模</li><li>更贴近真实的人机交互场景</li></ul><p><strong>局限：</strong></p><ul><li>数据结构相对复杂</li><li>需要严格遵循角色位置规则</li><li>对简单任务来说可能过于冗余</li></ul><h3 id="3-3-格式对比与选择建议"><a href="#3-3-格式对比与选择建议" class="headerlink" title="3.3 格式对比与选择建议"></a>3.3 格式对比与选择建议</h3><h4 id="详细对比表"><a href="#详细对比表" class="headerlink" title="详细对比表"></a>详细对比表</h4><table><thead><tr><th>对比维度</th><th>Alpaca 格式</th><th>ShareGPT 格式</th></tr></thead><tbody><tr><td><strong>核心设计目标</strong></td><td>单轮指令驱动任务（如问答、翻译、摘要）</td><td>多轮对话与工具调用（如聊天机器人、API 交互）</td></tr><tr><td><strong>数据结构</strong></td><td>以 instruction、input、output 为主体的 JSON 对象</td><td>以 conversations 列表为核心的多角色对话链</td></tr><tr><td><strong>对话历史处理</strong></td><td>通过 history 字段记录历史对话（格式：[[“指令”, “回答”], …]）</td><td>通过 conversations 列表顺序自然体现多轮对话</td></tr><tr><td><strong>角色与交互逻辑</strong></td><td>仅区分用户指令和模型输出，无显式角色标签</td><td>支持多种角色标签，强制奇偶位置规则</td></tr><tr><td><strong>工具调用支持</strong></td><td>不原生支持工具调用，需通过 input 或指令隐式描述</td><td>通过 function_call 和 observation 显式实现工具调用</td></tr><tr><td><strong>学习门槛</strong></td><td>简单易懂，快速上手</td><td>相对复杂，需要理解角色规则</td></tr><tr><td><strong>处理效率</strong></td><td>批量处理简单，便于自动化</td><td>需要额外的格式验证和转换</td></tr></tbody></table><h4 id="任务类型选择建议"><a href="#任务类型选择建议" class="headerlink" title="任务类型选择建议"></a>任务类型选择建议</h4><table><thead><tr><th>任务类型</th><th>推荐格式</th><th>详细原因</th></tr></thead><tbody><tr><td>简单问答</td><td>Alpaca</td><td>结构清晰，指令明确，无需复杂交互</td></tr><tr><td>多轮对话</td><td>ShareGPT</td><td>原生支持对话历史，角色标签清晰</td></tr><tr><td>工具调用</td><td>ShareGPT</td><td>完整支持 function_call 和 observation 流程</td></tr><tr><td>领域专家</td><td>Alpaca</td><td>指令明确，便于领域专家标注和验证</td></tr><tr><td>文本分类</td><td>Alpaca</td><td>简单直接，标签明确，便于批量处理</td></tr><tr><td>推理任务</td><td>Alpaca</td><td>支持思维链在 chain_of_thought 字段中结构化展示</td></tr><tr><td>知识蒸馏</td><td>Alpaca</td><td>便于大模型批量生成和自动化处理</td></tr><tr><td>客服系统</td><td>ShareGPT</td><td>需要多轮交互和上下文理解</td></tr><tr><td>代码助手</td><td>ShareGPT</td><td>支持工具调用，如代码执行、文档查询</td></tr></tbody></table><h4 id="选择建议总结"><a href="#选择建议总结" class="headerlink" title="选择建议总结"></a>选择建议总结</h4><p><strong>选择 Alpaca 格式的情况：</strong></p><ul><li>任务目标明确，单轮交互为主</li><li>需要大量数据生成和批量处理</li><li>团队技术门槛要求较低</li><li>专注于指令遵循和结果质量</li></ul><p><strong>选择 ShareGPT 格式的情况：</strong></p><ul><li>需要多轮对话和上下文理解</li><li>要集成外部工具和API调用</li><li>构建复杂的交互式应用</li><li>追求更自然的人机交互体验</li></ul><h3 id="3-4-数据质量要求"><a href="#3-4-数据质量要求" class="headerlink" title="3.4 数据质量要求"></a>3.4 数据质量要求</h3><h4 id="准确性原则"><a href="#准确性原则" class="headerlink" title="准确性原则"></a>准确性原则</h4><ul><li>标注一致性：同样的输入应该有一致的输出</li><li>专业性保证：领域数据需要专家审核</li><li>错误率控制：标注错误率应低于5%</li></ul><h4 id="完整性原则"><a href="#完整性原则" class="headerlink" title="完整性原则"></a>完整性原则</h4><ul><li>覆盖全面：包含各种可能的输入情况</li><li>边界处理：包含异常和边界情况的处理</li><li>平衡性：各类别样本数量相对均衡</li></ul><h4 id="规范性原则"><a href="#规范性原则" class="headerlink" title="规范性原则"></a>规范性原则</h4><ul><li>格式统一：严格按照选定格式执行</li><li>长度适中：避免过长或过短的文本</li><li>编码规范：统一使用UTF-8编码</li></ul><h2 id="四、数据集的三种用途"><a href="#四、数据集的三种用途" class="headerlink" title="四、数据集的三种用途"></a>四、数据集的三种用途</h2><h3 id="4-1-训练集（70-80-）"><a href="#4-1-训练集（70-80-）" class="headerlink" title="4.1 训练集（70-80%）"></a>4.1 训练集（70-80%）</h3><p><strong>作用：</strong> 模型学习知识的主要数据源<br><strong>要求：</strong> 数据量大，覆盖全面，质量稳定</p><h3 id="4-2-验证集（10-15-）"><a href="#4-2-验证集（10-15-）" class="headerlink" title="4.2 验证集（10-15%）"></a>4.2 验证集（10-15%）</h3><p><strong>作用：</strong> 训练过程中调优参数，防止过拟合<br><strong>要求：</strong> 与训练集分布相似但完全独立</p><h3 id="4-3-测试集（10-15-）"><a href="#4-3-测试集（10-15-）" class="headerlink" title="4.3 测试集（10-15%）"></a>4.3 测试集（10-15%）</h3><p><strong>作用：</strong> 最终评估模型真实性能<br><strong>要求：</strong> 绝对隔离，训练过程中不可见</p><h2 id="五、数据集准备实用建议"><a href="#五、数据集准备实用建议" class="headerlink" title="五、数据集准备实用建议"></a>五、数据集准备实用建议</h2><h3 id="5-1-质量优于数量"><a href="#5-1-质量优于数量" class="headerlink" title="5.1 质量优于数量"></a>5.1 质量优于数量</h3><ul><li>宁要 1000 条高质量数据，不要 10000 条低质量数据</li><li>确保数据准确性，避免错误标注影响模型学习</li></ul><h3 id="5-2-覆盖度要全面"><a href="#5-2-覆盖度要全面" class="headerlink" title="5.2 覆盖度要全面"></a>5.2 覆盖度要全面</h3><ul><li>考虑不同的输入形式和输出要求</li><li>包含边界情况和异常处理</li></ul><h3 id="5-3-格式要统一"><a href="#5-3-格式要统一" class="headerlink" title="5.3 格式要统一"></a>5.3 格式要统一</h3><ul><li>选定格式后保持一致性</li><li>注意字段命名和数据类型统一</li></ul><h3 id="5-4-迭代优化"><a href="#5-4-迭代优化" class="headerlink" title="5.4 迭代优化"></a>5.4 迭代优化</h3><ul><li>从小规模数据集开始测试</li><li>根据微调效果逐步优化数据集</li></ul><h3 id="5-5-数据获取途径"><a href="#5-5-数据获取途径" class="headerlink" title="5.5 数据获取途径"></a>5.5 数据获取途径</h3><h4 id="公开数据集"><a href="#公开数据集" class="headerlink" title="公开数据集"></a>公开数据集</h4><ul><li>HuggingFace Datasets：最丰富的开源数据集平台</li><li>Kaggle：竞赛数据集，质量较高</li><li>GitHub：社区贡献的专业数据集</li></ul><h4 id="领域文献转换"><a href="#领域文献转换" class="headerlink" title="领域文献转换"></a>领域文献转换</h4><ul><li>学术论文：提取问答对和知识点</li><li>技术文档：整理操作指南和FAQ</li><li>行业报告：提取分析和结论</li></ul><h4 id="AI辅助生成"><a href="#AI辅助生成" class="headerlink" title="AI辅助生成"></a>AI辅助生成</h4><ul><li>模型蒸馏：用大模型生成小模型训练数据</li><li>数据增强：同义词替换、句式变换</li><li>合成数据：基于规则和模板生成</li></ul><h3 id="5-6-标注工具推荐"><a href="#5-6-标注工具推荐" class="headerlink" title="5.6 标注工具推荐"></a>5.6 标注工具推荐</h3><h4 id="专业标注平台"><a href="#专业标注平台" class="headerlink" title="专业标注平台"></a>专业标注平台</h4><ul><li>Label Studio：支持多种数据类型的开源标注工具</li><li>Prodigy：高效的机器学习辅助标注工具</li><li>Doccano：专注于文本标注的开源平台</li></ul><h4 id="众包标注"><a href="#众包标注" class="headerlink" title="众包标注"></a>众包标注</h4><ul><li>Amazon Mechanical Turk：大规模众包标注</li><li>腾讯众智：中文数据标注平台</li><li>百度众测：支持多种标注任务</li></ul><h2 id="六、常见问题解答"><a href="#六、常见问题解答" class="headerlink" title="六、常见问题解答"></a>六、常见问题解答</h2><p><strong>Q: 数据集太少怎么办？</strong><br>A: 可以考虑数据增强、交叉验证，或使用大模型辅助生成（需人工审核）</p><p><strong>Q: 如何评估数据集质量？</strong><br>A: 通过验证集表现、人工抽样检查、A/B 测试等方式</p><p><strong>Q: 多模态数据如何处理？</strong><br>A: 需要选择支持多模态的预训练模型，数据格式要包含各种模态信息</p><p><strong>Q: 文本分类数据集如何确保平衡性？</strong><br>A: 采用分层抽样、过采样/欠采样技术，或使用加权损失函数</p><p><strong>Q: 推理任务的思维链数据难以获取怎么办？</strong><br>A: 可以使用DeepSeek-R1等开源推理模型生成，然后人工筛选和优化</p><p><strong>Q: 领域适配需要多少数据？</strong><br>A: 一般建议每个类别至少1000条高质量数据，具体取决于任务复杂度和模型大小</p><p><strong>Q: 如何处理不平衡数据集？</strong><br>A: 使用SMOTE算法、调整损失函数权重，或采用集成学习方法</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>数据集是大模型微调成功的基石。通过合理选择微调任务类型、采用标准化的数据格式、科学划分数据用途，您可以大幅提升微调效果。记住：<strong>好的数据集是成功微调的第一步</strong>。</p><p>在实际操作中，建议从小规模数据集开始验证思路，然后逐步扩展和优化。结合自动化工具和人工审核，可以高效地构建高质量的微调数据集。</p><p>下面是本文给出的学习路径总结：</p><ul><li><strong>前置知识</strong>：了解常见的微调任务类型，根据特定任务选择适合的数据集</li><li><strong>前置知识</strong>：了解常见的数据集格式，数据集的类型  </li><li><strong>学会怎么找</strong>：一些推荐的获取公开数据集的途径</li><li><strong>学会这么标</strong>：基于标注工具半自动标注数据集</li><li><strong>学会怎么做</strong>：将特定领域的文献转换为目标格式的数据集</li><li><strong>学会怎么做</strong>：基于 AI 全自动生成模型蒸馏数据集</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大模型微调数据集&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://luckyp.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>大模型基础概念</title>
    <link href="https://luckyp.top/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://luckyp.top/大模型基础概念/</id>
    <published>2025-06-01T02:59:50.000Z</published>
    <updated>2025-06-01T02:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>从基础概念到技术前沿<br><a id="more"></a></p><h2 id="一、什么是大模型？"><a href="#一、什么是大模型？" class="headerlink" title="一、什么是大模型？"></a>一、什么是大模型？</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>大模型是指具有大规模参数和复杂计算结构的<strong>机器学习</strong>模型，通常由深度<strong>神经网络</strong>构建而成，拥有数十亿甚至数千亿个参数。大模型本质上是一个使用海量数据训练而成的深度神经网络模型，其巨大的数据和参数规模，实现了智能的涌现，展现出类似人类的智能。<br><strong>机器学习</strong>：赋予计算机系统从示例中学习的能力，它是人工智能的一个分支，不严格等于<br><strong>神经网络</strong>：通过编程从示例中学习的机器</p><h3 id="大模型-vs-小模型的根本区别"><a href="#大模型-vs-小模型的根本区别" class="headerlink" title="大模型 vs 小模型的根本区别"></a>大模型 vs 小模型的根本区别</h3><p><strong>小模型特征</strong>：</p><ul><li>参数较少、层数较浅</li><li>轻量级、高效率、易于部署</li><li>适用于数据量较小、计算资源有限的场景</li><li>应用于移动端、嵌入式设备、物联网等</li></ul><p><strong>大模型的核心特征</strong>：</p><ul><li>参数较多、层数较深</li><li>具备”<strong>涌现能力</strong>“（这是最关键的区别）</li><li>更强的表达能力和更高的准确度</li><li>适用于数据量大、计算资源充足的场景<br><strong>涌现能力</strong>：当模型的训练数据和参数达到一定临界规模后，会表现出一些未能预测的、更复杂的能力和特性，模型能够从原始训练数据中自动学习并发现新的、更高层次的特征和模式。</li></ul><p>总结：大模型追求能力的广度和深度，小模型追求效率和实用性。选择哪种取决于具体的应用场景、资源限制和性能要求。</p><h2 id="二、大模型的核心特点"><a href="#二、大模型的核心特点" class="headerlink" title="二、大模型的核心特点"></a>二、大模型的核心特点</h2><h3 id="1-规模化特征"><a href="#1-规模化特征" class="headerlink" title="1. 规模化特征"></a>1. 规模化特征</h3><ul><li><strong>参数规模巨大</strong>：通常超过10亿参数，最大可达数千亿</li><li><strong>数据规模庞大</strong>：训练数据达到TB甚至PB级别</li><li><strong>计算资源需求大</strong>：需要成千上万个GPU进行分布式训练</li><li><strong>模型容量大</strong>：能够存储和处理复杂的知识结构</li></ul><h3 id="2-强大的泛化能力"><a href="#2-强大的泛化能力" class="headerlink" title="2. 强大的泛化能力"></a>2. 强大的泛化能力</h3><ul><li><strong>跨任务泛化</strong>：一个模型可以处理多种不同类型的任务</li><li><strong>少样本学习</strong>：仅需少量样本就能适应新任务</li><li><strong>零样本推理</strong>：在未见过的任务上也能表现出合理的性能</li><li><strong>知识迁移</strong>：能够将已学知识应用到新的领域</li></ul><h3 id="3-涌现特性"><a href="#3-涌现特性" class="headerlink" title="3. 涌现特性"></a>3. 涌现特性</h3><ul><li><strong>智能涌现</strong>：展现出训练时未明确设计的复杂能力</li><li><strong>创造性</strong>：能够生成原创性内容和解决方案</li><li><strong>推理能力</strong>：具备一定的逻辑推理和抽象思维能力</li><li><strong>上下文学习</strong>：能够在对话中学习和适应</li></ul><h3 id="4-多模态处理能力"><a href="#4-多模态处理能力" class="headerlink" title="4. 多模态处理能力"></a>4. 多模态处理能力</h3><ul><li><strong>文本理解与生成</strong>：自然语言处理的核心能力</li><li><strong>视觉理解</strong>：图像识别、分析和生成</li><li><strong>跨模态融合</strong>：文本与图像、音频等多种模态的结合处理</li><li><strong>统一接口</strong>：为用户提供统一的多模态交互体验</li></ul><h3 id="5-持续学习特性"><a href="#5-持续学习特性" class="headerlink" title="5. 持续学习特性"></a>5. 持续学习特性</h3><ul><li><strong>预训练基础</strong>：在大规模数据上建立通用知识基础</li><li><strong>微调适应</strong>：通过少量标注数据适应特定任务</li><li><strong>增量学习</strong>：能够在不遗忘旧知识的基础上学习新知识</li><li><strong>动态更新</strong>：支持知识的实时更新和补充</li></ul><h2 id="三、相关概念区分"><a href="#三、相关概念区分" class="headerlink" title="三、相关概念区分"></a>三、相关概念区分</h2><h3 id="模型层次分类"><a href="#模型层次分类" class="headerlink" title="模型层次分类"></a>模型层次分类</h3><ul><li><strong>大模型（Large Model/Foundation Model）</strong>：基础概念，具有大量参数和复杂结构，能够处理海量数据、完成各种复杂任务</li><li><strong>超大模型</strong>：大模型的子集，参数量远超过一般大模型</li><li><strong>大语言模型（LLM）</strong>：专门用于自然语言处理的大模型，如GPT-3、文心一言等</li></ul><h3 id="具体模型区分"><a href="#具体模型区分" class="headerlink" title="具体模型区分"></a>具体模型区分</h3><ul><li><strong>GPT（Generative Pre-trained Transformer）</strong>：基于Transformer架构，专注于文本生成和各种NLP任务，通常用于单向生成</li><li><strong>ChatGPT</strong>：GPT的对话优化版本，专门用于交互式对话，经过特定训练以处理多轮对话和上下文理解</li></ul><h2 id="四、技术发展历程"><a href="#四、技术发展历程" class="headerlink" title="四、技术发展历程"></a>四、技术发展历程</h2><h3 id="萌芽期（1950-2005）：传统神经网络阶段"><a href="#萌芽期（1950-2005）：传统神经网络阶段" class="headerlink" title="萌芽期（1950-2005）：传统神经网络阶段"></a>萌芽期（1950-2005）：传统神经网络阶段</h3><p><strong>自然语言处理的局限性</strong>：</p><ul><li>基于规则和统计模型实现</li><li>只能完成简单、生硬、固定模板的对话</li><li>对复杂语境理解能力不足</li><li>生成自然流畅文本困难</li></ul><p><strong>技术发展节点</strong>：</p><ul><li><strong>1956年</strong>：约翰·麦卡锡提出”人工智能”概念</li><li><strong>1980年</strong>：卷积神经网络雏形CNN诞生</li><li><strong>1998年</strong>：LeNet-5建立现代CNN基本结构</li></ul><h3 id="探索沉淀期（2006-2019）：深度学习崛起"><a href="#探索沉淀期（2006-2019）：深度学习崛起" class="headerlink" title="探索沉淀期（2006-2019）：深度学习崛起"></a>探索沉淀期（2006-2019）：深度学习崛起</h3><p><strong>机器学习的推进</strong>：</p><ul><li>引入无监督学习和有监督学习</li><li>通过大规模数据学习和模式识别</li><li>但存在手动特征提取、模型泛化能力有限等挑战</li></ul><p><strong>深度学习的突破</strong>：</p><ul><li>模仿人脑结构，构建深层神经网络</li><li>解决传统方法的特征提取问题</li><li>但面临记忆长度、并行性、长距离依赖性挑战</li></ul><p><strong>关键技术节点</strong>：</p><ul><li><strong>2013年</strong>：Word2Vec自然语言处理模型诞生</li><li><strong>2017年</strong>：<strong>Transformer横空出世</strong>，发表《Attention is All You Need》</li><li><strong>2018年</strong>：BERT和GPT-1问世</li><li><strong>2019年</strong>：GPT-2展现强大生成能力</li></ul><h3 id="快速发展期（2019-至今）：规模化与应用爆发"><a href="#快速发展期（2019-至今）：规模化与应用爆发" class="headerlink" title="快速发展期（2019-至今）：规模化与应用爆发"></a>快速发展期（2019-至今）：规模化与应用爆发</h3><ul><li><strong>2020年</strong>：GPT-3达到1750亿参数，展现少样本学习能力</li><li><strong>2022年</strong>：ChatGPT引发全球AI热潮，5天用户破百万</li><li><strong>2023年</strong>：GPT-4、多模态模型涌现，能力显著提升</li></ul><h2 id="五、核心技术原理"><a href="#五、核心技术原理" class="headerlink" title="五、核心技术原理"></a>五、核心技术原理</h2><h3 id="Transformer架构革命"><a href="#Transformer架构革命" class="headerlink" title="Transformer架构革命"></a>Transformer架构革命</h3><p><strong>技术背景</strong>：传统神经网络面临的挑战</p><ul><li><strong>记忆长度限制</strong>：处理长序列时出现记忆衰减</li><li><strong>并行性不足</strong>：顺序处理难以利用并行计算优势</li><li><strong>长距离依赖问题</strong>：梯度消失和爆炸导致性能下降</li></ul><p><strong>Transformer创新</strong>：</p><ol><li><p><strong>自注意力机制（Self-Attention）</strong></p><ul><li>解决长距离依赖问题</li><li>实现更好的上下文理解</li><li>提供强大的语义表示能力</li></ul></li><li><p><strong>位置编码（Positional Encoding）</strong></p><ul><li>处理序列位置信息</li><li>保持文本结构特征</li><li>支持并行计算处理</li></ul></li></ol><p><strong>技术优势</strong>：</p><ul><li>更高的并行性</li><li>更长的记忆长度</li><li>更好的长距离依赖关系处理</li><li>生成自然、流畅、复杂的文本</li></ul><h3 id="LLM技术实现原理"><a href="#LLM技术实现原理" class="headerlink" title="LLM技术实现原理"></a>LLM技术实现原理</h3><p><strong>1. Transformer架构核心</strong></p><ul><li>多头注意力机制</li><li>前馈神经网络</li><li>残差连接和层归一化</li></ul><p><strong>2. 预训练机制</strong></p><ul><li>大规模无标注数据训练</li><li>自监督学习方式</li><li>建立通用语言表示</li></ul><p><strong>3. 生成式特性</strong></p><ul><li>自回归生成模式</li><li>上下文感知能力</li><li>创造性文本生成</li></ul><h2 id="六、大模型分类体系"><a href="#六、大模型分类体系" class="headerlink" title="六、大模型分类体系"></a>六、大模型分类体系</h2><h3 id="按应用领域分类"><a href="#按应用领域分类" class="headerlink" title="按应用领域分类"></a>按应用领域分类</h3><p><strong>1. 大语言模型（LLM）</strong></p><ul><li><strong>生成式模型</strong>：GPT系列、LLaMA、文心一言、ChatGLM</li><li><strong>理解式模型</strong>：BERT系列、RoBERTa</li><li>目前发展最成熟、应用最广泛的类型</li></ul><p><strong>2. 视觉大模型</strong></p><ul><li><strong>CLIP</strong>：连接文本和图像的桥梁</li><li><strong>ViT</strong>：Vision Transformer，将Transformer应用于视觉任务</li><li><strong>DALL-E</strong>：文本到图像生成</li><li><strong>Stable Diffusion</strong>：开源图像生成模型</li></ul><p><strong>3. 多模态大模型</strong></p><ul><li><strong>GPT-4V</strong>：集成视觉理解的语言模型</li><li><strong>Flamingo</strong>：少样本学习的多模态模型</li><li><strong>BLIP系列</strong>：图像-文本理解和生成</li></ul><p><strong>4. 科学计算大模型</strong></p><ul><li><strong>AlphaFold</strong>：蛋白质结构预测</li><li><strong>Climate Models</strong>：气候变化预测</li><li><strong>Drug Discovery Models</strong>：药物发现</li></ul><p><strong>5. 代码生成大模型</strong></p><ul><li><strong>Codex</strong>：GitHub Copilot的核心</li><li><strong>CodeT5</strong>：代码理解和生成</li><li><strong>StarCoder</strong>：开源代码生成模型</li></ul><h2 id="七、泛化与微调机制"><a href="#七、泛化与微调机制" class="headerlink" title="七、泛化与微调机制"></a>七、泛化与微调机制</h2><h3 id="预训练阶段"><a href="#预训练阶段" class="headerlink" title="预训练阶段"></a>预训练阶段</h3><ul><li><strong>大规模数据训练</strong>：在海量无标注数据上进行自监督学习</li><li><strong>通用能力建立</strong>：学习通用的语言理解和生成能力</li><li><strong>知识基础构建</strong>：建立基础的知识表示和语言模式</li></ul><h3 id="微调阶段"><a href="#微调阶段" class="headerlink" title="微调阶段"></a>微调阶段</h3><ul><li><strong>任务特化</strong>：在特定任务的标注数据上进行有监督学习</li><li><strong>领域适应</strong>：适应具体应用场景和任务需求</li><li><strong>性能优化</strong>：提升在特定领域的表现和准确性</li></ul><h3 id="微调策略"><a href="#微调策略" class="headerlink" title="微调策略"></a>微调策略</h3><ul><li><strong>全参数微调</strong>：调整所有模型参数</li><li><strong>参数高效微调</strong>：如LoRA、Adapter等技术</li><li><strong>提示学习</strong>：通过设计提示模板实现零样本或少样本学习</li></ul><h2 id="八、实际应用场景"><a href="#八、实际应用场景" class="headerlink" title="八、实际应用场景"></a>八、实际应用场景</h2><h3 id="RAG（检索增强生成）场景"><a href="#RAG（检索增强生成）场景" class="headerlink" title="RAG（检索增强生成）场景"></a>RAG（检索增强生成）场景</h3><p><strong>技术原理</strong>：结合检索和生成的方法，解决LLM语料时效性和数据源问题</p><p><strong>1. 检索阶段（Retrieval）</strong></p><ul><li>使用向量存储提高相关性搜索准确率</li><li>从大型知识库检索相关文本片段</li><li>只传递相关性最高的数据，减少资源消耗</li></ul><p><strong>2. 增强阶段（Augmented）</strong></p><ul><li>通过提示工程技术优化上下文</li><li>在用户输入中添加检索到的相关数据</li><li>提供LLM生成所需的背景信息</li></ul><p><strong>3. 生成阶段（Generation）</strong></p><ul><li>基于检索内容进行精确生成</li><li>利用上下文信息提高回答准确性</li><li>实现智能问答系统、文档总结等应用</li></ul><h3 id="AIGC（人工智能生成内容）场景"><a href="#AIGC（人工智能生成内容）场景" class="headerlink" title="AIGC（人工智能生成内容）场景"></a>AIGC（人工智能生成内容）场景</h3><p>AIGC涵盖多种生成式任务，LLM在其中发挥重要作用：</p><p><strong>应用领域</strong>：</p><ul><li><strong>文本生成</strong>：文章创作、新闻写作、营销文案</li><li><strong>图片生成</strong>：AI绘画、设计素材创作</li><li><strong>代码生成</strong>：程序开发、代码补全、bug修复</li><li><strong>视频生成</strong>：短视频制作、动画创作</li><li><strong>语音生成</strong>：语音合成、配音制作</li></ul><h2 id="九、当前发展态势与挑战"><a href="#九、当前发展态势与挑战" class="headerlink" title="九、当前发展态势与挑战"></a>九、当前发展态势与挑战</h2><h3 id="技术成熟度"><a href="#技术成熟度" class="headerlink" title="技术成熟度"></a>技术成熟度</h3><ul><li><strong>LLM最为成熟</strong>：架构稳定、训练方法完善、评估体系健全</li><li><strong>应用场景丰富</strong>：问答、创作、翻译、摘要等多种任务</li><li><strong>商业价值明确</strong>：API调用、订阅服务等盈利模式成熟</li></ul><h3 id="面临挑战"><a href="#面临挑战" class="headerlink" title="面临挑战"></a>面临挑战</h3><ul><li><strong>计算资源需求巨大</strong>：训练和推理成本高</li><li><strong>安全性问题</strong>：生成内容可控性、隐私保护</li><li><strong>技术局限</strong>：知识截止时间、幻觉问题</li><li><strong>部署门槛高</strong>：对硬件和技术要求严格</li></ul><h2 id="十、未来发展趋势"><a href="#十、未来发展趋势" class="headerlink" title="十、未来发展趋势"></a>十、未来发展趋势</h2><h3 id="1-效率优化"><a href="#1-效率优化" class="headerlink" title="1. 效率优化"></a>1. 效率优化</h3><ul><li><strong>模型压缩</strong>：知识蒸馏、剪枝、量化技术</li><li><strong>推理优化</strong>：提高推理速度，降低部署成本</li><li><strong>硬件协同</strong>：设计专门的AI芯片架构</li></ul><h3 id="2-多模态融合"><a href="#2-多模态融合" class="headerlink" title="2. 多模态融合"></a>2. 多模态融合</h3><ul><li><strong>原生多模态设计</strong>：从底层架构支持多模态</li><li><strong>跨模态推理</strong>：在不同模态间进行复杂推理</li><li><strong>统一接口</strong>：提供统一的多模态交互界面</li></ul><h3 id="3-专业化发展"><a href="#3-专业化发展" class="headerlink" title="3. 专业化发展"></a>3. 专业化发展</h3><ul><li><strong>医疗大模型</strong>：医学诊断和治疗建议</li><li><strong>法律大模型</strong>：法律文书和法律咨询</li><li><strong>教育大模型</strong>：个性化教学和智能辅导</li><li><strong>科研大模型</strong>：科学研究和数据分析</li></ul><h3 id="4-安全性和可控性"><a href="#4-安全性和可控性" class="headerlink" title="4. 安全性和可控性"></a>4. 安全性和可控性</h3><ul><li><strong>对齐技术</strong>：确保模型行为符合人类价值观</li><li><strong>可解释性</strong>：让模型决策过程更加透明</li><li><strong>隐私保护</strong>：在训练和使用过程中保护用户隐私</li></ul><h2 id="十一、结语"><a href="#十一、结语" class="headerlink" title="十一、结语"></a>十一、结语</h2><p>大模型代表了人工智能发展的重要里程碑，从2017年Transformer架构的提出，到ChatGPT引发的全球AI热潮，标志着人类正式迈入真正的人工智能时代。</p><p>大模型不仅仅是参数规模的简单堆叠，更是多项关键技术创新的集成，最终实现了从量变到质变的突破。其”涌现能力”让机器首次展现出类似人类的智能，为各个领域带来了革命性的变革。</p><p>虽然目前仍面临计算资源、安全性、技术局限等挑战，但随着技术不断进步和产业生态完善，大模型必将在未来更深入地改变我们的工作和生活方式。理解大模型的基本原理和发展趋势，对于把握这一技术革命带来的机遇具有重要意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从基础概念到技术前沿&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://luckyp.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>注意力机制相关</title>
    <link href="https://luckyp.top/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
    <id>https://luckyp.top/注意力机制/</id>
    <published>2025-05-24T04:00:00.000Z</published>
    <updated>2025-05-24T03:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>注意力机制简单了解。<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="注意力机制的通俗理解"><a href="#注意力机制的通俗理解" class="headerlink" title="注意力机制的通俗理解"></a>注意力机制的通俗理解</h3><p>让我们通过几个生活中的例子来理解:</p><p>例子1: 阅读理解<br>假设有这样一段话:<br>“小明很喜欢打篮球。他每天都会去操场练习。”</p><p>当我们读到”他”这个字的时候,大脑会自动去寻找这个”他”指的是谁。通过上下文,我们知道”他”指的是”小明”。这就是一个最基本的注意力机制 - 我们的大脑会自动关注到相关的重要信息。</p><p>例子2: 歧义词理解<br>“我在得物上买了最新款的苹果,体验非常好”<br>“我在得物上买了阿克苏的苹果,口感非常好”</p><p>在这两句话中,”苹果”是一个歧义词:</p><ul><li>第一句中的”苹果”指的是iPhone手机,因为搭配了”最新款”和”体验”</li><li>第二句中的”苹果”指的是水果,因为搭配了”阿克苏”和”口感”</li></ul><p>注意力机制就是帮助模型像人类大脑一样,通过上下文来理解每个词的真实含义。</p><h3 id="注意力机制是如何工作的"><a href="#注意力机制是如何工作的" class="headerlink" title="注意力机制是如何工作的"></a>注意力机制是如何工作的</h3><p>让我用一个形象的例子来解释:</p><p>想象你在看一个很长的句子:”昨天下午,小明在公园里遇到了小红,她穿着一条蓝色的裙子。”</p><p>当模型在处理”她”这个词时,会:</p><p>1) 计算相关度分数:</p><ul><li>“她” 和 “小明” 的相关度: 较低(因为性别不匹配)</li><li>“她” 和 “小红” 的相关度: 很高(因为性别匹配)</li><li>“她” 和其他词的相关度: 较低</li></ul><p>2) 分配注意力权重:</p><ul><li>“小红” 获得最高的注意力权重</li><li>其他词获得较低的注意力权重</li></ul><p>3) 整合信息:<br>模型会重点关注高权重的信息,从而理解”她”指代的是”小红”。</p><h3 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h3><p>继续用刚才的例子:<br>“昨天下午,小明在公园里遇到了小红,她穿着一条蓝色的裙子。”</p><p>多头注意力就像是从多个角度来理解这句话:</p><ul><li><p>第1个注意力头可能关注人物关系:<br>发现”她”和”小红”的关联</p></li><li><p>第2个注意力头可能关注时间信息:<br>关注”昨天下午”这个时间点</p></li><li><p>第3个注意力头可能关注地点信息:<br>关注”公园”这个场所</p></li><li><p>第4个注意力头可能关注动作信息:<br>关注”遇到”这个动作</p></li></ul><p>这就像多个人从不同角度来理解同一句话,最后把这些理解综合起来,得到更全面的理解。</p><h3 id="为什么需要注意力机制"><a href="#为什么需要注意力机制" class="headerlink" title="为什么需要注意力机制"></a>为什么需要注意力机制</h3><p>在注意力机制出现之前,模型处理长文本有这些问题:</p><ul><li><p>无法很好地处理长距离依赖<br>比如在很长的文章中,可能会”忘记”前面提到的重要信息</p></li><li><p>不能并行处理<br>必须一个词一个词按顺序处理,效率较低</p></li></ul><p>注意力机制解决了这些问题:</p><ul><li>可以直接建立任意两个词之间的联系</li><li>支持并行计算,大大提高了处理效率</li></ul><h2 id="为什么可以并行"><a href="#为什么可以并行" class="headerlink" title="为什么可以并行"></a>为什么可以并行</h2><p>对比传统模型(RNN)和Transformer来解释为什么Transformer支持并行计算。</p><h3 id="传统RNN模型的处理方式"><a href="#传统RNN模型的处理方式" class="headerlink" title="传统RNN模型的处理方式"></a>传统RNN模型的处理方式</h3><p>假设我们有一句话：”我喜欢吃苹果”</p><p>RNN必须按顺序一个词一个词处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1步：处理&quot;我&quot;</span><br><span class="line">第2步：处理&quot;喜欢&quot; (必须等第1步完成)</span><br><span class="line">第3步：处理&quot;吃&quot; (必须等第2步完成)</span><br><span class="line">第4步：处理&quot;苹果&quot; (必须等第3步完成)</span><br></pre></td></tr></table></figure><p>就像是在读一本书，你必须从第一页开始，按顺序一页一页读下去，不能跳着读。这就是”顺序处理”。</p><h3 id="Transformer的并行处理方式"><a href="#Transformer的并行处理方式" class="headerlink" title="Transformer的并行处理方式"></a>Transformer的并行处理方式</h3><p>Transformer可以同时处理所有的词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同时处理：</span><br><span class="line">- &quot;我&quot; </span><br><span class="line">- &quot;喜欢&quot;</span><br><span class="line">- &quot;吃&quot;</span><br><span class="line">- &quot;苹果&quot;</span><br></pre></td></tr></table></figure><p>这就像是有4个人，每个人负责读一个词，他们可以同时开始读。这就是”并行处理”。</p><h3 id="为什么Transformer能做到并行？"><a href="#为什么Transformer能做到并行？" class="headerlink" title="为什么Transformer能做到并行？"></a>为什么Transformer能做到并行？</h3><p>关键在于位置编码(Positional Encoding)和自注意力机制：</p><p>a) 位置编码：</p><ul><li>每个词都会被赋予一个位置信息</li><li>比如：”我”(位置1)、”喜欢”(位置2)、”吃”(位置3)、”苹果”(位置4)</li><li>这样即使同时处理所有词，模型也知道每个词在句子中的位置</li></ul><p>举个例子：<br>就像给每个人发一张带编号的扑克牌：</p><ul><li>“我” → 1号牌</li><li>“喜欢” → 2号牌</li><li>“吃” → 3号牌</li><li>“苹果” → 4号牌</li></ul><p>这样即使大家同时看自己的牌，也知道这些词的正确顺序。</p><p>b) 自注意力机制：</p><ul><li>每个词可以同时和句子中的所有其他词计算注意力分数</li><li>不需要等待前面的词处理完成</li></ul><p>举个例子：<br>想象一个会议室里有4个人，每个人负责一个词：</p><ul><li>A负责”我”</li><li>B负责”喜欢”</li><li>C负责”吃”</li><li>D负责”苹果”</li></ul><p>他们可以同时开始工作：</p><ol><li>每个人都有一份完整的句子副本</li><li>他们可以同时查看整个句子</li><li><p>各自计算自己负责的词与其他词的关联度</p></li><li><p>实际的计算优势：</p></li></ol><p>假设处理一个有100个词的句子：</p><ul><li>RNN需要100个时间步骤，因为必须一个词一个词处理</li><li>Transformer只需要1个时间步骤，因为可以同时处理100个词</li></ul><p>这就像是：</p><ul><li>RNN：一个人要读100页书，需要花100分钟</li><li>Transformer：100个人同时读，每人读1页，只需要1分钟</li></ul><h3 id="在GPU上的优势"><a href="#在GPU上的优势" class="headerlink" title="在GPU上的优势"></a>在GPU上的优势</h3><p>现代GPU擅长并行计算，就像有很多个小工人可以同时工作。</p><ul><li>Transformer充分利用了这一优势，可以让GPU同时处理多个词</li><li>而RNN因为必须按顺序处理，无法充分利用GPU的并行能力</li></ul><p>这就是为什么说Transformer支持并行计算，它通过巧妙的设计（位置编码+自注意力机制），让所有词可以同时被处理，大大提高了计算效率。这也是Transformer相比RNN的一个重要优势。</p><h2 id="注意力机制计算过程"><a href="#注意力机制计算过程" class="headerlink" title="注意力机制计算过程"></a>注意力机制计算过程</h2><h3 id="基本概念：Query-查询-、Key-键-、Value-值"><a href="#基本概念：Query-查询-、Key-键-、Value-值" class="headerlink" title="基本概念：Query(查询)、Key(键)、Value(值)"></a>基本概念：Query(查询)、Key(键)、Value(值)</h3><p>先用一个生活中的例子来理解这三个概念：<br>想象你去图书馆找书：</p><ul><li>Query(查询)：你想找的书的关键词，比如”人工智能入门”</li><li>Key(键)：图书馆里每本书的标题</li><li>Value(值)：书的具体内容</li></ul><h3 id="在Transformer中的对应关系"><a href="#在Transformer中的对应关系" class="headerlink" title="在Transformer中的对应关系"></a>在Transformer中的对应关系</h3><p>还是用前面的例子：<br>“昨天下午,小明在公园里遇到了小红,她穿着一条蓝色的裙子。”</p><p>当我们要理解”她”这个词时：</p><ul><li>Query(查询)：是”她”这个词的表示向量</li><li>Key(键)：句子中所有词的表示向量</li><li>Value(值)：句子中所有词携带的信息</li></ul><h3 id="具体计算步骤"><a href="#具体计算步骤" class="headerlink" title="具体计算步骤"></a>具体计算步骤</h3><p>让我们用一个简化的例子来说明：<br>“小红很喜欢吃苹果”</p><p>第一步：转换为向量<br>假设我们用2维向量来表示每个词（实际中通常是512维或更高）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;小红&quot; → [2, 3]</span><br><span class="line">&quot;很&quot; → [1, 1]</span><br><span class="line">&quot;喜欢&quot; → [2, 2]</span><br><span class="line">&quot;吃&quot; → [1, 2]</span><br><span class="line">&quot;苹果&quot; → [3, 1]</span><br></pre></td></tr></table></figure><p>第二步：计算Query、Key、Value<br>每个词都会被转换为三种向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如&quot;小红&quot;：</span><br><span class="line">Q向量(查询)：[2, 3] × WQ = [4, 6]</span><br><span class="line">K向量(键)：[2, 3] × WK = [5, 7]</span><br><span class="line">V向量(值)：[2, 3] × WV = [3, 4]</span><br></pre></td></tr></table></figure><p>(其中WQ、WK、WV是可学习的权重矩阵)</p><p>第三步：计算注意力分数<br>以”小红”为例，计算它与所有词的相关度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相关度 = Q向量 · K向量 / √维度</span><br><span class="line"></span><br><span class="line">比如&quot;小红&quot;和&quot;苹果&quot;的相关度：</span><br><span class="line">= [4, 6] · [5, 7] / √2</span><br><span class="line">= (4×5 + 6×7) / 1.414</span><br><span class="line">= (20 + 42) / 1.414</span><br><span class="line">= 43.7</span><br></pre></td></tr></table></figure><p>第四步：归一化分数<br>使用softmax函数将所有分数转换为0-1之间的概率值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始分数：[43.7, 35.2, 28.9, 31.5, 39.6]</span><br><span class="line">归一化后：[0.3, 0.2, 0.1, 0.15, 0.25]</span><br></pre></td></tr></table></figure><p>第五步：加权求和<br>用这些概率值去加权每个词的Value向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终表示 = 0.3×V1 + 0.2×V2 + 0.1×V3 + 0.15×V4 + 0.25×V5</span><br></pre></td></tr></table></figure><h3 id="多头注意力"><a href="#多头注意力" class="headerlink" title="多头注意力"></a>多头注意力</h3><p>实际上，Transformer使用了多头注意力机制，相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 注意力头1：可能关注语法关系</span><br><span class="line">- 注意力头2：可能关注语义关系</span><br><span class="line">- 注意力头3：可能关注位置关系</span><br><span class="line">...（通常有8个头）</span><br></pre></td></tr></table></figure><p>每个头都独立计算注意力分数，最后将所有结果合并。</p><h3 id="形象的比喻"><a href="#形象的比喻" class="headerlink" title="形象的比喻"></a>形象的比喻</h3><p>这个过程就像：</p><ul><li>一个人(Query)在派对上(句子)寻找聊天对象</li><li>他会看看每个人(Key)是否适合聊天</li><li>计算相关度就像评估与每个人的共同话题多少</li><li>最后主要和相关度高的人(Value)交流</li></ul><p>或者像：</p><ul><li>一个学生(Query)在解答问题</li><li>他会查看所有笔记(Key)</li><li>计算每页笔记与问题的相关度</li><li>最后主要参考相关度高的笔记内容(Value)</li></ul><p>这就是注意力分数的计算过程。虽然数学计算看起来复杂，但基本思想是让模型能够像人类一样，通过计算相关度来决定应该重点关注哪些信息。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="词向量的基本概念"><a href="#词向量的基本概念" class="headerlink" title="词向量的基本概念"></a>词向量的基本概念</h3><p>词向量(Word Embedding)是将单词转换为计算机可以理解的数值向量的方法。主要有以下特点：</p><ul><li>每个单词被映射到一个固定维度(比如300维)的向量空间中</li><li>语义相近的词在向量空间中的距离也相近</li><li>向量之间可以进行数学运算,比如:<br>vector(‘国王’) - vector(‘男人’) + vector(‘女人’) ≈ vector(‘女王’)</li></ul><h3 id="获取词向量的主要方法"><a href="#获取词向量的主要方法" class="headerlink" title="获取词向量的主要方法"></a>获取词向量的主要方法</h3><p>(1) Word2Vec模型:</p><ul><li>CBOW(Continuous Bag of Words):使用上下文预测目标词</li><li>Skip-gram:使用目标词预测上下文词</li><li>通过神经网络训练,学习词与词之间的语义关系</li></ul><p>(2) GloVe模型:</p><ul><li>基于全局矩阵分解</li><li>统计词与词的共现频率</li><li>结合局部上下文窗口方法</li></ul><p>(3) FastText模型:</p><ul><li>将单词分解为子词单元(n-gram)</li><li>能处理词表外的词</li><li>对拼写错误有一定容忍度</li></ul><h3 id="Transformer中的向量表示"><a href="#Transformer中的向量表示" class="headerlink" title="Transformer中的向量表示"></a>Transformer中的向量表示</h3><p>Transformer中的输入向量由三部分组成:</p><p>(1) 词嵌入(Token Embeddings):</p><ul><li>表示单词本身的语义</li><li>通过可训练的嵌入矩阵获得</li><li>维度通常是512维</li></ul><p>(2) 位置嵌入(Positional Embeddings):</p><ul><li>表示单词在序列中的位置信息</li><li>使用正弦和余弦函数计算</li><li>与词嵌入维度相同</li></ul><p>(3) 段嵌入(Segment Embeddings):</p><ul><li>用于区分不同的句子或段落</li><li>主要用于BERT等模型</li></ul><h3 id="向量的计算过程"><a href="#向量的计算过程" class="headerlink" title="向量的计算过程"></a>向量的计算过程</h3><p>(1) 首先进行分词(Tokenization):</p><ul><li>将输入文本分解为token</li><li>每个token映射到一个唯一的ID</li><li>构建词表(Vocabulary)</li></ul><p>(2) 通过嵌入层获取词向量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">embedding = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line">token_embedding = embedding(token_ids)</span><br></pre></td></tr></table></figure><p>(3) 计算位置编码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PE(pos,<span class="number">2</span>i) = sin(pos/<span class="number">10000</span>^(<span class="number">2</span>i/d))</span><br><span class="line">PE(pos,<span class="number">2</span>i+<span class="number">1</span>) = cos(pos/<span class="number">10000</span>^(<span class="number">2</span>i/d))</span><br></pre></td></tr></table></figure><p>(4) 将词向量和位置编码相加:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_embedding = token_embedding + positional_embedding</span><br></pre></td></tr></table></figure><h3 id="向量的特点"><a href="#向量的特点" class="headerlink" title="向量的特点"></a>向量的特点</h3><ul><li>维度固定:通常是512维或768维</li><li>稠密表示:每个维度都有值,不是one-hot编码</li><li>可训练:通过反向传播不断优化</li><li>可解释:向量间的距离和运算有语义含义</li></ul><p>这样,每个输入token最终都被转换为一个包含语义信息和位置信息的高维向量,作为Transformer的输入。这种向量表示使得模型能够:</p><ul><li>理解词与词之间的语义关系</li><li>捕捉序列中的位置信息</li><li>并行处理整个序列</li><li>处理变长的输入</li></ul><p>这就是Transformer中向量表示的基本原理。通过这种方式,模型可以有效地理解和处理自然语言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注意力机制简单了解。&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://luckyp.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>极简科学上网</title>
    <link href="https://luckyp.top/VPN/"/>
    <id>https://luckyp.top/VPN/</id>
    <published>2025-05-01T10:59:50.000Z</published>
    <updated>2025-05-01T10:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>极简科学上网自建 VPN 方案</p><a id="more"></a><h2 id="🎯-极简科学上网方案"><a href="#🎯-极简科学上网方案" class="headerlink" title="🎯 极简科学上网方案"></a>🎯 <strong>极简科学上网方案</strong></h2><h3 id="💰-最经济配置"><a href="#💰-最经济配置" class="headerlink" title="💰 最经济配置"></a><strong>💰 最经济配置</strong></h3><h4 id="🥇-推荐方案：-2-5-5-月"><a href="#🥇-推荐方案：-2-5-5-月" class="headerlink" title="🥇 推荐方案：$2.5-5/月"></a><strong>🥇 推荐方案：$2.5-5/月</strong></h4><ul><li><strong>服务器</strong>：Vultr/DigitalOcean 最小配置</li><li><strong>配置</strong>：1 核 512MB-1GB 内存，10-25GB 硬盘</li><li><strong>流量</strong>：500GB-1TB/月（够用）</li><li><strong>地区</strong>：日本、新加坡、美国西海岸</li></ul><h4 id="🏆-超值推荐"><a href="#🏆-超值推荐" class="headerlink" title="🏆 超值推荐"></a><strong>🏆 超值推荐</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vultr VPS Regular Performance</span><br><span class="line">• CPU: 1核</span><br><span class="line">• 内存: 512MB</span><br><span class="line">• 存储: 10GB SSD</span><br><span class="line">• 流量: 500GB</span><br><span class="line">• 价格: $2.5/月</span><br></pre></td></tr></table></figure><h3 id="⚡-最简单部署方法"><a href="#⚡-最简单部署方法" class="headerlink" title="⚡ 最简单部署方法"></a><strong>⚡ 最简单部署方法</strong></h3><h4 id="🔥-一键脚本安装（推荐新手）"><a href="#🔥-一键脚本安装（推荐新手）" class="headerlink" title="🔥 一键脚本安装（推荐新手）"></a><strong>🔥 一键脚本安装（推荐新手）</strong></h4><h4 id="方案一：WireGuard-一键脚本"><a href="#方案一：WireGuard-一键脚本" class="headerlink" title="方案一：WireGuard 一键脚本"></a><strong>方案一：WireGuard 一键脚本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到服务器后，直接运行：</span></span><br><span class="line">wget https://git.io/wireguard -O wireguard.sh &amp;&amp; bash wireguard.sh</span><br></pre></td></tr></table></figure><h4 id="方案二：V2Ray-一键脚本"><a href="#方案二：V2Ray-一键脚本" class="headerlink" title="方案二：V2Ray 一键脚本"></a><strong>方案二：V2Ray 一键脚本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抗封锁能力更强</span></span><br><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure><h4 id="方案三：Shadowsocks-一键脚本"><a href="#方案三：Shadowsocks-一键脚本" class="headerlink" title="方案三：Shadowsocks 一键脚本"></a><strong>方案三：Shadowsocks 一键脚本</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最轻量级选择</span></span><br><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><h3 id="📱-客户端下载"><a href="#📱-客户端下载" class="headerlink" title="📱 客户端下载"></a><strong>📱 客户端下载</strong></h3><h4 id="安卓手机"><a href="#安卓手机" class="headerlink" title="安卓手机"></a><strong>安卓手机</strong></h4><ul><li><strong>V2rayNG</strong>：支持多协议</li><li><strong>WireGuard</strong>：官方客户端</li><li><strong>Shadowsocks</strong>：经典选择</li></ul><h4 id="苹果手机"><a href="#苹果手机" class="headerlink" title="苹果手机"></a><strong>苹果手机</strong></h4><ul><li><strong>Shadowrocket</strong>：$2.99（美区 App Store）</li><li><strong>Quantumult X</strong>：功能强大</li><li><strong>WireGuard</strong>：免费官方版</li></ul><h4 id="Windows-电脑"><a href="#Windows-电脑" class="headerlink" title="Windows 电脑"></a><strong>Windows 电脑</strong></h4><ul><li><strong>V2rayN</strong>：图形界面，简单易用</li><li><strong>WireGuard</strong>：官方客户端</li><li><strong>SSTap</strong>：游戏加速也支持</li></ul><h4 id="Mac-电脑"><a href="#Mac-电脑" class="headerlink" title="Mac 电脑"></a><strong>Mac 电脑</strong></h4><ul><li><strong>ClashX</strong>：功能完整</li><li><strong>WireGuard</strong>：官方版本</li><li><strong>ShadowsocksX-NG</strong>：轻量选择</li></ul><h3 id="🚀-30-秒快速上手"><a href="#🚀-30-秒快速上手" class="headerlink" title="🚀 30 秒快速上手"></a><strong>🚀 30 秒快速上手</strong></h3><h4 id="第-1-步：购买服务器（5-分钟）"><a href="#第-1-步：购买服务器（5-分钟）" class="headerlink" title="第 1 步：购买服务器（5 分钟）"></a><strong>第 1 步：购买服务器（5 分钟）</strong></h4><ol><li>注册 Vultr 账号：<a href="https://vultr.com" target="_blank" rel="noopener">vultr.com</a></li><li>充值$10（支付宝/微信支付）</li><li>选择日本或新加坡节点</li><li>选择 Ubuntu 20.04 系统</li><li>选择$2.5/月套餐</li><li>点击 Deploy 部署</li></ol><h4 id="第-2-步：连接服务器（2-分钟）"><a href="#第-2-步：连接服务器（2-分钟）" class="headerlink" title="第 2 步：连接服务器（2 分钟）"></a><strong>第 2 步：连接服务器（2 分钟）</strong></h4><p><strong>Windows 用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载PuTTY，输入服务器IP和端口22</span></span><br><span class="line"><span class="comment"># 用户名：root，密码：在服务器详情查看</span></span><br></pre></td></tr></table></figure><p><strong>Mac/Linux 用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@你的服务器IP</span><br><span class="line"><span class="comment"># 输入密码登录</span></span><br></pre></td></tr></table></figure><h4 id="第-3-步：一键安装（1-分钟）"><a href="#第-3-步：一键安装（1-分钟）" class="headerlink" title="第 3 步：一键安装（1 分钟）"></a><strong>第 3 步：一键安装（1 分钟）</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制粘贴运行（推荐WireGuard）</span></span><br><span class="line">wget https://git.io/wireguard -O wireguard.sh &amp;&amp; bash wireguard.sh</span><br></pre></td></tr></table></figure><p>按提示设置：</p><ul><li>客户端数量：5-10 个</li><li>其他选项：全部默认回车</li></ul><h4 id="第-4-步：获取配置（30-秒）"><a href="#第-4-步：获取配置（30-秒）" class="headerlink" title="第 4 步：获取配置（30 秒）"></a><strong>第 4 步：获取配置（30 秒）</strong></h4><p>安装完成后会显示：</p><ul><li>二维码（手机扫描）</li><li>配置文件（电脑导入）</li></ul><h3 id="💡-超简单使用方法"><a href="#💡-超简单使用方法" class="headerlink" title="💡 超简单使用方法"></a><strong>💡 超简单使用方法</strong></h3><h4 id="手机使用"><a href="#手机使用" class="headerlink" title="手机使用"></a><strong>手机使用</strong></h4><ol><li>下载 WireGuard APP</li><li>扫描服务器生成的二维码</li><li>点击连接开关</li><li>完成！可以访问 Google 了</li></ol><h4 id="电脑使用"><a href="#电脑使用" class="headerlink" title="电脑使用"></a><strong>电脑使用</strong></h4><ol><li>下载 WireGuard 客户端</li><li>导入配置文件（.conf 文件）</li><li>点击连接</li><li>完成！</li></ol><h3 id="📊-成本对比"><a href="#📊-成本对比" class="headerlink" title="📊 成本对比"></a><strong>📊 成本对比</strong></h3><table><thead><tr><th>方案</th><th>月费用</th><th>年费用</th><th>特点</th></tr></thead><tbody><tr><td><strong>自建 VPN</strong></td><td>$2.5-5</td><td>$30-60</td><td>完全私有，无限流量</td></tr><tr><td><strong>商业 VPN</strong></td><td>$3-12</td><td>$36-144</td><td>即用即开，多节点</td></tr><tr><td><strong>机场服务</strong></td><td>$5-20</td><td>$60-240</td><td>高速专线，易被封</td></tr></tbody></table><h3 id="🛡️-安全优化（可选）"><a href="#🛡️-安全优化（可选）" class="headerlink" title="🛡️ 安全优化（可选）"></a><strong>🛡️ 安全优化（可选）</strong></h3><p>如果想要更好的隐蔽性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 修改SSH端口</span></span><br><span class="line">sudo nano /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 将Port 22改为其他端口如2233</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 设置防火墙</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line">sudo ufw allow 2233/tcp  <span class="comment"># 你的SSH端口</span></span><br><span class="line">sudo ufw allow 51820/udp <span class="comment"># WireGuard端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 禁用密码登录（使用密钥）</span></span><br><span class="line">sudo nano /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># PasswordAuthentication no</span></span><br></pre></td></tr></table></figure><h3 id="🔧-常见问题解决"><a href="#🔧-常见问题解决" class="headerlink" title="🔧 常见问题解决"></a><strong>🔧 常见问题解决</strong></h3><h4 id="连不上网络？"><a href="#连不上网络？" class="headerlink" title="连不上网络？"></a><strong>连不上网络？</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查服务状态</span></span><br><span class="line">sudo systemctl status wg-quick@wg0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">sudo systemctl restart wg-quick@wg0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看端口是否开放</span></span><br><span class="line">sudo netstat -ulnp | grep 51820</span><br></pre></td></tr></table></figure><h4 id="速度太慢？"><a href="#速度太慢？" class="headerlink" title="速度太慢？"></a><strong>速度太慢？</strong></h4><ol><li><strong>换服务器地区</strong>：选择离你更近的节点</li><li><strong>换协议</strong>：WireGuard &gt; V2Ray &gt; OpenVPN</li><li><strong>升级配置</strong>：选择更高配置的 VPS</li></ol><h4 id="IP-被封？"><a href="#IP-被封？" class="headerlink" title="IP 被封？"></a><strong>IP 被封？</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新部署新服务器</span></span><br><span class="line"><span class="comment"># 删除当前服务器，创建新的</span></span><br><span class="line"><span class="comment"># 几分钟就能获得新IP</span></span><br></pre></td></tr></table></figure><h3 id="🎁-省钱小技巧"><a href="#🎁-省钱小技巧" class="headerlink" title="🎁 省钱小技巧"></a><strong>🎁 省钱小技巧</strong></h3><ol><li><strong>新用户优惠</strong>：Vultr 新用户送$100 体验金</li><li><strong>按需使用</strong>：不用时删除服务器，用时重建</li><li><strong>合理选择</strong>：512MB 内存足够轻度使用</li><li><strong>流量监控</strong>：设置流量告警避免超额</li><li><strong>多备份</strong>：准备 2-3 个不同服务商账号</li></ol><h3 id="⚡-终极懒人方案"><a href="#⚡-终极懒人方案" class="headerlink" title="⚡ 终极懒人方案"></a><strong>⚡ 终极懒人方案</strong></h3><p>如果连上面的步骤都觉得麻烦：</p><ol><li><strong>购买现成服务</strong>：找靠谱的技术朋友代搭建</li><li><strong>使用脚本市场</strong>：一些自动化脚本网站</li><li><strong>Docker 一键版</strong>：预打包的 Docker 镜像</li></ol><p><strong>一行命令搞定</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name wireguard --<span class="built_in">cap</span>-add=NET_ADMIN -p 51820:51820/udp -v wireguard:/config linuxserver/wireguard</span><br></pre></td></tr></table></figure><h3 id="📞-需要帮助？"><a href="#📞-需要帮助？" class="headerlink" title="📞 需要帮助？"></a><strong>📞 需要帮助？</strong></h3><p><strong>常见问题</strong>：</p><ul><li>服务器连不上 → 检查 IP 是否被墙</li><li>配置不成功 → 重新运行安装脚本</li><li>速度太慢 → 换节点或升级配置</li><li>手机连不上 → 检查客户端配置</li></ul><p><strong>总结</strong>：整个过程最快 10 分钟搞定，每月成本$2.5-5，比买一杯咖啡还便宜！</p><p>需要我提供具体的搭建指导吗？我可以一步步教您操作！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;极简科学上网自建 VPN 方案&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cherryStudio使用</title>
    <link href="https://luckyp.top/cherryStudio%E4%BD%BF%E7%94%A8/"/>
    <id>https://luckyp.top/cherryStudio使用/</id>
    <published>2025-04-27T04:22:31.000Z</published>
    <updated>2025-04-27T04:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前本地部署了DeepSeek，可以通过<a href="https://github.com/CherryHQ/cherry-studio" target="_blank" rel="noopener">cherry-studio</a>图形化操作，或者使用云服务。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>访问<a href="https://www.cherry-ai.com/download" target="_blank" rel="noopener">cherry-studio</a>，下载相应的版本，默认next安装。</p><h2 id="连接本地DeepSeek"><a href="#连接本地DeepSeek" class="headerlink" title="连接本地DeepSeek"></a>连接本地DeepSeek</h2><p>通过<code>Ollama</code>创建的默认开启<code>http://127.0.0.1:11434</code>本地接口。</p><ol><li>打开设置</li><li>模型服务 &gt; Ollama</li><li>配置API地址，不改接口的情况下，按默认；本地模型不需要API密钥</li><li>选择管理添加模型</li><li>开启</li></ol><p><img src="../images/cherryStudio_1.png" alt="cherryStudio_1"></p><p>配置好后即可在助手中，选取模型使用。</p><h2 id="快速体验云服务"><a href="#快速体验云服务" class="headerlink" title="快速体验云服务"></a>快速体验云服务</h2><h3 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h3><p>点击<a href="https://cloud.siliconflow.cn/i/LEPJTo52" target="_blank" rel="noopener">siliconflow</a>，注册账号，登录自动获取14元，可以用来使用<code>满血版DeepSeek或者其它模型</code>。</p><p>当前也可以去模型广场查看免费的模型，性能可能会弱一点，测试使用还是没问题的。</p><h3 id="获取KEY"><a href="#获取KEY" class="headerlink" title="获取KEY"></a>获取KEY</h3><p>在<a href="https://cloud.siliconflow.cn/i/LEPJTo52" target="_blank" rel="noopener">siliconflow</a>创建获取Key<br><img src="../images/cherryStudio_2.png" alt="cherryStudio_2"></p><h3 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h3><p>在cherry-studio中按下图配置<br><img src="../images/cherryStudio_3.png" alt="cherryStudio_3"></p><h2 id="配置一个提示词助手"><a href="#配置一个提示词助手" class="headerlink" title="配置一个提示词助手"></a>配置一个提示词助手</h2><p>在前面的过程中配置好后，会有大模型可以使用，现在如下图所示，打开助手配置<br><img src="../images/cherryStudio_4.png" alt="cherryStudio_4"></p><p>添加提示词，后点完成即可<br><img src="../images/cherryStudio_5.png" alt="cherryStudio_5"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你是一位大模型提示词生成专家，请根据用户的需求编写一个智能助手的提示词，来指导大模型进行内容生成，要求：</span><br><span class="line">1. 以 Markdown 格式输出</span><br><span class="line">2. 贴合用户需求，描述智能助手的定位、能力、知识储备</span><br><span class="line">3. 提示词应清晰、精确、易于理解，在保持质量的同时，尽可能简洁</span><br><span class="line">4. 只输出提示词，不要输出多余解释</span><br></pre></td></tr></table></figure><p>之后想要什么助手，都可以告诉它，让它生成提示词，培养专职的助手</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前本地部署了DeepSeek，可以通过&lt;a href=&quot;https://github.com/CherryHQ/cherry-studio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cherry-studio&lt;/a&gt;图形化操作，或者使用云服务。&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://luckyp.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>DeepSeek本地部署相关</title>
    <link href="https://luckyp.top/DeepSeek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
    <id>https://luckyp.top/DeepSeek本地部署/</id>
    <published>2025-04-26T02:18:36.000Z</published>
    <updated>2025-04-26T02:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本地部署DeepSeek的简要介绍<br><a id="more"></a></p><h2 id="本地部署优点"><a href="#本地部署优点" class="headerlink" title="本地部署优点"></a>本地部署优点</h2><ul><li>免费</li><li>数据隐私</li><li>无额外限制（可绕过敏感话题，纯粹基于数据和算法逻辑）</li><li>无需网络依赖</li><li>灵活定制（根据自己的知识库配置微调）</li><li>性能和效率（不会卡顿延迟服务器繁忙）</li></ul><h2 id="本地部署缺点"><a href="#本地部署缺点" class="headerlink" title="本地部署缺点"></a>本地部署缺点</h2><p>本地部署有一个比较大的局限性，很吃设备的配置</p><ul><li>满血版：DeepSeek 的完整版本，通常具有非常大的参数量。eg：DeepSeek-R1</li><li>蒸馏版本：通过知识蒸馏技术从满血版模型中提取关键知识并转移到更小的模型中，从而在保持较高性能的同时，显著降低计算资源需求。<br>DeepSeek-R1-Distill-Qwen-32B（Distill代表蒸馏，Qwen代表是基于阿里的开源大模型千问，32B代表模型中可训练参数的数量）</li></ul><p>从性价比角度，32b就已经很不错了，当然满血版更好。<br><img src="../images/deepseek_1.png" alt="deepseek_1"></p><h2 id="🔗-官方文档位置"><a href="#🔗-官方文档位置" class="headerlink" title="🔗 官方文档位置"></a>🔗 官方文档位置</h2><p><strong>主要来源</strong>：<a href="https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf" target="_blank" rel="noopener"><strong>DeepSeek-R1 GitHub 仓库</strong></a></p><h2 id="📋-系统要求"><a href="#📋-系统要求" class="headerlink" title="📋 系统要求"></a>📋 系统要求</h2><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><table><thead><tr><th>模型大小</th><th>GPU 显存</th><th>系统内存</th><th>存储空间</th></tr></thead><tbody><tr><td>1.5B-7B</td><td>8GB+</td><td>16GB+</td><td>50GB+</td></tr><tr><td>8B-14B</td><td>16GB+</td><td>32GB+</td><td>100GB+</td></tr><tr><td>32B+</td><td>32GB+</td><td>64GB+</td><td>200GB+</td></tr><tr><td>67B+</td><td>80GB+</td><td>128GB+</td><td>500GB+</td></tr></tbody></table><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ul><li><strong>操作系统</strong>：Linux/macOS/Windows</li><li><strong>Python</strong>：3.8+</li><li><strong>CUDA</strong>：11.8+ (NVIDIA GPU)</li><li><strong>工具</strong>：Ollama/vLLM/Transformers</li></ul><h2 id="🚀-三种主要安装方法"><a href="#🚀-三种主要安装方法" class="headerlink" title="🚀 三种主要安装方法"></a>🚀 三种主要安装方法</h2><h3 id="方法-1：使用-Ollama（推荐新手）"><a href="#方法-1：使用-Ollama（推荐新手）" class="headerlink" title="方法 1：使用 Ollama（推荐新手）"></a>方法 1：使用 Ollama（推荐新手）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装Ollama</span></span><br><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 拉取模型</span></span><br><span class="line">ollama pull deepseek-r1:7b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 运行模型</span></span><br><span class="line">ollama run deepseek-r1:7b</span><br></pre></td></tr></table></figure><h3 id="方法-2：使用-vLLM（生产环境）"><a href="#方法-2：使用-vLLM（生产环境）" class="headerlink" title="方法 2：使用 vLLM（生产环境）"></a>方法 2：使用 vLLM（生产环境）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装依赖</span></span><br><span class="line">pip install vllm transformers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启动服务</span></span><br><span class="line">vllm serve <span class="string">"deepseek-ai/DeepSeek-R1-Distill-Llama-8B"</span> --max_model 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. API调用</span></span><br><span class="line">curl -X POST <span class="string">"http://localhost:8000/v1/chat/completions"</span> \</span><br><span class="line">    -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">    --data <span class="string">'&#123;"model": "deepseek-ai/DeepSeek-R1-Distill-Llama-8B", "messages": [&#123;"role": "user", "content": "你好"&#125;]&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="方法-3：使用-Transformers（研究用途）"><a href="#方法-3：使用-Transformers（研究用途）" class="headerlink" title="方法 3：使用 Transformers（研究用途）"></a>方法 3：使用 Transformers（研究用途）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建管道</span></span><br><span class="line">pipe = pipeline(<span class="string">"text-generation"</span>, model=<span class="string">"deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型</span></span><br><span class="line">messages = [&#123;<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: <span class="string">"你好，请介绍一下自己"</span>&#125;]</span><br><span class="line">response = pipe(messages)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h2 id="📚-官方资源链接"><a href="#📚-官方资源链接" class="headerlink" title="📚 官方资源链接"></a>📚 <strong>官方资源链接</strong></h2><ol><li><strong><a href="https://github.com/deepseek-ai/DeepSeek-R1" target="_blank" rel="noopener">GitHub 仓库</a></strong> - 90k⭐，包含完整代码和文档</li><li><strong><a href="https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf" target="_blank" rel="noopener">技术论文</a></strong> - 详细技术细节</li><li><strong><a href="https://huggingface.co/deepseek-ai" target="_blank" rel="noopener">Hugging Face 模型页面</a></strong> - 多个模型变体</li><li><strong>DeepSeek 官网</strong> (deepseek.com) - 最新公告和指南</li></ol><h2 id="💡-快速开始建议"><a href="#💡-快速开始建议" class="headerlink" title="💡 快速开始建议"></a>💡 快速开始建议</h2><ol><li><strong>检查硬件</strong>：确认 GPU 内存足够</li><li><strong>选择模型大小</strong>：从 7B 模型开始测试</li><li><strong>使用 Ollama</strong>：最简单的入门方式</li><li><strong>逐步优化</strong>：根据需求调整配置</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地部署DeepSeek的简要介绍&lt;br&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://luckyp.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Cursor使用</title>
    <link href="https://luckyp.top/Cursor%E4%BD%BF%E7%94%A8/"/>
    <id>https://luckyp.top/Cursor使用/</id>
    <published>2025-04-19T03:54:32.000Z</published>
    <updated>2025-04-19T03:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cursor功能基本用法<br><a id="more"></a></p><h2 id="快捷询问"><a href="#快捷询问" class="headerlink" title="快捷询问"></a>快捷询问</h2><p>选中字段后</p><ul><li>Ctrl+I打开chat（实际使用和Ctrl+L差不多）</li><li>Ctrl+L创建新的chat（长篇询问）</li><li>Ctrl+K创建新的短词询问（比如添加注释）</li></ul><h3 id="聊天模式"><a href="#聊天模式" class="headerlink" title="聊天模式"></a>聊天模式</h3><p>推荐默认的代理模式Agent</p><ul><li>Agent：读写模式，开启所有的工具集</li><li>Ask： 只读模式，不支持修改。用于提出问题、探索和了解代码库</li><li>Manual： 手动模式。只访问修改提供的上下文<br><img src="../images/cursor_1.png" alt="cursor_1"></li></ul><h3 id="切换模型"><a href="#切换模型" class="headerlink" title="切换模型"></a>切换模型</h3><ul><li>快捷键 Ctrl + /，输入模型</li><li>图形点击<br><img src="../images/cursor_2.png" alt="cursor_2"></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li><p>Claude 3.7 Sonnet / Claude 3.7 Sonnet MAX</p><ul><li>开发商：Anthropic</li><li>特点：Claude 3.7 Sonnet 是 Claude 3 系列的中高端模型，擅长理解复杂文本、代码、推理和创意写作。MAX 版本通常指的是更高配额或更快响应速度。</li><li>适用场景：代码生成、文档总结、复杂对话、推理任务。</li></ul><hr></li><li><p>Gemini 2.5 Pro / Gemini 2.5 Pro Exp / Gemini 2.5 Pro MAX</p><ul><li>开发商：Google（原名 Bard，Gemini 是升级版）</li><li>特点：Gemini 2.5 Pro 是 Google 最新的多模态大模型，支持文本、图片等多种输入，理解能力强，推理和代码能力也很优秀。Exp 版本为实验性，MAX 版本为高配额。</li><li>适用场景：多模态任务、代码、复杂问答、图片理解。</li></ul><hr></li><li><p>GPT-4.1 / GPT-4o</p><ul><li>开发商：OpenAI</li><li>GPT-4.1：GPT-4 的升级版，文本理解和生成能力极强，代码能力也很强。</li><li>GPT-4o：OpenAI 最新旗舰模型，o 代表“omni”，多模态能力更强，响应速度更快，推理和代码能力进一步提升。</li><li>适用场景：高质量文本生成、代码、推理、复杂对话、多模态任务。</li></ul><hr></li><li><p>o4-mini / o3</p><ul><li>开发商：OpenAI</li><li>o4-mini：GPT-4o 的轻量级版本，速度快，适合对响应速度要求高但对质量要求一般的场景。</li><li>o3：GPT-3.5 的升级版，速度快，成本低，适合日常对话和轻量级任务。</li></ul><hr></li></ol><p>总结建议</p><ul><li>追求最强代码/推理/多模态能力：优先用 GPT-4o、Gemini 2.5 Pro、Claude 3.7 Sonnet</li><li>追求速度和成本：用 o4-mini、o3</li><li>需要 Google 生态/图片理解：Gemini 2.5 Pro</li><li>需要 Anthropic 风格/安全性：Claude 3.7 Sonnet</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>带MAX的按条收费</p><h2 id="Think模式"><a href="#Think模式" class="headerlink" title="Think模式"></a>Think模式</h2><p>深入思考推理模式。推理模式尽量直接说明问题，减少提示词（模型在推理过程中会自行加提示词，过多的提示词会干扰推理）。<br><img src="../images/cursor_3.png" alt="cursor_3"></p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>添加上下文询问，有利于提高精度</p><ul><li>@Files。通过输入文件名作为上下文</li><li>#Files。特别关注某个文件，配合@Files</li><li>/command。可以快速添加打开的文件作为上下文</li><li>@Folders。通过输入文件夹作为上下文</li><li>@Code。选中代码段（Ctrl+L）</li><li>@Git。查询询问代码情况</li><li>@Doc。询问文档相关</li><li>@图片。例如实现图片内容</li><li>@Web。接入外部实时网络查询</li><li>@powershell。询问运行控制台指令</li><li>@Link。通过粘贴URL链接作为上下文</li><li>@Rules。Rule自定义</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>智能提示，Tab键入，快速编写/修改</li><li>MCP，允许通过标准化接口将代理连接到各种数据源和工具，从而扩展代理的功能</li><li>自动生成提交信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cursor功能基本用法&lt;br&gt;
    
    </summary>
    
    
      <category term="编辑器" scheme="https://luckyp.top/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>npx serve</title>
    <link href="https://luckyp.top/npx-serve/"/>
    <id>https://luckyp.top/npx-serve/</id>
    <published>2024-10-01T03:38:54.000Z</published>
    <updated>2024-10-01T03:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>用于快速启动静态文件服务器的命令行工具。这个工具可以帮助开发者在本地快速查看 HTML、CSS 和 JavaScript 文件的效果，而无需设置复杂的服务器环境。<br><a id="more"></a></p><h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><p>对于本地的静态资源预览，有些可能需要启动http服务，才能实现更好的预览效果。<br>之前用的主要是VsCode的插件<a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">LiveServer</a>来快速开启。查阅vue官方时，发现了这个指令。简单了解一下大概。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对于一个如下的目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/project</span><br><span class="line">  ├── index.html</span><br><span class="line">  ├── styles.css</span><br><span class="line">  └── script.js</span><br></pre></td></tr></table></figure><p>打开控制台输入<code>npx serve</code>，如果是第一次会需要输入y，执行下载依赖包，之后会自动开启本地服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS D:\project&gt;npx serve</span><br><span class="line">Need to install the following packages:</span><br><span class="line">  serve@14.2.4</span><br><span class="line">Ok to proceed? (y) y</span><br><span class="line"></span><br><span class="line">   ┌─────────────────────────────────────────┐</span><br><span class="line">   │                                         │</span><br><span class="line">   │   Serving!                              │</span><br><span class="line">   │                                         │</span><br><span class="line">   │   - Local:    http://localhost:3000     │</span><br><span class="line">   │   - Network:  http://172.29.16.1:3000   │</span><br><span class="line">   │                                         │</span><br><span class="line">   │   Copied local address to clipboard!    │</span><br><span class="line">   │                                         │</span><br><span class="line">   └─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="指定端口号"><a href="#指定端口号" class="headerlink" title="指定端口号"></a>指定端口号</h3><p>通过使用 <code>-l</code> 参数指定其他端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx serve -l 3000</span><br></pre></td></tr></table></figure><h3 id="设置缓存时间"><a href="#设置缓存时间" class="headerlink" title="设置缓存时间"></a>设置缓存时间</h3><p>通过 <code>-t</code> 参数设置缓存时间，以秒为单位。例如，设置缓存时间为 10 秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx serve -t 10</span><br></pre></td></tr></table></figure><h3 id="启用压缩"><a href="#启用压缩" class="headerlink" title="启用压缩"></a>启用压缩</h3><p>通过 <code>-c</code> 参数可以启用 gzip 压缩，提高传输效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx serve -c</span><br></pre></td></tr></table></figure><h2 id="简易结合webpack"><a href="#简易结合webpack" class="headerlink" title="简易结合webpack"></a>简易结合webpack</h2><h3 id="初始化package添加script"><a href="#初始化package添加script" class="headerlink" title="初始化package添加script"></a>初始化package添加script</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;serve&quot;: &quot;npx serve dist&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli serve --save-dev</span><br></pre></td></tr></table></figure><h3 id="配置-Webpack"><a href="#配置-Webpack" class="headerlink" title="配置 Webpack"></a>配置 Webpack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;development&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于快速启动静态文件服务器的命令行工具。这个工具可以帮助开发者在本地快速查看 HTML、CSS 和 JavaScript 文件的效果，而无需设置复杂的服务器环境。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="https://luckyp.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>sticky定位示例</title>
    <link href="https://luckyp.top/sticky%E5%AE%9A%E4%BD%8D%E7%A4%BA%E4%BE%8B/"/>
    <id>https://luckyp.top/sticky定位示例/</id>
    <published>2023-11-05T07:04:15.000Z</published>
    <updated>2023-11-05T07:04:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>粘性定位区别于其他的定位方式，目前浏览器兼容性良好，使用起来很方便，但是不是很好理解使用，列举几个实现效果。<br><a id="more"></a></p><h2 id="基础概念使用"><a href="#基础概念使用" class="headerlink" title="基础概念使用"></a>基础概念使用</h2><p>MDN中简单的介绍了它的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#%E7%B2%98%E6%80%A7%E5%AE%9A%E4%BD%8D" target="_blank" rel="noopener">概念</a>。</p><blockquote><p>元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的层叠上下文（stacking context）。注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为</p></blockquote><hr><p>简单来说，就是以下几点：</p><ul><li>如果父元素position不是static，就会根据父元素定位，如果不是，往上查找滚动的非标准元素（position不是static）</li><li>这个元素本身是标准流的元素，类似static</li><li>当设置了top/bottom/left/right，会在到达指定偏移量后浮动，类似fixed</li></ul><h2 id="相对于底部浮动"><a href="#相对于底部浮动" class="headerlink" title="相对于底部浮动"></a>相对于底部浮动</h2><p>设置相对于顶部只需要设置top，在可视区域内，向下滚动，父元素相对可视区域顶部消失时，粘性定位元素就会生效。</p><p>如果想要针对实现，父元素相对可视区域底部出现，固定显示需要一点技巧。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/yplian/mx0y9rp2/2/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .box &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 2000px;</span><br><span class="line">        background: skyblue;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .sticky &#123;</span><br><span class="line">        position: sticky;</span><br><span class="line">        bottom: 0px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .content &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background: yellowgreen;</span><br><span class="line">        border: 1px solid saddlebrown;</span><br><span class="line">        position: absolute;</span><br><span class="line">        bottom: 20px;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 200px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100%;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sticky"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字，这是一段文字</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 800px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="固定底图文字从底部向上滑动"><a href="#固定底图文字从底部向上滑动" class="headerlink" title="固定底图文字从底部向上滑动"></a>固定底图文字从底部向上滑动</h2><p>全屏背景图，向上滑动时，文字从底部移动至中间。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/yplian/dc81Le0p/5/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    /* 加上 -webkit- 注意兼容 */</span><br><span class="line">    h1 &#123;</span><br><span class="line">    background: -webkit-linear-gradient(135deg,</span><br><span class="line">        #0eaf6d,</span><br><span class="line">        #ff6ac6 25%,</span><br><span class="line">        #147b96 50%,</span><br><span class="line">        #e6d205 55%,</span><br><span class="line">        #2cc4e0 60%,</span><br><span class="line">        #8b2ce0 80%,</span><br><span class="line">        #ff6384 95%,</span><br><span class="line">        #08dfb4);</span><br><span class="line">        /* 文字颜色填充设置为透明 */</span><br><span class="line">        -webkit-text-fill-color: transparent;</span><br><span class="line">        /* 背景裁剪，即让文字使用背景色 */</span><br><span class="line">        -webkit-background-clip: text;</span><br><span class="line">        /* 背景图放大一下，看着柔和一些 */</span><br><span class="line">        -webkit-background-size: 200% 100%;</span><br><span class="line">        /* 应用动画flowCss 12秒速度 无限循环 线性匀速动画*/</span><br><span class="line">        -webkit-animation: flowCss 12s infinite linear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @-webkit-keyframes flowCss &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        /* 移动背景位置 */</span><br><span class="line">        background-position: 0 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    100% &#123;</span><br><span class="line">        background-position: -400% 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h1:hover &#123;</span><br><span class="line">        animation: flowCss 4s infinite linear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .banner-wrap &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        /* 需要设置大于一屏的高度，多余的高度用来承载滚动的文字 */</span><br><span class="line">        height: 180vh;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .banner-sticky-box &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        /* 一定要设置为一屏的高度 */</span><br><span class="line">        height: 100vh;</span><br><span class="line">        position: sticky;</span><br><span class="line">        top: 0;</span><br><span class="line">        transition: 0.1s;</span><br><span class="line">        /* background: skyblue; */</span><br><span class="line">        background: url('https://www.baidu.com/img/PCfb_5bf082d29588c07f842ccde3f97243ea.png');</span><br><span class="line"></span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .banner-scrollytxt &#123;</span><br><span class="line">        width: 60%;</span><br><span class="line">        max-width: 640px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        bottom: 50vh;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%, 50%);</span><br><span class="line">        text-align: center;</span><br><span class="line">        z-index: 12;</span><br><span class="line">    &#125;</span><br><span class="line">    .other&#123;</span><br><span class="line">        height:200px;</span><br><span class="line">        background: #f2f2f2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner-sticky-box"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以放置图片之类背景图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner-scrollytxt"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 放置滚动显示的文字，任意内容均可，标准流为父盒子减去100vh的高度，这里是180-100=80vh --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文字颜色渐变流光效果<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 思路就是 文字颜色填充为透明、背景裁剪让文字使用背景色、然后设置一个渐变背景色</span></span><br><span class="line"><span class="comment">                再放大一下背景，最后通过动画移动背景位置，于是效果就出来了 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"other"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;粘性定位区别于其他的定位方式，目前浏览器兼容性良好，使用起来很方便，但是不是很好理解使用，列举几个实现效果。&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://luckyp.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Docker简要</title>
    <link href="https://luckyp.top/Docker%E7%AE%80%E8%A6%81/"/>
    <id>https://luckyp.top/Docker简要/</id>
    <published>2023-08-05T04:00:00.000Z</published>
    <updated>2023-08-05T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍<code>Docker</code>基本使用方法，附带实现在<code>Docker</code>中运行前端项目开发环境的方法。<br><a id="more"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>新手推荐下载桌面版，可视化操作更简单，很多指令可以通过可视化进行。<a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noopener">下载地址</a>。</p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p>建议通过<code>docker 指令名称 --help</code>查看详细的指令信息。这里简单列举大概有哪些。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 redis 镜像</span></span><br><span class="line">docker pull redis </span><br><span class="line"><span class="comment"># 根据 reids 镜像生成端口从内部6378映射到外部6379的容器，其名为 myredis</span></span><br><span class="line">docker run -itd --name myredis -p <span class="number">6378</span><span class="symbol">:</span><span class="number">6379</span> redis</span><br><span class="line"><span class="comment"># 查看当前的容器，获取CONTAINER ID</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="comment"># 根据容器id，进入容器内部</span></span><br><span class="line">docker exec -it CONTAINERID bash/sh</span><br><span class="line"><span class="comment"># 重启/停止容器</span></span><br><span class="line">docker restart/stop CONTAINERID</span><br><span class="line"><span class="comment"># 根据容器id，删除容器</span></span><br><span class="line">docker rm -f CONTAINERID</span><br><span class="line"><span class="comment"># 删除本地redis镜像</span></span><br><span class="line">docker rmi redis</span><br></pre></td></tr></table></figure><h3 id="容器生命周期"><a href="#容器生命周期" class="headerlink" title="容器生命周期"></a>容器生命周期</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的容器并运行一个命令  </span></span><br><span class="line"><span class="comment"># -t: 在新容器内指定一个伪终端或终端。</span></span><br><span class="line"><span class="comment"># -i: 允许你对容器内的标准输入 (STDIN) 进行交互</span></span><br><span class="line"><span class="comment"># -d: 后台运行</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">docker run -itd --name customName -p <span class="number">3000</span><span class="symbol">:</span><span class="number">3000</span> <span class="symbol">nginx:</span>latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个或多个已经被停止的容器</span></span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止一个运行中的容器</span></span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀掉一个运行中的容器</span></span><br><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker kill mynginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个或多个容器</span></span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停容器中所有的进程</span></span><br><span class="line">docker pause CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复容器中所有的进程</span></span><br><span class="line">docker unpause CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的容器但不启动它，语法同run</span></span><br><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在运行的容器中执行命令</span></span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line">docker exec -it xxxid bash/sh</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出容器  </span></span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器/镜像的元数据</span></span><br><span class="line">docker inspect [OPTIONS] NAME<span class="params">|ID [NAME|</span>ID...]</span><br><span class="line">docker inspect <span class="symbol">mysql:</span><span class="number">5.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器中运行的进程信息，支持 ps 命令参数</span></span><br><span class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到正在运行中的容器</span></span><br><span class="line">docker attach [OPTIONS] CONTAINER </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务器获取实时事件</span></span><br><span class="line">docker events [OPTIONS]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取容器的日志</span></span><br><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞运行直到容器停止，然后打印出它的退出代码</span></span><br><span class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件系统作为一个tar归档文件导出到STDOUT</span></span><br><span class="line">docker export [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于列出指定的容器的端口映射，或者查找将 PRIVATE_PORT NAT 到面向公众的端口</span></span><br><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT/PROTO]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示容器资源的使用情况，包括：CPU、内存、网络 I/O等</span></span><br><span class="line">docker stats [OPTIONS] [CONTAINER...]</span><br></pre></td></tr></table></figure><h3 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从容器创建一个新的镜像</span></span><br><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[<span class="symbol">:TAG</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于容器与主机之间的数据拷贝</span></span><br><span class="line">docker cp </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查容器里文件结构的更改</span></span><br><span class="line">docker diff [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆/登出到一个Docker镜像仓库</span></span><br><span class="line">docker login/logout [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从镜像仓库中拉取或者更新指定镜像</span></span><br><span class="line">docker pull [OPTIONS] NAME[<span class="symbol">:TAG|</span>@DIGEST]</span><br><span class="line">docker pull ngnix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span></span><br><span class="line">docker push [OPTIONS] NAME[<span class="symbol">:TAG</span>]</span><br><span class="line">docker push <span class="symbol">myimage:</span>v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从Docker Hub查找镜像</span></span><br><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><h3 id="镜像指令"><a href="#镜像指令" class="headerlink" title="镜像指令"></a>镜像指令</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地镜像</span></span><br><span class="line">docker images [OPTIONS] [REPOSITORY[<span class="symbol">:TAG</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地一个或多个镜像</span></span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记本地镜像，将其归入某一仓库</span></span><br><span class="line">docker tag [OPTIONS] IMAGE[<span class="symbol">:TAG</span>] [REGISTRYHOST/][USERNAME/]NAME[<span class="symbol">:TAG</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令用于使用 Dockerfile 创建镜像</span></span><br><span class="line">docker build [OPTIONS] PATH <span class="params">| URL |</span> -</span><br><span class="line">docker build -t imgageName .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定镜像的创建历史</span></span><br><span class="line">docker history [OPTIONS] IMAGE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定镜像保存成 tar 归档文件</span></span><br><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入使用 docker save 命令导出的镜像</span></span><br><span class="line">docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从归档文件中创建镜像</span></span><br><span class="line">docker import [OPTIONS] file<span class="params">|URL|</span>- [REPOSITORY[<span class="symbol">:TAG</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 Docker 系统信息，包括镜像和容器数</span></span><br><span class="line">docker info [OPTIONS]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 Docker 版本信息</span></span><br><span class="line">docker version [OPTIONS]</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>创建一个名字为<code>Dockerfile</code>的文件。</p><h3 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h3><p>一个依赖node的应用在docker中运行。其中的很多运行命令需要根据项目调整。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取最新的node版本，可以指定版本</span></span><br><span class="line">FROM <span class="symbol">node:</span>alpine</span><br><span class="line"><span class="comment"># 创建一个app文件夹</span></span><br><span class="line">RUN mkdir -p /app</span><br><span class="line"><span class="comment"># 设置工作目录为app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"><span class="comment"># 拷贝当前项目到该文件夹下</span></span><br><span class="line">COPY . /app</span><br><span class="line"><span class="comment"># 可以设置淘宝镜像</span></span><br><span class="line">RUN npm i --registry=<span class="symbol">https:</span>/<span class="regexp">/registry.npm.taobao.org</span></span><br><span class="line"><span class="regexp"># 安装依赖</span></span><br><span class="line"><span class="regexp">RUN npm install  </span></span><br><span class="line"><span class="regexp"># 运行前端打包指令</span></span><br><span class="line"><span class="regexp">RUN npm run build</span></span><br><span class="line"><span class="regexp"># 运行项目</span></span><br><span class="line"><span class="regexp">CMD ["npm","start"]</span></span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM：定制的镜像都是基于 FROM 的镜像，等同于 docker pull </span><br><span class="line">RUN：用于执行后面跟着的命令行命令。eg：RUN yarn（执行yarn依赖下载） 换行链接符 \</span><br><span class="line">COPY：将文件或目录复制到镜像中</span><br><span class="line">CMD：指定容器创建时的默认命令</span><br><span class="line">ENV：在容器内部设置环境变量</span><br><span class="line">WORKDIR：设置后续指令的工作目录</span><br><span class="line">VOLUME：为容器创建挂载点或声明卷</span><br><span class="line">ARG：定义在构建过程中传递给构建器的变量，可使用 <span class="string">"docker build"</span> 命令设置</span><br></pre></td></tr></table></figure><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h3><p><code>docker-compose.yml</code>文件类似与<code>Dockerfile</code>文件，是另一种更快捷的配置文件。可以参考<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">官网详情</a>。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>下面举例一种vue项目在docker环境中进行开发，本地文件改变时项目会热更新。</p><h3 id="配置docker-compose"><a href="#配置docker-compose" class="headerlink" title="配置docker-compose"></a>配置docker-compose</h3><p>项目根目录放置docker-compose.yaml文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  vueapp:</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">vueapp:0.0.1</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">vueapp</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line">     <span class="comment"># - NODE_ENV=production</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">NODE_ENV=development</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">      <span class="comment"># 映射容器的8080端口到本地的8080端口</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">8080</span><span class="string">:8080</span>  </span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./src:/app/src</span></span><br><span class="line">      <span class="comment">#- ./node_modules:/app/node_modules</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">"npm run serve"</span></span><br></pre></td></tr></table></figure><h3 id="配置Dockerfile"><a href="#配置Dockerfile" class="headerlink" title="配置Dockerfile"></a>配置Dockerfile</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的Node.js镜像作为基础镜像</span></span><br><span class="line">FROM <span class="symbol">node:</span>latest</span><br><span class="line"><span class="comment"># 创建app文件夹</span></span><br><span class="line">RUN mkdir -p /app</span><br><span class="line"><span class="comment"># 设置工作目录为/app</span></span><br><span class="line">WORKDIR /app </span><br><span class="line"><span class="comment"># 拷贝文件到该目录</span></span><br><span class="line">COPY . /app</span><br><span class="line"><span class="comment"># 安装项目依赖</span></span><br><span class="line">RUN npm install</span><br><span class="line"><span class="comment"># 启动开发服务器</span></span><br><span class="line">CMD [<span class="string">"npm"</span>, <span class="string">"run"</span>, <span class="string">"serve"</span>]</span><br></pre></td></tr></table></figure><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据当前根目录项目构建项目，加-d可后台运行，如果没有镜像会构建镜像同时启动容器</span></span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose up --force-recreate <span class="comment"># 强制清空启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭正在运行的容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker-compose restart</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><code>.dockerignore</code>文件和<code>.gitignore</code>类似，用来处理<code>docker</code>要忽略的文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍&lt;code&gt;Docker&lt;/code&gt;基本使用方法，附带实现在&lt;code&gt;Docker&lt;/code&gt;中运行前端项目开发环境的方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://luckyp.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Cookie相关</title>
    <link href="https://luckyp.top/Cookie%E7%9B%B8%E5%85%B3/"/>
    <id>https://luckyp.top/Cookie相关/</id>
    <published>2023-03-26T02:55:58.000Z</published>
    <updated>2023-03-26T02:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作<code>Cookie</code>相关内容。<br><a id="more"></a></p><h2 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取cookie</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @export</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; coockiename</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;  &#123;(string | undefined)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCookieValue</span>(<span class="params">coockiename: <span class="built_in">string</span></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = coockiename + <span class="string">'='</span>;</span><br><span class="line">    <span class="keyword">const</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ca.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> c = ca[i].trim();</span><br><span class="line">      <span class="keyword">if</span> (c.indexOf(name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.substring(name.length, c.length);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置cookie</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @export</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; val</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [expTime=365]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setCookieValue</span>(<span class="params">name: <span class="built_in">string</span>, val: <span class="built_in">string</span>, expTime = 365</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 默认cookie有效期365天, 严格设置GTM格式</span></span><br><span class="line">  <span class="keyword">const</span> exp = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + expTime * <span class="number">864e5</span>);</span><br><span class="line">  <span class="built_in">document</span>.cookie = <span class="string">`<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;encodeURIComponent(</span></span></span><br><span class="line"><span class="string"><span class="subst">    val</span></span></span><br><span class="line"><span class="string"><span class="subst">  )&#125;</span>;expires=<span class="subst">$&#123;exp.toUTCString()&#125;</span>; path=/; domain=<span class="subst">$&#123;getCookieDomain()&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取主域名"><a href="#获取主域名" class="headerlink" title="获取主域名"></a>获取主域名</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取主域名，如果域名是ip，直接返回 eg:www.baidu.com =&gt; .baidu.com</span></span><br><span class="line"><span class="comment"> * @export</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; [hostName]</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;  &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCookieDomain</span>(<span class="params">hostName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> initialHost: <span class="built_in">string</span> = hostName || location.hostname;</span><br><span class="line">  <span class="keyword">let</span> host: <span class="built_in">string</span> = initialHost;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ip =</span><br><span class="line">    /^(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|<span class="number">1</span>\\d\\d|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\\.(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|<span class="number">1</span>\\d\\d|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\\.(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|<span class="number">1</span>\\d\\d|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])\\.(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|<span class="number">1</span>\\d\\d|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>])$/;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip.test(initialHost) === <span class="literal">true</span> || initialHost === <span class="string">'localhost'</span>) <span class="keyword">return</span> initialHost;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> regex = <span class="regexp">/([^]*).*/</span>;</span><br><span class="line">  <span class="keyword">const</span> match: RegExpMatchArray | <span class="literal">null</span> = initialHost.match(regex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (match !== <span class="literal">undefined</span> &amp;&amp; match !== <span class="literal">null</span>) host = match[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (host !== <span class="literal">undefined</span> &amp;&amp; host !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strAry: <span class="built_in">string</span>[] = host.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (strAry.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      host = strAry.slice(<span class="number">1</span>).join(<span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`.<span class="subst">$&#123;host&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作&lt;code&gt;Cookie&lt;/code&gt;相关内容。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSV转JSON</title>
    <link href="https://luckyp.top/csv%E8%BD%ACjson/"/>
    <id>https://luckyp.top/csv转json/</id>
    <published>2023-02-05T02:28:31.000Z</published>
    <updated>2023-02-05T02:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>市面上有很多现在的网站，可以实现csv转为需要的格式，但因为项目的csv格式比较特殊，需要手动实现自定义。</p><p>主要通过三方的 <code>csvtojson</code> npm 包实现。记录过程，方便自定义更多格式。<br><a id="more"></a></p><p>话不多说，简单说下流程。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>多语言包为csv格式，需要将该格式转为json，便于i18n进行懒加载。</p><p>i18文件夹结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--i18n</span><br><span class="line">    |--en_us</span><br><span class="line">        |--en_US.csv</span><br><span class="line">    |--de_de</span><br><span class="line">        |--de_DE.csv</span><br></pre></td></tr></table></figure><p>csv的格式大致如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i18n/en_us/en_US.csv</span></span><br><span class="line">hello,hello</span><br><span class="line">welcome,welcome</span><br><span class="line"></span><br><span class="line"><span class="comment">// i18n/de_de/de_DE.csv</span></span><br><span class="line">hello,Hallo</span><br><span class="line">welcome,Willkommen</span><br></pre></td></tr></table></figure><p>转化后的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output/en_US.json</span></span><br><span class="line">&#123;</span><br><span class="line">    hello: hello,</span><br><span class="line">    welcome: welcome</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>打开命令行，执行</p><ul><li>mkdir demo</li><li>cd ./demo</li><li>npm init</li><li>npm install csvtojson</li><li>cd &gt;index.js</li><li>mkdir output</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> csv = <span class="built_in">require</span>(<span class="string">"csvtojson"</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walkSync</span>(<span class="params">currentDirPath, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>),</span><br><span class="line">    path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line">  fs.readdirSync(currentDirPath, &#123; <span class="attr">withFileTypes</span>: <span class="literal">true</span> &#125;).forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    dirent</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> filePath = path.join(currentDirPath, dirent.name);</span><br><span class="line">    <span class="keyword">if</span> (dirent.isFile()) &#123;</span><br><span class="line">      callback(filePath, dirent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirent.isDirectory()) &#123;</span><br><span class="line">      walkSync(filePath, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileArr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> csvFileArr = [];</span><br><span class="line">    walkSync(<span class="string">"./i18n"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// if(filePath.test(/+\.csv$/))&#123;</span></span><br><span class="line">      <span class="keyword">if</span> (filePath.includes(<span class="string">".csv"</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> file = <span class="string">`./<span class="subst">$&#123;filePath&#125;</span>`</span>.replace(<span class="regexp">/\\/g</span>, <span class="string">"/"</span>);</span><br><span class="line">        csvFileArr.push(file);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> csvFileArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csvTojson</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  csv(&#123;</span><br><span class="line">    noheader: <span class="literal">true</span>,</span><br><span class="line">    output: <span class="string">"csv"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">    .fromFile(<span class="string">`<span class="subst">$&#123;fileName&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">jsonArr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> jsonObj = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; jsonArr.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = jsonArr[index];</span><br><span class="line">        jsonObj[item[<span class="number">0</span>]] = item[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      jsonObj = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br><span class="line">      <span class="keyword">let</span> outFile = fileName.match(<span class="regexp">/(\w+)\.csv$/</span>)[<span class="number">1</span>];</span><br><span class="line">      fs.writeFile(</span><br><span class="line">        <span class="string">`./output/<span class="subst">$&#123;outFile&#125;</span>.json`</span>,</span><br><span class="line">        jsonObj,</span><br><span class="line">        <span class="string">"utf-8"</span>,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"The file was saved!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileArr = getFileArr();</span><br><span class="line">fileArr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  csvTojson(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;市面上有很多现在的网站，可以实现csv转为需要的格式，但因为项目的csv格式比较特殊，需要手动实现自定义。&lt;/p&gt;
&lt;p&gt;主要通过三方的 &lt;code&gt;csvtojson&lt;/code&gt; npm 包实现。记录过程，方便自定义更多格式。&lt;br&gt;
    
    </summary>
    
    
      <category term="csv" scheme="https://luckyp.top/tags/csv/"/>
    
      <category term="json" scheme="https://luckyp.top/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>前端SEO</title>
    <link href="https://luckyp.top/%E5%89%8D%E7%AB%AFSEO/"/>
    <id>https://luckyp.top/前端SEO/</id>
    <published>2022-12-03T16:00:00.000Z</published>
    <updated>2022-12-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端流行框架如Vue、React大多采用单页面形式，针对SEO会有那些问题？<br><a id="more"></a></p><h2 id="爬虫存在的问题"><a href="#爬虫存在的问题" class="headerlink" title="爬虫存在的问题"></a>爬虫存在的问题</h2><ul><li>不渲染JavaScript – 这是一个较老的议题了，但<a href="https://searchengineland.com/google-now-crawling-and-indexing-flash-content-14299" target="_blank" rel="noopener">谷歌在 2008 年才开始以有限的方式渲染 JavaScript</a>。然而，它仍然依赖于 2009 年创建的 JavaScript 网站的抓取方式。（谷歌已经弃用了该方式。）</li><li>渲染引擎 (Chromium) 已过时 – 这导致<a href="https://www.deepcrawl.com/blog/news/what-version-of-chrome-is-google-actually-using-for-rendering/" target="_blank" rel="noopener">缺乏对最新浏览器和 JavaScript 的功能支持</a>，如果使用了 Googlebot 不支持的 JavaScript 功能，页面可能无法正确呈现，这可能会对你的内容索引产生负面影响。</li><li>Google 出现渲染延迟 – 在某些情况下，这可能<a href="https://twitter.com/Paul_Kinlan/status/1040147543345098752" target="_blank" rel="noopener">意味着最多会延迟数周</a>，从而减慢内容更改后达到索引阶段的时间，这可能会排除那些大多数需要依靠谷歌渲染内容的网站。</li></ul><p>目前Google的<a href="https://developers.google.com/search/blog/2019/05/the-new-evergreen-googlebot" target="_blank" rel="noopener">长青状态的爬虫</a>以支持动态解决JavaScript，渲染时间大概为5s。但是相对来说，必应、百度等其它爬虫依旧会有这个问题。</p><p><em>以下技术方案以vue举例</em>.</p><h2 id="单页面存在的问题"><a href="#单页面存在的问题" class="headerlink" title="单页面存在的问题"></a>单页面存在的问题</h2><p>单页面应用的页面一般为单页面public/index.html，内容为下面结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We're sorry but <span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span> doesn't work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过JavaScript解析动态渲染为需要展示的页面</p><ol><li>爬虫不会解析JavaScript，页面节点爬取简单</li><li>不能单独设置TDK（title、description、description）</li><li>客户端渲染，首屏加载相对服务端慢，但是对服务端压力小</li></ol><h2 id="相对需求"><a href="#相对需求" class="headerlink" title="相对需求"></a>相对需求</h2><ol><li>多页面，可以实现根据不同页面实现不同的节点，便于爬取</li><li>可设置动态TDK</li></ol><h2 id="解决方案-SSR"><a href="#解决方案-SSR" class="headerlink" title="解决方案-SSR"></a>解决方案-SSR</h2><p>针对vue、react等技术，社区提供了成熟的实现方案<br>方案</p><ul><li>Vue技术栈 — nuxtjs</li><li>React技术栈 — nextjs</li></ul><h3 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h3><ol><li>用户通过浏览器预览页面，浏览器请求node服务</li><li>node服务上，nuxtjs通过asyncData、fetch等方法异步请求后端服务数据，预渲染页面，返回附带html的页面到浏览器</li><li>浏览器交互时，执行vue的如: Create、mounted、destroy等生命周期。</li><li>每个page/页面.vue可以根据head单独设置不同的TDK，可以动态设置渲染</li></ol><h3 id="要求限制"><a href="#要求限制" class="headerlink" title="要求限制"></a>要求限制</h3><ul><li>开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。</li><li>更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。</li><li>更高的服务端负载。在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。</li><li>node环境</li><li>vue版本</li></ul><h2 id="解决方案-预渲染"><a href="#解决方案-预渲染" class="headerlink" title="解决方案-预渲染"></a>解决方案-预渲染</h2><p>针对多页面通过prerender-spa-plugin库实现。使用详情参见<br>针对TDK可以通过vue-meta库实现。使用详情参见<br>应用场景</p><ul><li>为数不多页面的seo，例如关于我们、联系我们之类的</li><li>seo要求不高</li></ul><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li>在本地router.js文件中配置好的路由，可以进行单独的页面预渲染，不能是动态路由，每添加一个预渲染页面就需要手动在配置项新增一个</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">plugins</span>: [</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  <span class="comment">// Required - The path to the webpack-outputted app to prerender.</span></span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  <span class="comment">// Required - Routes to render.</span></span><br><span class="line">  routes: [ <span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/some/deep/nested/route'</span> ],&#125;)</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><ul><li>可以通过vue-meta实现每个页面的TDK，但不能为动态渲染，业务场景如商品详情页中，该页面的title应该为请求接口后拿到的商品名，此时不能实现。</li></ul><h2 id="解决方案-无头浏览器爬取"><a href="#解决方案-无头浏览器爬取" class="headerlink" title="解决方案-无头浏览器爬取"></a>解决方案-无头浏览器爬取</h2><p>本着爬虫不能解析JavaScript的原则，如果实现页面的解析爬取并返回给爬虫，就能做到针对原有项目最小改动（甚至无改动）的情况下，实现对seo需求的实现。<br>chrome爬虫本身可以解析JavaScript，所以提供了一套解决方案puppeteer.js。<br>puppeteer为chromium官方binding，其他语言也有类似binding，例如go和rust。</p><h3 id="大概功能"><a href="#大概功能" class="headerlink" title="大概功能"></a>大概功能</h3><ul><li><a href="https://developer.chrome.com/docs/puppeteer/ssr/#introduction" target="_blank" rel="noopener">官方文档使用详情参见</a></li><li><a href="https://zhuanlan.zhihu.com/p/76237595" target="_blank" rel="noopener">可实现的大概功能</a></li><li>网页截图或者生成 PDF</li><li>爬取 SPA 或 SSR 网站</li><li>UI 自动化测试，模拟表单提交，键盘输入，点击等行为</li><li>捕获网站的时间线，帮助诊断性能问题</li><li>创建一个最新的自动化测试环境，使用最新的 js 和最新的 Chrome 浏览器运行测试用例</li><li>测试 Chrome 扩展程序</li><li>…</li></ul><h3 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h3><p><a href="../images/express.zip">express.zip</a>.</p><h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li>node环境</li><li>单页面资源依靠相对路径，爬取资源失败</li><li>爬取失败存在程序奔溃，持久化处理问题</li></ul><h2 id="解决方案-静态化"><a href="#解决方案-静态化" class="headerlink" title="解决方案-静态化"></a>解决方案-静态化</h2><p>nuxtjs可以实现静态化打包，不同于单页面的CSG的方案，也就是SCG方案。</p><ol><li>克隆 nuxtjs.org repository</li><li>使用 npm install 命令安装依赖</li><li>运行 npm run generate</li><li>生成 dist 目录<br>Nuxt3可以实现混合渲染，针对不同的路由设置不同的渲染。</li></ol><h3 id="多页面应用的可行性"><a href="#多页面应用的可行性" class="headerlink" title="多页面应用的可行性"></a>多页面应用的可行性</h3><p>vue-cli可以配置设置为多页面应用</p><ul><li>同单页面一样，设置为多页面依旧是单一节点html</li><li>可以为不同页面设置静态化TDK，固定不可变更</li><li>seo问题依旧存在</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端流行框架如Vue、React大多采用单页面形式，针对SEO会有那些问题？&lt;br&gt;
    
    </summary>
    
    
      <category term="SEO" scheme="https://luckyp.top/tags/SEO/"/>
    
      <category term="Vue" scheme="https://luckyp.top/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>数据类型检测</title>
    <link href="https://luckyp.top/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    <id>https://luckyp.top/数据类型检测/</id>
    <published>2022-06-19T03:37:08.000Z</published>
    <updated>2022-06-19T03:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>常见的类型检测的分为以下几种，优缺点各不相同。<br><a id="more"></a></p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'str'</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure><p>typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure><p>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；<br>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们也可以试着实现一下 instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 由于instance要检测的是某对象，需要有一个前置判断条件</span></span><br><span class="line">  <span class="comment">//基本数据类型直接返回false</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">'object'</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得类型的原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  <span class="comment">// 获得对象的原型</span></span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof(<span class="literal">null</span>, <span class="built_in">Array</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof([], <span class="built_in">Array</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof(<span class="string">''</span>, <span class="built_in">Array</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test'</span>, _instanceof(&#123;&#125;, <span class="built_in">Object</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">'str'</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果创建一个对象，更改它的原型，constructor就会变得不可靠了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><p>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(&#123;&#125;)       <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)    <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'1'</span>)  <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)  <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)   <span class="comment">//"[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">//"[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/123/g</span>)    <span class="comment">//"[object RegExp]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//"[object Date]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])       <span class="comment">//"[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>)  <span class="comment">//"[object HTMLDocument]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>)   <span class="comment">//"[object Window]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf1</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type  = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).replace(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">'$1'</span>);  <span class="comment">// 注意正则中间有个空格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>typeof<ul><li>直接在计算机底层基于数据类型的值（二进制）进行检测</li><li>typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象</li><li>typeof 普通对象/数组对象/正则对象/日期对象 都是object</li><li>typeof NaN === ‘number’</li></ul></li><li>instanceof<ul><li>检测当前实例是否属于这个类的</li><li>底层机制：只要当前类出现在实例的原型上，结果都是true</li><li>不能检测基本数据类型</li></ul></li><li>constructor<ul><li>支持基本类型</li><li>constructor可以随便改，也不准</li></ul></li><li>Object.prototype.toString.call([val])<ul><li>返回当前实例所属类信息</li></ul></li></ul><p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p><ul><li>基本类型(null): 使用 String(null)</li><li>基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可</li><li>其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的类型检测的分为以下几种，优缺点各不相同。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://luckyp.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>原生js手写</title>
    <link href="https://luckyp.top/%E5%8E%9F%E7%94%9Fjs%E6%89%8B%E5%86%99/"/>
    <id>https://luckyp.top/原生js手写/</id>
    <published>2022-04-22T14:53:44.000Z</published>
    <updated>2022-04-22T14:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过基础的代码，实现原生<code>js</code>的一些方法。更有利于对<code>JavaScript</code>加深理解。<br><a id="more"></a></p><p>部分内容具体实现可参考冴羽的<a href="https://github.com/mqyqingfeng/Blog#%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97" target="_blank" rel="noopener">深入系列</a>。</p><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似的还有indexOf，includes，some等等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">var</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6，参数为处理几层，默认1</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.flat(infinity)</span><br></pre></td></tr></table></figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它不会拷贝对象的继承属性；</span></span><br><span class="line"><span class="comment">// 它不会拷贝对象的不可枚举的属性；</span></span><br><span class="line"><span class="comment">// 可以拷贝 Symbol 类型的属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象扩展符，和上面的类似</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat 拷贝数组</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 拷贝数组</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动实现</span></span><br><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">          cloneTarget[prop] = target[prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单版，忽略undefund，symbol，无法转换正则日期等对象，不能循环引用对象</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(Obj))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写版</span></span><br><span class="line"><span class="keyword">const</span> isComplexDataType = <span class="function"><span class="params">obj</span> =&gt;</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; (obj !== <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="keyword">function</span> (<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.constructor === <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)       <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (obj.constructor === <span class="built_in">RegExp</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)     <span class="comment">//正则对象直接返回一个新的正则对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果循环引用了就用 weakMap 来解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.get(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDesc)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把cloneObj原型复制到obj上</span></span><br><span class="line">  hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123; </span><br><span class="line">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">'function'</span>) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>同观察者模式区别在于，没有中间消息处理中心，可参考<a href="https://juejin.cn/post/7055441354054172709" target="_blank" rel="noopener">观察者模式 vs 发布订阅模式</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    on(name, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cache[name].push(fn)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cache[name] = [fn]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off(name, fn) &#123;</span><br><span class="line">        <span class="keyword">let</span> tasks = <span class="keyword">this</span>.cache[name]</span><br><span class="line">        <span class="keyword">if</span> (tasks) &#123;</span><br><span class="line">            <span class="keyword">const</span> index = tasks.findIndex(<span class="function"><span class="params">f</span> =&gt;</span> f === fn || f.callback === fn)</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                tasks.splice(index, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emit(name, once = <span class="literal">false</span>, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cache[name]) &#123;</span><br><span class="line">            <span class="comment">// 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span></span><br><span class="line">            <span class="keyword">let</span> tasks = <span class="keyword">this</span>.cache[name].slice()</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">                fn(...args)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (once) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>.cache[name]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span>; <span class="comment">// 模板字符串正则</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(template)) &#123; <span class="comment">// 判断模板里是否有模板字符串</span></span><br><span class="line">        <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>]; <span class="comment">// 查找当前模板里第一个模板字符串的字段</span></span><br><span class="line">        template = template.replace(reg, data[name]); <span class="comment">// 将第一个模板字符串渲染</span></span><br><span class="line">        <span class="keyword">return</span> render(template, data); <span class="comment">// 递归的渲染并返回渲染后的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> template; <span class="comment">// 如果模板没有模板字符串直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> judge = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == fn.length) <span class="keyword">return</span> fn(...args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        args[index] = </span><br><span class="line">        <span class="keyword">return</span> fn(...args, ...arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> generateUrl = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dataSrc = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.hasOwnProperty(key)) &#123;</span><br><span class="line">                dataSrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dataSrc += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataSrc&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">        scriptEle.src = generateUrl()</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle)</span><br><span class="line">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">            <span class="built_in">document</span>.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">'Mscrosoft.XMLHttp'</span>);</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url, <span class="literal">false</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.responseText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h2><p>利用obj.fn的this指向obj。可参考<a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a>相关内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 处理new时</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存在值为对象的情况应返回对象，否则返回生成的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret || obj : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === right.prototype) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create2 = <span class="function"><span class="keyword">function</span>(<span class="params">proto, propertyObject = undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object prototype may only be an Object or null.'</span>)</span><br><span class="line">    <span class="keyword">if</span> (propertyObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot convert undefined or null to object'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = proto</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> F()</span><br><span class="line">    <span class="keyword">if</span> (propertyObject != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(obj, propertyObject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个没有原型对象的对象，Object.create(null)</span></span><br><span class="line">        obj.__proto__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign2 = <span class="function"><span class="keyword">function</span>(<span class="params">target, ...source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot convert undefined or null to object'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="built_in">Object</span>(target) </span><br><span class="line">    source.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                    ret[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><a href="https://juejin.cn/post/6945319439772434469" target="_blank" rel="noopener">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a><br><a href="https://juejin.cn/post/6844904077537574919" target="_blank" rel="noopener">要就来45道Promise面试题一次爽到底</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过基础的代码，实现原生&lt;code&gt;js&lt;/code&gt;的一些方法。更有利于对&lt;code&gt;JavaScript&lt;/code&gt;加深理解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器的回流与重绘</title>
    <link href="https://luckyp.top/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
    <id>https://luckyp.top/浏览器的回流与重绘/</id>
    <published>2022-01-04T02:13:37.000Z</published>
    <updated>2022-01-04T02:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>回流：也被称为重排，或者布局阶段<br>重绘：绘制阶段<br><a id="more"></a></p><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。</p><p><img src="/images/draw_1.png" alt="draw"></p><p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。</li></ul><p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p><h3 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h3><p><img src="/images/draw_2.png" alt="draw"></p><p>为了构建渲染树，浏览器主要完成了以下工作：</p><ol><li>从DOM树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p><ul><li>一些不会渲染输出的节点，比如script、meta、link等。</li><li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li></ul><p>从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。<br><strong>注意：渲染树只包含可见的节点</strong></p><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。<br>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p><h2 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong><br>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><h2 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect</li><li>具体可以访问这个网站：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a" target="_blank" rel="noopener">https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a</a></li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p><h2 id="减少回流和重绘"><a href="#减少回流和重绘" class="headerlink" title="减少回流和重绘"></a>减少回流和重绘</h2><p>前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p><h3 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h3><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line">el.style.padding = <span class="string">'5px'</span>;</span><br><span class="line">el.style.borderLeft = <span class="string">'1px'</span>;</span><br><span class="line">el.style.borderRight = <span class="string">'2px'</span>;</span><br></pre></td></tr></table></figure><p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p><p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p><h4 id="使用cssText"><a href="#使用cssText" class="headerlink" title="使用cssText"></a>使用cssText</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line">el.style.cssText += <span class="string">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br></pre></td></tr></table></figure><h4 id="修改CSS的class"><a href="#修改CSS的class" class="headerlink" title="修改CSS的class"></a>修改CSS的class</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line">el.className += <span class="string">' active'</span>;</span><br></pre></td></tr></table></figure><h3 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p><ol><li>使元素脱离文档流</li><li>对其进行多次修改</li><li>将元素带回到文档中。</li></ol><p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。<br>有三种方式可以让DOM脱离文档流：</p><ul><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li><li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li></ul><p>考虑我们要执行一段批量插入节点的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">appendToElement, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">     li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.textContent = <span class="string">'text'</span>;</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure><p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p><p>我们可以使用这三种方式进行优化:</p><h4 id="隐藏元素，应用修改，重新显示"><a href="#隐藏元素，应用修改，重新显示" class="headerlink" title="隐藏元素，应用修改，重新显示"></a>隐藏元素，应用修改，重新显示</h4><p>这个会在展示和隐藏节点的时候，产生两次回流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendDataToElement</span>(<span class="params">appendToElement, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> li;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">     li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.textContent = <span class="string">'text'</span>;</span><br><span class="line">        appendToElement.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">ul.style.display = <span class="string">'none'</span>;</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = <span class="string">'block'</span>;</span><br></pre></td></tr></table></figure><h4 id="使用文档片段-document-fragment-在当前DOM之外构建一个子树，再把它拷贝回文档"><a href="#使用文档片段-document-fragment-在当前DOM之外构建一个子树，再把它拷贝回文档" class="headerlink" title="使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档"></a>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure><h4 id="将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素"><a href="#将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素" class="headerlink" title="将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素"></a>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">const</span> clone = ul.cloneNode(<span class="literal">true</span>);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure><p>对于上面这三种情况，我写了一个demo在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。</p><p>原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</p><h3 id="避免触发同步布局事件"><a href="#避免触发同步布局事件" class="headerlink" title="避免触发同步布局事件"></a>避免触发同步布局事件</h3><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">        paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = box.offsetWidth;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class="line">        paragraphs[i].style.width = width + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于复杂动画效果-使用绝对定位让其脱离文档流"><a href="#对于复杂动画效果-使用绝对定位让其脱离文档流" class="headerlink" title="对于复杂动画效果,使用绝对定位让其脱离文档流"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。</p><h3 id="css3硬件加速（GPU加速）"><a href="#css3硬件加速（GPU加速）" class="headerlink" title="css3硬件加速（GPU加速）"></a>css3硬件加速（GPU加速）</h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！<br>划重点：</p><ol><li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。</li><li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li></ol><p>常见的触发硬件加速的css属性：</p><ul><li>transform</li><li>opacity</li><li>filters</li><li>Will-change</li></ul><p>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘<br>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p><p>css3硬件加速的坑<br>当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:</p><p>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。<br>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p><p>转载链接：<a href="https://juejin.cn/post/6844903779700047885" target="_blank" rel="noopener">https://juejin.cn/post/6844903779700047885</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回流：也被称为重排，或者布局阶段&lt;br&gt;重绘：绘制阶段&lt;br&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://luckyp.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>线上调试vue-devtools</title>
    <link href="https://luckyp.top/%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95vue-devtools/"/>
    <id>https://luckyp.top/线上调试vue-devtools/</id>
    <published>2021-11-22T14:29:07.000Z</published>
    <updated>2021-11-22T14:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>调试线上vue项目，在某些特殊情况下使用。<br><a id="more"></a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>按F12找到<code>Source</code>选项卡，找到app.js文件，点击下方<code>{}</code>格式化文件</li><li><code>ctrl + f</code>搜索<code>$mount</code>,在<code>new</code>处打断点，<code>new</code>后面的对象是Vue对象，记住该变量名，例如：<code>d[&quot;default&quot;]</code></li><li>F5刷新页面，此时进入断点，在控制台输入指令<code>d[&quot;default&quot;].config.devtools = true</code></li><li>结束断点，关闭控制台，重新打开即可看到<code>vue-devtools</code>选项卡</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;调试线上vue项目，在某些特殊情况下使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="vue" scheme="https://luckyp.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>提问的艺术</title>
    <link href="https://luckyp.top/%E6%8F%90%E9%97%AE%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://luckyp.top/提问的艺术/</id>
    <published>2021-09-03T10:52:26.000Z</published>
    <updated>2021-09-03T10:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何处理难以解决问题。</p><a id="more"></a><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/images/ask_question1.png" alt="question"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何处理难以解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="https://luckyp.top/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>图片格式转换</title>
    <link href="https://luckyp.top/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>https://luckyp.top/图片格式转换/</id>
    <published>2021-06-13T14:14:46.000Z</published>
    <updated>2021-06-13T14:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>图片canvas，file，blob，DataURL等格式转换。</p><a id="more"></a><h2 id="file转base64"><a href="#file转base64" class="headerlink" title="file转base64"></a>file转base64</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>base<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 方法一：利用URL.createObjectURL() ==&gt;  blob:null/xxxxxx</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> $img = <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">        file.onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.target.files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> fileUrl = <span class="built_in">window</span>.URL.createObjectURL(file)</span></span><br><span class="line">            $img.src = fileUrl</span><br><span class="line"><span class="javascript">            img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 手动回收</span></span></span><br><span class="line">                URL.revokeObjectURL(fileUrl)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 利用FileReader.readAsDataURL() ==&gt; data:image/jpeg;base64,xxxxxx</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> $img = <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">        file.onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.target.files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader(file)</span></span><br><span class="line">            fr.readAsDataURL(file)</span><br><span class="line"><span class="javascript">            fr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                 $img.src = <span class="keyword">this</span>.result</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="canvas转DataURL"><a href="#canvas转DataURL" class="headerlink" title="canvas转DataURL"></a>canvas转DataURL</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toBlob(callback, type, quality)</span></span><br><span class="line"><span class="comment">// callback</span></span><br><span class="line"><span class="comment">// 回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值。</span></span><br><span class="line"><span class="comment">// type 可选</span></span><br><span class="line"><span class="comment">// DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png。</span></span><br><span class="line"><span class="comment">// quality 可选</span></span><br><span class="line"><span class="comment">// Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。</span></span><br><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span>(<span class="params">blob</span>)</span>&#123;...&#125;, <span class="string">"image/jpeg"</span>, <span class="number">0.95</span>); <span class="comment">// JPEG at 95%</span></span><br></pre></td></tr></table></figure><h2 id="Blob对象显示图片"><a href="#Blob对象显示图片" class="headerlink" title="Blob对象显示图片"></a>Blob对象显示图片</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span> (<span class="params">blobObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> imgSrc = <span class="built_in">window</span>.URL.createObjectURL(blobObj)</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>).src = imgSrc</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="下载DataURL表示的图片"><a href="#下载DataURL表示的图片" class="headerlink" title="下载DataURL表示的图片"></a>下载DataURL表示的图片</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadImg</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aLink = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">    aLink.download = <span class="string">'fileName.png'</span> <span class="comment">// 文件名后缀需要和dataurl表示的相同，否则可能乱码</span></span><br><span class="line">    aLink.href = dataUrl</span><br><span class="line">    aLink.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图片canvas，file，blob，DataURL等格式转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://luckyp.top/tags/js/"/>
    
      <category term="Image" scheme="https://luckyp.top/tags/Image/"/>
    
      <category term="Canvas" scheme="https://luckyp.top/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>z-index层级点击问题</title>
    <link href="https://luckyp.top/z-index%E5%B1%82%E7%BA%A7%E7%82%B9%E5%87%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://luckyp.top/z-index层级点击问题/</id>
    <published>2021-03-21T14:42:58.000Z</published>
    <updated>2021-03-21T14:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>两个弹出层，第一个层级高于第二个层级，想触发第二个层级的点击事件<br><a id="more"></a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对上层元素使用以下属性，可穿透点击层</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-events: none;</span><br></pre></td></tr></table></figure><p>如果想让上层元素的子元素部分可点击，在可点击的元素上添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-events: auto;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个弹出层，第一个层级高于第二个层级，想触发第二个层级的点击事件&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://luckyp.top/tags/css/"/>
    
  </entry>
  
</feed>
