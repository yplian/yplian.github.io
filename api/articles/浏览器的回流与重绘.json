{"title":"浏览器的回流与重绘","slug":"浏览器的回流与重绘","date":"2022-01-04T02:13:37.000Z","updated":"2022-01-04T02:13:37.000Z","comments":true,"path":"api/articles/浏览器的回流与重绘.json","excerpt":"回流：也被称为重排，或者布局阶段<br>重绘：绘制阶段<br>","covers":["/images/draw_1.png","/images/draw_2.png"],"content":"<p>回流：也被称为重排，或者布局阶段<br>重绘：绘制阶段<br><a id=\"more\"></a></p>\n<h2 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h2><p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。</p>\n<p><img src=\"/images/draw_1.png\" alt=\"draw\"></p>\n<p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p>\n<ul>\n<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>\n<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>\n<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>\n<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>\n<li>Display:将像素发送给GPU，展示在页面上。</li>\n</ul>\n<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>\n<h3 id=\"生成渲染树\"><a href=\"#生成渲染树\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树</h3><p><img src=\"/images/draw_2.png\" alt=\"draw\"></p>\n<p>为了构建渲染树，浏览器主要完成了以下工作：</p>\n<ol>\n<li>从DOM树的根节点开始遍历每个可见节点。</li>\n<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>\n<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>\n</ol>\n<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>\n<ul>\n<li>一些不会渲染输出的节点，比如script、meta、link等。</li>\n<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>\n</ul>\n<p>从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。<br><strong>注意：渲染树只包含可见的节点</strong></p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。<br>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p>\n<h2 id=\"何时发生回流重绘\"><a href=\"#何时发生回流重绘\" class=\"headerlink\" title=\"何时发生回流重绘\"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p>\n<ul>\n<li>添加或删除可见的DOM元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>\n<li>页面一开始渲染的时候（这肯定避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong><br>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>\n<h2 id=\"浏览器的优化机制\"><a href=\"#浏览器的优化机制\" class=\"headerlink\" title=\"浏览器的优化机制\"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：</p>\n<ul>\n<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>\n<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect</li>\n<li>具体可以访问这个网站：<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a\" target=\"_blank\" rel=\"noopener\">https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a</a></li>\n</ul>\n<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>\n<h2 id=\"减少回流和重绘\"><a href=\"#减少回流和重绘\" class=\"headerlink\" title=\"减少回流和重绘\"></a>减少回流和重绘</h2><p>前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p>\n<h3 id=\"最小化重绘和重排\"><a href=\"#最小化重绘和重排\" class=\"headerlink\" title=\"最小化重绘和重排\"></a>最小化重绘和重排</h3><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">el.style.padding = <span class=\"string\">'5px'</span>;</span><br><span class=\"line\">el.style.borderLeft = <span class=\"string\">'1px'</span>;</span><br><span class=\"line\">el.style.borderRight = <span class=\"string\">'2px'</span>;</span><br></pre></td></tr></table></figure>\n<p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p>\n<p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p>\n<h4 id=\"使用cssText\"><a href=\"#使用cssText\" class=\"headerlink\" title=\"使用cssText\"></a>使用cssText</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">el.style.cssText += <span class=\"string\">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改CSS的class\"><a href=\"#修改CSS的class\" class=\"headerlink\" title=\"修改CSS的class\"></a>修改CSS的class</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">el.className += <span class=\"string\">' active'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p>\n<ol>\n<li>使元素脱离文档流</li>\n<li>对其进行多次修改</li>\n<li>将元素带回到文档中。</li>\n</ol>\n<p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。<br>有三种方式可以让DOM脱离文档流：</p>\n<ul>\n<li>隐藏元素，应用修改，重新显示</li>\n<li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>\n</ul>\n<p>考虑我们要执行一段批量插入节点的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendDataToElement</span>(<span class=\"params\">appendToElement, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> li;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">     li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">        li.textContent = <span class=\"string\">'text'</span>;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>\n<p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p>\n<p>我们可以使用这三种方式进行优化:</p>\n<h4 id=\"隐藏元素，应用修改，重新显示\"><a href=\"#隐藏元素，应用修改，重新显示\" class=\"headerlink\" title=\"隐藏元素，应用修改，重新显示\"></a>隐藏元素，应用修改，重新显示</h4><p>这个会在展示和隐藏节点的时候，产生两次回流</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendDataToElement</span>(<span class=\"params\">appendToElement, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> li;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">     li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">        li.textContent = <span class=\"string\">'text'</span>;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'block'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用文档片段-document-fragment-在当前DOM之外构建一个子树，再把它拷贝回文档\"><a href=\"#使用文档片段-document-fragment-在当前DOM之外构建一个子树，再把它拷贝回文档\" class=\"headerlink\" title=\"使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档\"></a>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素\"><a href=\"#将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素\" class=\"headerlink\" title=\"将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素\"></a>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = ul.cloneNode(<span class=\"literal\">true</span>);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure>\n<p>对于上面这三种情况，我写了一个demo在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。</p>\n<p>原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</p>\n<h3 id=\"避免触发同步布局事件\"><a href=\"#避免触发同步布局事件\" class=\"headerlink\" title=\"避免触发同步布局事件\"></a>避免触发同步布局事件</h3><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initP</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = box.offsetWidth + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> width = box.offsetWidth;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initP</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = width + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对于复杂动画效果-使用绝对定位让其脱离文档流\"><a href=\"#对于复杂动画效果-使用绝对定位让其脱离文档流\" class=\"headerlink\" title=\"对于复杂动画效果,使用绝对定位让其脱离文档流\"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。</p>\n<h3 id=\"css3硬件加速（GPU加速）\"><a href=\"#css3硬件加速（GPU加速）\" class=\"headerlink\" title=\"css3硬件加速（GPU加速）\"></a>css3硬件加速（GPU加速）</h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！<br>划重点：</p>\n<ol>\n<li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。</li>\n<li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li>\n</ol>\n<p>常见的触发硬件加速的css属性：</p>\n<ul>\n<li>transform</li>\n<li>opacity</li>\n<li>filters</li>\n<li>Will-change</li>\n</ul>\n<p>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘<br>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>\n<p>css3硬件加速的坑<br>当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:</p>\n<p>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。<br>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p>\n<p>转载链接：<a href=\"https://juejin.cn/post/6844903779700047885\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903779700047885</a></p>\n","more":"</p>\n<h2 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h2><p>本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。</p>\n<p><img src=\"/images/draw_1.png\" alt=\"draw\"></p>\n<p>从上面这个图上，我们可以看到，浏览器渲染过程如下：</p>\n<ul>\n<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>\n<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>\n<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>\n<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>\n<li>Display:将像素发送给GPU，展示在页面上。</li>\n</ul>\n<p>渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。</p>\n<h3 id=\"生成渲染树\"><a href=\"#生成渲染树\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树</h3><p><img src=\"/images/draw_2.png\" alt=\"draw\"></p>\n<p>为了构建渲染树，浏览器主要完成了以下工作：</p>\n<ol>\n<li>从DOM树的根节点开始遍历每个可见节点。</li>\n<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>\n<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>\n</ol>\n<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>\n<ul>\n<li>一些不会渲染输出的节点，比如script、meta、link等。</li>\n<li>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>\n</ul>\n<p>从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。<br><strong>注意：渲染树只包含可见的节点</strong></p>\n<h3 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。</p>\n<h3 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。<br>既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。</p>\n<h2 id=\"何时发生回流重绘\"><a href=\"#何时发生回流重绘\" class=\"headerlink\" title=\"何时发生回流重绘\"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：</p>\n<ul>\n<li>添加或删除可见的DOM元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>\n<li>页面一开始渲染的时候（这肯定避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong><br>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>\n<h2 id=\"浏览器的优化机制\"><a href=\"#浏览器的优化机制\" class=\"headerlink\" title=\"浏览器的优化机制\"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：</p>\n<ul>\n<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>\n<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>\n<li>clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>getComputedStyle()</li>\n<li>getBoundingClientRect</li>\n<li>具体可以访问这个网站：<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a\" target=\"_blank\" rel=\"noopener\">https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a</a></li>\n</ul>\n<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>\n<h2 id=\"减少回流和重绘\"><a href=\"#减少回流和重绘\" class=\"headerlink\" title=\"减少回流和重绘\"></a>减少回流和重绘</h2><p>前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。</p>\n<h3 id=\"最小化重绘和重排\"><a href=\"#最小化重绘和重排\" class=\"headerlink\" title=\"最小化重绘和重排\"></a>最小化重绘和重排</h3><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">el.style.padding = <span class=\"string\">'5px'</span>;</span><br><span class=\"line\">el.style.borderLeft = <span class=\"string\">'1px'</span>;</span><br><span class=\"line\">el.style.borderRight = <span class=\"string\">'2px'</span>;</span><br></pre></td></tr></table></figure>\n<p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。</p>\n<p>因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p>\n<h4 id=\"使用cssText\"><a href=\"#使用cssText\" class=\"headerlink\" title=\"使用cssText\"></a>使用cssText</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">el.style.cssText += <span class=\"string\">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改CSS的class\"><a href=\"#修改CSS的class\" class=\"headerlink\" title=\"修改CSS的class\"></a>修改CSS的class</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">el.className += <span class=\"string\">' active'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h3><p>当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p>\n<ol>\n<li>使元素脱离文档流</li>\n<li>对其进行多次修改</li>\n<li>将元素带回到文档中。</li>\n</ol>\n<p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。<br>有三种方式可以让DOM脱离文档流：</p>\n<ul>\n<li>隐藏元素，应用修改，重新显示</li>\n<li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li>\n<li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li>\n</ul>\n<p>考虑我们要执行一段批量插入节点的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendDataToElement</span>(<span class=\"params\">appendToElement, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> li;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">     li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">        li.textContent = <span class=\"string\">'text'</span>;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>\n<p>如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。</p>\n<p>我们可以使用这三种方式进行优化:</p>\n<h4 id=\"隐藏元素，应用修改，重新显示\"><a href=\"#隐藏元素，应用修改，重新显示\" class=\"headerlink\" title=\"隐藏元素，应用修改，重新显示\"></a>隐藏元素，应用修改，重新显示</h4><p>这个会在展示和隐藏节点的时候，产生两次回流</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendDataToElement</span>(<span class=\"params\">appendToElement, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> li;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">     li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">        li.textContent = <span class=\"string\">'text'</span>;</span><br><span class=\"line\">        appendToElement.appendChild(li);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'block'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用文档片段-document-fragment-在当前DOM之外构建一个子树，再把它拷贝回文档\"><a href=\"#使用文档片段-document-fragment-在当前DOM之外构建一个子树，再把它拷贝回文档\" class=\"headerlink\" title=\"使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档\"></a>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素\"><a href=\"#将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素\" class=\"headerlink\" title=\"将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素\"></a>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'list'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> clone = ul.cloneNode(<span class=\"literal\">true</span>);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">ul.parentNode.replaceChild(clone, ul);</span><br></pre></td></tr></table></figure>\n<p>对于上面这三种情况，我写了一个demo在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。</p>\n<p>原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。</p>\n<h3 id=\"避免触发同步布局事件\"><a href=\"#避免触发同步布局事件\" class=\"headerlink\" title=\"避免触发同步布局事件\"></a>避免触发同步布局事件</h3><p>上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initP</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = box.offsetWidth + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> width = box.offsetWidth;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initP</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; paragraphs.length; i++) &#123;</span><br><span class=\"line\">        paragraphs[i].style.width = width + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对于复杂动画效果-使用绝对定位让其脱离文档流\"><a href=\"#对于复杂动画效果-使用绝对定位让其脱离文档流\" class=\"headerlink\" title=\"对于复杂动画效果,使用绝对定位让其脱离文档流\"></a>对于复杂动画效果,使用绝对定位让其脱离文档流</h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。</p>\n<h3 id=\"css3硬件加速（GPU加速）\"><a href=\"#css3硬件加速（GPU加速）\" class=\"headerlink\" title=\"css3硬件加速（GPU加速）\"></a>css3硬件加速（GPU加速）</h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！<br>划重点：</p>\n<ol>\n<li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。</li>\n<li>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</li>\n</ol>\n<p>常见的触发硬件加速的css属性：</p>\n<ul>\n<li>transform</li>\n<li>opacity</li>\n<li>filters</li>\n<li>Will-change</li>\n</ul>\n<p>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘<br>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p>\n<p>css3硬件加速的坑<br>当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:</p>\n<p>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。<br>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p>\n<p>转载链接：<a href=\"https://juejin.cn/post/6844903779700047885\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903779700047885</a></p>","categories":[],"tags":[{"name":"浏览器","path":"api/tags/浏览器.json"}]}