{"title":"数据类型检测","slug":"数据类型检测","date":"2022-06-19T03:37:08.000Z","updated":"2022-06-19T03:37:08.000Z","comments":true,"path":"api/articles/数据类型检测.json","excerpt":"常见的类型检测的分为以下几种，优缺点各不相同。<br>","covers":null,"content":"<p>常见的类型检测的分为以下几种，优缺点各不相同。<br><a id=\"more\"></a></p>\n<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"number\">2</span>);               <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>);            <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"string\">'str'</span>);           <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> []);              <span class=\"comment\">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);    <span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> &#123;&#125;);              <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>);       <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>);            <span class=\"comment\">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure>\n<p>typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</p>\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span>);                    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Boolean</span>);                <span class=\"comment\">// false </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'str'</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>);                <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);                    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>);       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;&#125; <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);                   <span class=\"comment\">// true    </span></span><br><span class=\"line\"><span class=\"comment\">// console.log(undefined instanceof Undefined);</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure>\n<p>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；<br>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们也可以试着实现一下 instanceof</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_instanceof</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 由于instance要检测的是某对象，需要有一个前置判断条件</span></span><br><span class=\"line\">  <span class=\"comment\">//基本数据类型直接返回false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> left !== <span class=\"string\">'object'</span> || left === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获得类型的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prototype = right.prototype</span><br><span class=\"line\">  <span class=\"comment\">// 获得对象的原型</span></span><br><span class=\"line\">  left = left.__proto__</span><br><span class=\"line\">  <span class=\"comment\">// 判断对象的类型是否等于类型的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left === <span class=\"literal\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prototype === left)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    left = left.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof(<span class=\"literal\">null</span>, <span class=\"built_in\">Array</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof([], <span class=\"built_in\">Array</span>)) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof(<span class=\"string\">''</span>, <span class=\"built_in\">Array</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof(&#123;&#125;, <span class=\"built_in\">Object</span>)) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"number\">2</span>).constructor === <span class=\"built_in\">Number</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"literal\">true</span>).constructor === <span class=\"built_in\">Boolean</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"string\">'str'</span>).constructor === <span class=\"built_in\">String</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(([]).constructor === <span class=\"built_in\">Array</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;).constructor === <span class=\"built_in\">Function</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((&#123;&#125;).constructor === <span class=\"built_in\">Object</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>如果创建一个对象，更改它的原型，constructor就会变得不可靠了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> f=<span class=\"keyword\">new</span> Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.constructor===Fn);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.constructor===<span class=\"built_in\">Array</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a>Object.prototype.toString.call()</h2><p>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString(&#123;&#125;)       <span class=\"comment\">// \"[object Object]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(&#123;&#125;)  <span class=\"comment\">// 同上结果，加上call也ok</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">1</span>)    <span class=\"comment\">// \"[object Number]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"string\">'1'</span>)  <span class=\"comment\">// \"[object String]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">true</span>)  <span class=\"comment\">// \"[object Boolean]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)  <span class=\"comment\">// \"[object Function]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">null</span>)   <span class=\"comment\">//\"[object Null]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">undefined</span>) <span class=\"comment\">//\"[object Undefined]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"regexp\">/123/g</span>)    <span class=\"comment\">//\"[object RegExp]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()) <span class=\"comment\">//\"[object Date]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([])       <span class=\"comment\">//\"[object Array]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">document</span>)  <span class=\"comment\">//\"[object HTMLDocument]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">window</span>)   <span class=\"comment\">//\"[object Window]\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typeOf1</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> type  = <span class=\"keyword\">typeof</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type !== <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj).replace(<span class=\"regexp\">/^\\[object (\\S+)\\]$/</span>, <span class=\"string\">'$1'</span>);  <span class=\"comment\">// 注意正则中间有个空格</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typeOf2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>).toLowerCase()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>typeof<ul>\n<li>直接在计算机底层基于数据类型的值（二进制）进行检测</li>\n<li>typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象</li>\n<li>typeof 普通对象/数组对象/正则对象/日期对象 都是object</li>\n<li>typeof NaN === ‘number’</li>\n</ul>\n</li>\n<li>instanceof<ul>\n<li>检测当前实例是否属于这个类的</li>\n<li>底层机制：只要当前类出现在实例的原型上，结果都是true</li>\n<li>不能检测基本数据类型</li>\n</ul>\n</li>\n<li>constructor<ul>\n<li>支持基本类型</li>\n<li>constructor可以随便改，也不准</li>\n</ul>\n</li>\n<li>Object.prototype.toString.call([val])<ul>\n<li>返回当前实例所属类信息</li>\n</ul>\n</li>\n</ul>\n<p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p>\n<ul>\n<li>基本类型(null): 使用 String(null)</li>\n<li>基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可</li>\n<li>其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断</li>\n</ul>\n","more":"</p>\n<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"number\">2</span>);               <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>);            <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"string\">'str'</span>);           <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> []);              <span class=\"comment\">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);    <span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> &#123;&#125;);              <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>);       <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>);            <span class=\"comment\">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure>\n<p>typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</p>\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span>);                    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Boolean</span>);                <span class=\"comment\">// false </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'str'</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">String</span>);                <span class=\"comment\">// false  </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([] <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);                    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>);       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(&#123;&#125; <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);                   <span class=\"comment\">// true    </span></span><br><span class=\"line\"><span class=\"comment\">// console.log(undefined instanceof Undefined);</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure>\n<p>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；<br>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们也可以试着实现一下 instanceof</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_instanceof</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 由于instance要检测的是某对象，需要有一个前置判断条件</span></span><br><span class=\"line\">  <span class=\"comment\">//基本数据类型直接返回false</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> left !== <span class=\"string\">'object'</span> || left === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获得类型的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prototype = right.prototype</span><br><span class=\"line\">  <span class=\"comment\">// 获得对象的原型</span></span><br><span class=\"line\">  left = left.__proto__</span><br><span class=\"line\">  <span class=\"comment\">// 判断对象的类型是否等于类型的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left === <span class=\"literal\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prototype === left)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    left = left.__proto__</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof(<span class=\"literal\">null</span>, <span class=\"built_in\">Array</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof([], <span class=\"built_in\">Array</span>)) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof(<span class=\"string\">''</span>, <span class=\"built_in\">Array</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'test'</span>, _instanceof(&#123;&#125;, <span class=\"built_in\">Object</span>)) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"number\">2</span>).constructor === <span class=\"built_in\">Number</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"literal\">true</span>).constructor === <span class=\"built_in\">Boolean</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"string\">'str'</span>).constructor === <span class=\"built_in\">String</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(([]).constructor === <span class=\"built_in\">Array</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;).constructor === <span class=\"built_in\">Function</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((&#123;&#125;).constructor === <span class=\"built_in\">Object</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>如果创建一个对象，更改它的原型，constructor就会变得不可靠了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> f=<span class=\"keyword\">new</span> Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.constructor===Fn);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f.constructor===<span class=\"built_in\">Array</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a>Object.prototype.toString.call()</h2><p>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString(&#123;&#125;)       <span class=\"comment\">// \"[object Object]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(&#123;&#125;)  <span class=\"comment\">// 同上结果，加上call也ok</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">1</span>)    <span class=\"comment\">// \"[object Number]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"string\">'1'</span>)  <span class=\"comment\">// \"[object String]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">true</span>)  <span class=\"comment\">// \"[object Boolean]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)  <span class=\"comment\">// \"[object Function]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">null</span>)   <span class=\"comment\">//\"[object Null]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">undefined</span>) <span class=\"comment\">//\"[object Undefined]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"regexp\">/123/g</span>)    <span class=\"comment\">//\"[object RegExp]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()) <span class=\"comment\">//\"[object Date]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([])       <span class=\"comment\">//\"[object Array]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">document</span>)  <span class=\"comment\">//\"[object HTMLDocument]\"</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">window</span>)   <span class=\"comment\">//\"[object Window]\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typeOf1</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> type  = <span class=\"keyword\">typeof</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type !== <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj).replace(<span class=\"regexp\">/^\\[object (\\S+)\\]$/</span>, <span class=\"string\">'$1'</span>);  <span class=\"comment\">// 注意正则中间有个空格</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typeOf2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>).toLowerCase()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>typeof<ul>\n<li>直接在计算机底层基于数据类型的值（二进制）进行检测</li>\n<li>typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象</li>\n<li>typeof 普通对象/数组对象/正则对象/日期对象 都是object</li>\n<li>typeof NaN === ‘number’</li>\n</ul>\n</li>\n<li>instanceof<ul>\n<li>检测当前实例是否属于这个类的</li>\n<li>底层机制：只要当前类出现在实例的原型上，结果都是true</li>\n<li>不能检测基本数据类型</li>\n</ul>\n</li>\n<li>constructor<ul>\n<li>支持基本类型</li>\n<li>constructor可以随便改，也不准</li>\n</ul>\n</li>\n<li>Object.prototype.toString.call([val])<ul>\n<li>返回当前实例所属类信息</li>\n</ul>\n</li>\n</ul>\n<p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p>\n<ul>\n<li>基本类型(null): 使用 String(null)</li>\n<li>基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可</li>\n<li>其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断</li>\n</ul>","categories":[],"tags":[{"name":"js","path":"api/tags/js.json"}]}